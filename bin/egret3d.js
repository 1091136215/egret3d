"use strict";
var __reflect = (this && this.__reflect) || function (p, c, t) {
    p.__class__ = c, t ? t.push(c) : t = [c], p.__types__ = p.__types__ ? t.concat(p.__types__) : t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __extends = this && this.__extends || function __extends(t, e) { 
 function r() { 
 this.constructor = t;
}
for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
r.prototype = e.prototype, t.prototype = new r();
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var paper;
(function (paper) {
    /**
     * @internal
     */
    paper._executeInEditModeComponents = [];
    /**
     * @internal
     */
    paper._disallowMultipleComponents = [];
    /**
     * @internal
     */
    paper._requireComponents = {};
    var _tagA = [];
    var _tagB = [];
    var _tagC = [];
    /**
     * 标记序列化分类
     * 如果没有标记序列化分类，序列化后的对象只会收集在objects中
     * 如果被标记了某种序列化分类，序列化后的对象还会被单独收集到一个新的数组中，key即为类名
     * @internal
     */
    function serializedType(type) {
        return function (clazz) {
            var classPrototype = clazz.prototype;
            if (_tagA.indexOf(classPrototype) >= 0) {
                var types = classPrototype["__serializedType" /* SerializedType */];
                if (types.indexOf(type) < 0) {
                    types.push(type);
                }
            }
            else {
                classPrototype["__serializedType" /* SerializedType */] = [type];
                _tagA.push(classPrototype);
            }
        };
    }
    paper.serializedType = serializedType;
    /**
     * 标记序列化属性
     * 通过装饰器标记需要序列化的属性
     */
    function serializedField(classPrototype, type) {
        if (_tagB.indexOf(classPrototype) >= 0) {
            var types = classPrototype["__serialized" /* Serialized */];
            if (types.indexOf(type) < 0) {
                types.push(type);
            }
        }
        else {
            classPrototype["__serialized" /* Serialized */] = [type];
            _tagB.push(classPrototype);
        }
    }
    paper.serializedField = serializedField;
    /**
     * 标记反序列化时需要忽略的属性
     * 通过装饰器标记反序列化时需要被忽略的属性（但属性中引用的对象依然会被实例化）
     */
    function deserializedIgnore(classPrototype, type) {
        if (_tagC.indexOf(classPrototype) >= 0) {
            var types = classPrototype["__deserializedIgnore" /* DeserializedIgnore */];
            if (types.indexOf(type) < 0) {
                types.push(type);
            }
        }
        else {
            classPrototype["__deserializedIgnore" /* DeserializedIgnore */] = [type];
            _tagC.push(classPrototype);
        }
    }
    paper.deserializedIgnore = deserializedIgnore;
    /**
     * 标记脚本组件是否在编辑模式也拥有生命周期。
     */
    function executeInEditMode(target) {
        paper._executeInEditModeComponents.push(target);
    }
    paper.executeInEditMode = executeInEditMode;
    /**
     *
     */
    function disallowMultipleComponent(target) {
        paper._disallowMultipleComponents.push(target);
    }
    paper.disallowMultipleComponent = disallowMultipleComponent;
    /**
     *
     */
    function requireComponent(requireTarget) {
        return function (target) {
            var key = egret.getQualifiedClassName(target);
            var components = key in paper._requireComponents ? paper._requireComponents[key] : (paper._requireComponents[key] = []);
            components.push(requireTarget);
        };
    }
    paper.requireComponent = requireComponent;
})(paper || (paper = {}));
var paper;
(function (paper) {
    var _hashCount = 1;
    /**
     * 生成 uuid 的方式。
     */
    paper.createUUID = function () {
        return (_hashCount++).toString();
    };
    /**
     * 可序列化对象。
     */
    var SerializableObject = (function () {
        function SerializableObject() {
            this.uuid = paper.createUUID();
            /**
             * @internal
             */
            this.assetUUid = paper.createUUID();
        }
        SerializableObject.prototype.serialize = function () {
            console.warn("Unimplemented serialize method.");
        };
        SerializableObject.prototype.deserialize = function (element) {
            console.warn("Unimplemented deserialize method.");
        };
        __decorate([
            paper.serializedField
        ], SerializableObject.prototype, "uuid", void 0);
        __decorate([
            paper.serializedField
        ], SerializableObject.prototype, "assetUUid", void 0);
        return SerializableObject;
    }());
    paper.SerializableObject = SerializableObject;
    __reflect(SerializableObject.prototype, "paper.SerializableObject", ["paper.IUUID", "paper.ISerializable"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var Vector3 = (function () {
        function Vector3(x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            this.x = x;
            this.y = y;
            this.z = z;
        }
        Vector3.prototype.serialize = function () {
            return [this.x, this.y, this.z];
        };
        Vector3.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.z = element[2];
        };
        Vector3.prototype.copy = function (value) {
            this.x = value.x;
            this.y = value.y;
            this.z = value.z;
            return this;
        };
        Vector3.prototype.clone = function () {
            var value = new Vector3();
            value.copy(this);
            return value;
        };
        Vector3.prototype.set = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        Vector3.prototype.normalize = function () {
            var l = this.length;
            if (l > Number.MIN_VALUE) {
                this.x /= l;
                this.y /= l;
                this.z /= l;
            }
            else {
                this.x = 1.0;
                this.y = 0.0;
                this.z = 0.0;
            }
            return this;
        };
        Vector3.prototype.scale = function (scale) {
            this.x *= scale;
            this.y *= scale;
            this.z *= scale;
            return this;
        };
        Vector3.prototype.add = function (value) {
            this.x += value.x;
            this.y += value.y;
            this.z += value.z;
            return this;
        };
        Vector3.prototype.subtract = function (value) {
            this.x -= value.x;
            this.y -= value.y;
            this.z -= value.z;
            return this;
        };
        Vector3.prototype.multiply = function (value) {
            this.x *= value.x;
            this.y *= value.y;
            this.z *= value.z;
            return this;
        };
        Vector3.prototype.cross = function (rhs) {
            var x = this.x;
            var y = this.y;
            var z = this.z;
            this.x = y * rhs.z - z * rhs.y;
            this.y = z * rhs.x - x * rhs.z;
            this.z = x * rhs.y - y * rhs.x;
            return this;
        };
        Vector3.prototype.dot = function (value) {
            return this.x * value.x + this.y * value.y + this.z * value.z;
        };
        Vector3.prototype.equal = function (value, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(this.x - value.x) > threshold) {
                return false;
            }
            if (Math.abs(this.y - value.y) > threshold) {
                return false;
            }
            if (Math.abs(this.z - value.z) > threshold) {
                return false;
            }
            return true;
        };
        Vector3.prototype.getDistance = function (value) {
            return egret3d.helpVector3H.copy(this).subtract(value).length;
        };
        Object.defineProperty(Vector3.prototype, "length", {
            get: function () {
                return Math.sqrt(this.sqrtLength);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3.prototype, "sqrtLength", {
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            enumerable: true,
            configurable: true
        });
        Vector3.set = function (x, y, z, out) {
            out.x = x;
            out.y = y;
            out.z = z;
            return out;
        };
        Vector3.normalize = function (v) {
            var num = Vector3.getLength(v);
            if (num > Number.MIN_VALUE) {
                v.x = v.x / num;
                v.y = v.y / num;
                v.z = v.z / num;
            }
            else {
                v.x = 1.0;
                v.y = 0.0;
                v.z = 0.0;
            }
            return v;
        };
        Vector3.copy = function (v, out) {
            out.x = v.x;
            out.y = v.y;
            out.z = v.z;
            return out;
        };
        Vector3.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            out.z = v1.z + v2.z;
            return out;
        };
        Vector3.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            out.z = v1.z - v2.z;
            return out;
        };
        Vector3.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            out.z = v1.z * v2.z;
            return out;
        };
        Vector3.scale = function (v, scale) {
            v.x = v.x * scale;
            v.y = v.y * scale;
            v.z = v.z * scale;
            return v;
        };
        Vector3.cross = function (lhs, rhs, out) {
            out.x = lhs.y * rhs.z - lhs.z * rhs.y;
            out.y = lhs.z * rhs.x - lhs.x * rhs.z;
            out.z = lhs.x * rhs.y - lhs.y * rhs.x;
            return out;
        };
        Vector3.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        };
        Vector3.getLength = function (v) {
            return Math.sqrt(this.getSqrLength(v));
        };
        Vector3.getSqrLength = function (v) {
            return v.x * v.x + v.y * v.y + v.z * v.z;
        };
        Vector3.getDistance = function (a, b) {
            this.subtract(a, b, egret3d.helpVector3H);
            return this.getLength(egret3d.helpVector3H);
        };
        Vector3.min = function (v1, v2, out) {
            out.x = Math.min(v1.x, v2.x);
            out.y = Math.min(v1.y, v2.y);
            out.z = Math.min(v1.z, v2.z);
            return out;
        };
        Vector3.max = function (v1, v2, out) {
            out.x = Math.max(v1.x, v2.x);
            out.y = Math.max(v1.y, v2.y);
            out.z = Math.max(v1.z, v2.z);
            return out;
        };
        Vector3.lerp = function (v1, v2, v, out) {
            out.x = v1.x * (1 - v) + v2.x * v;
            out.y = v1.y * (1 - v) + v2.y * v;
            out.z = v1.z * (1 - v) + v2.z * v;
            return out;
        };
        Vector3.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            if (Math.abs(v1.z - v2.z) > threshold) {
                return false;
            }
            return true;
        };
        Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);
        Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
        Vector3.UP = new Vector3(0.0, 1.0, 0.0);
        Vector3.DOWN = new Vector3(0.0, -1.0, 0.0);
        Vector3.LEFT = new Vector3(-1.0, 0.0, 0.0);
        Vector3.RIGHT = new Vector3(1.0, 0.0, 0.0);
        Vector3.FORWARD = new Vector3(0.0, 0.0, 1.0);
        Vector3.BACK = new Vector3(0.0, 0.0, -1.0);
        return Vector3;
    }());
    egret3d.Vector3 = Vector3;
    __reflect(Vector3.prototype, "egret3d.Vector3", ["paper.ISerializable"]);
    egret3d.helpVector3A = new Vector3();
    egret3d.helpVector3B = new Vector3();
    egret3d.helpVector3C = new Vector3();
    egret3d.helpVector3D = new Vector3();
    egret3d.helpVector3E = new Vector3();
    egret3d.helpVector3F = new Vector3();
    egret3d.helpVector3G = new Vector3();
    egret3d.helpVector3H = new Vector3();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**属性信息 */
        var PropertyInfo = (function () {
            function PropertyInfo(name, editType, option) {
                this.name = name;
                this.editType = editType;
                this.option = option;
            }
            return PropertyInfo;
        }());
        editor.PropertyInfo = PropertyInfo;
        __reflect(PropertyInfo.prototype, "paper.editor.PropertyInfo");
        /**编辑类型 */
        var EditType;
        (function (EditType) {
            /**数字输入 */
            EditType[EditType["NUMBER"] = 0] = "NUMBER";
            /**文本输入 */
            EditType[EditType["TEXT"] = 1] = "TEXT";
            /**选中框 */
            EditType[EditType["CHECKBOX"] = 2] = "CHECKBOX";
            /**vertor2 */
            EditType[EditType["VECTOR2"] = 3] = "VECTOR2";
            /**vertor3 */
            EditType[EditType["VECTOR3"] = 4] = "VECTOR3";
            /**vertor4 */
            EditType[EditType["VECTOR4"] = 5] = "VECTOR4";
            /**Quaternion */
            EditType[EditType["QUATERNION"] = 6] = "QUATERNION";
            /**颜色选择器 */
            EditType[EditType["COLOR"] = 7] = "COLOR";
            /**下拉 */
            EditType[EditType["LIST"] = 8] = "LIST";
            /**Rect */
            EditType[EditType["RECT"] = 9] = "RECT";
            /**材质 */
            EditType[EditType["MATERIAL"] = 10] = "MATERIAL";
            /**材质数组 */
            EditType[EditType["MATERIAL_ARRAY"] = 11] = "MATERIAL_ARRAY";
            /**游戏对象 */
            EditType[EditType["GAMEOBJECT"] = 12] = "GAMEOBJECT";
            /**变换 */
            EditType[EditType["TRANSFROM"] = 13] = "TRANSFROM";
            /**声音 */
            EditType[EditType["SOUND"] = 14] = "SOUND";
            /**Mesh */
            EditType[EditType["MESH"] = 15] = "MESH";
            /**shader */
            EditType[EditType["SHADER"] = 16] = "SHADER";
            /**数组 */
            EditType[EditType["ARRAY"] = 17] = "ARRAY";
        })(EditType = editor.EditType || (editor.EditType = {}));
        var customMap = {};
        /**
         * 装饰器:自定义
         */
        function custom() {
            return function (target) {
                customMap[target.name] = true;
            };
        }
        editor.custom = custom;
        var propertyMap = {};
        /**
         * 装饰器:属性
         * @param editType 编辑类型
         */
        function property(editType, option) {
            return function (target, property) {
                if (!propertyMap[target.constructor.name]) {
                    propertyMap[target.constructor.name] = {
                        extends: target.__proto__.constructor.name,
                        propertyList: [],
                    };
                }
                if (editType !== undefined) {
                    propertyMap[target.constructor.name].propertyList.push(new PropertyInfo(property, editType, option));
                }
                else {
                    //TODO:自动分析编辑类型
                }
            };
        }
        editor.property = property;
        /**
         * 检测一个实例对象是否为已被自定义
         * @param classInstance 实例对象
         */
        function isCustom(classInstance) {
            return customMap[classInstance.constructor.name] ? true : false;
        }
        editor.isCustom = isCustom;
        /**
         * 获取一个实例对象的编辑信息
         * @param classInstance 实例对象
         */
        function getEditInfo(classInstance) {
            var className = classInstance.constructor.name;
            function _getEditInfo(className) {
                var classInfo = propertyMap[className];
                if (classInfo) {
                    var extendsInfo = _getEditInfo(classInfo.extends);
                    extendsInfo = extendsInfo.concat(classInfo.propertyList);
                    return extendsInfo;
                }
                return [];
            }
            return _getEditInfo(className);
        }
        editor.getEditInfo = getEditInfo;
        var extraPropertyMap = {};
        /**
         * 装饰器:属性
         * @param editType 编辑类型
         */
        function extraProperty(editType, option) {
            return function (target, property) {
                if (!extraPropertyMap[target.constructor.name]) {
                    extraPropertyMap[target.constructor.name] = {
                        extends: target.__proto__.constructor.name,
                        propertyList: [],
                    };
                }
                if (editType !== undefined) {
                    extraPropertyMap[target.constructor.name].propertyList.push(new PropertyInfo(property, editType, option));
                }
                else {
                    //TODO:自动分析编辑类型
                }
            };
        }
        editor.extraProperty = extraProperty;
        /**
         * 额外信息
         * @param classInstance 实例对象
         */
        function getExtraInfo(classInstance) {
            var className = classInstance.constructor.name;
            function _getExtraInfo(className) {
                var classInfo = extraPropertyMap[className];
                if (classInfo) {
                    var extendsInfo = _getExtraInfo(classInfo.extends);
                    extendsInfo = extendsInfo.concat(classInfo.propertyList);
                    return extendsInfo;
                }
                return [];
            }
            return _getExtraInfo(className);
        }
        editor.getExtraInfo = getExtraInfo;
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var _helpVectorA = new egret3d.Vector3();
    var Matrix = (function () {
        function Matrix(rawData) {
            if (rawData === void 0) { rawData = null; }
            if (rawData) {
                this.rawData = rawData;
            }
            else {
                this.rawData = new Float32Array([
                    1.0, 0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    0.0, 0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0, 1.0
                ]);
            }
        }
        Matrix.prototype.copy = function (value) {
            var fromRawData = value.rawData;
            var toRawData = this.rawData;
            toRawData[0] = fromRawData[0];
            toRawData[1] = fromRawData[1];
            toRawData[2] = fromRawData[2];
            toRawData[3] = fromRawData[3];
            toRawData[4] = fromRawData[4];
            toRawData[5] = fromRawData[5];
            toRawData[6] = fromRawData[6];
            toRawData[7] = fromRawData[7];
            toRawData[8] = fromRawData[8];
            toRawData[9] = fromRawData[9];
            toRawData[10] = fromRawData[10];
            toRawData[11] = fromRawData[11];
            toRawData[12] = fromRawData[12];
            toRawData[13] = fromRawData[13];
            toRawData[14] = fromRawData[14];
            toRawData[15] = fromRawData[15];
            return this;
        };
        Matrix.prototype.clone = function () {
            var value = new Matrix();
            value.copy(this);
            return value;
        };
        Matrix.prototype.set = function (n11, n21, n31, n41, n12, n22, n32, n42, n13, n23, n33, n43, n14, n24, n34, n44) {
            this.rawData[0] = n11;
            this.rawData[1] = n12;
            this.rawData[2] = n13;
            this.rawData[3] = n14;
            this.rawData[4] = n21;
            this.rawData[5] = n22;
            this.rawData[6] = n23;
            this.rawData[7] = n24;
            this.rawData[8] = n31;
            this.rawData[9] = n32;
            this.rawData[10] = n33;
            this.rawData[11] = n34;
            this.rawData[12] = n41;
            this.rawData[13] = n42;
            this.rawData[14] = n43;
            this.rawData[15] = n44;
            return this;
        };
        Matrix.prototype.set3x3 = function (n11, n21, n31, n12, n22, n32, n13, n23, n33) {
            this.rawData[0] = n11;
            this.rawData[1] = n12;
            this.rawData[2] = n13;
            this.rawData[4] = n21;
            this.rawData[5] = n22;
            this.rawData[6] = n23;
            this.rawData[8] = n31;
            this.rawData[9] = n32;
            this.rawData[10] = n33;
            return this;
        };
        Matrix.prototype.setTranslation = function (translation) {
            this.rawData[12] = translation.x;
            this.rawData[13] = translation.y;
            this.rawData[14] = translation.z;
            this.rawData[15] = 1.0;
            return this;
        };
        Matrix.prototype.identity = function () {
            this.rawData[0] = 1.0;
            this.rawData[1] = 0.0;
            this.rawData[2] = 0.0;
            this.rawData[3] = 0.0;
            this.rawData[4] = 0.0;
            this.rawData[5] = 1.0;
            this.rawData[6] = 0.0;
            this.rawData[7] = 0.0;
            this.rawData[8] = 0.0;
            this.rawData[9] = 0.0;
            this.rawData[10] = 1.0;
            this.rawData[11] = 0.0;
            this.rawData[12] = 0.0;
            this.rawData[13] = 0.0;
            this.rawData[14] = 0.0;
            this.rawData[15] = 1.0;
            return this;
        };
        Matrix.prototype.inverse = function () {
            var l1 = this.rawData[0];
            var l2 = this.rawData[1];
            var l3 = this.rawData[2];
            var l4 = this.rawData[3];
            var l5 = this.rawData[4];
            var l6 = this.rawData[5];
            var l7 = this.rawData[6];
            var l8 = this.rawData[7];
            var l9 = this.rawData[8];
            var l10 = this.rawData[9];
            var l11 = this.rawData[10];
            var l12 = this.rawData[11];
            var l13 = this.rawData[12];
            var l14 = this.rawData[13];
            var l15 = this.rawData[14];
            var l16 = this.rawData[15];
            var l17 = (l11 * l16) - (l12 * l15);
            var l18 = (l10 * l16) - (l12 * l14);
            var l19 = (l10 * l15) - (l11 * l14);
            var l20 = (l9 * l16) - (l12 * l13);
            var l21 = (l9 * l15) - (l11 * l13);
            var l22 = (l9 * l14) - (l10 * l13);
            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);
            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));
            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);
            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));
            var l27 = 1.0 / ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));
            var l28 = (l7 * l16) - (l8 * l15);
            var l29 = (l6 * l16) - (l8 * l14);
            var l30 = (l6 * l15) - (l7 * l14);
            var l31 = (l5 * l16) - (l8 * l13);
            var l32 = (l5 * l15) - (l7 * l13);
            var l33 = (l5 * l14) - (l6 * l13);
            var l34 = (l7 * l12) - (l8 * l11);
            var l35 = (l6 * l12) - (l8 * l10);
            var l36 = (l6 * l11) - (l7 * l10);
            var l37 = (l5 * l12) - (l8 * l9);
            var l38 = (l5 * l11) - (l7 * l9);
            var l39 = (l5 * l10) - (l6 * l9);
            var rawData = this.rawData;
            rawData[0] = l23 * l27;
            rawData[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;
            rawData[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;
            rawData[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;
            rawData[4] = l24 * l27;
            rawData[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;
            rawData[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;
            rawData[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;
            rawData[8] = l25 * l27;
            rawData[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;
            rawData[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;
            rawData[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;
            rawData[12] = l26 * l27;
            rawData[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;
            rawData[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;
            rawData[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;
            return this;
        };
        Matrix.prototype.transformVector3 = function (value) {
            var x = (value.x * this.rawData[0]) + (value.y * this.rawData[4]) + (value.z * this.rawData[8]) + this.rawData[12];
            var y = (value.x * this.rawData[1]) + (value.y * this.rawData[5]) + (value.z * this.rawData[9]) + this.rawData[13];
            var z = (value.x * this.rawData[2]) + (value.y * this.rawData[6]) + (value.z * this.rawData[10]) + this.rawData[14];
            var w = (value.x * this.rawData[3]) + (value.y * this.rawData[7]) + (value.z * this.rawData[11]) + this.rawData[15];
            value.x = x / w;
            value.y = y / w;
            value.z = z / w;
            return value;
        };
        Matrix.prototype.transformNormal = function (value) {
            var x = (value.x * this.rawData[0]) + (value.y * this.rawData[4]) + (value.z * this.rawData[8]);
            var y = (value.x * this.rawData[1]) + (value.y * this.rawData[5]) + (value.z * this.rawData[9]);
            var z = (value.x * this.rawData[2]) + (value.y * this.rawData[6]) + (value.z * this.rawData[10]);
            value.x = x;
            value.y = y;
            value.z = z;
            return value;
        };
        Matrix.set = function (n11, n21, n31, n41, n12, n22, n32, n42, n13, n23, n33, n43, n14, n24, n34, n44, result) {
            var rawData = result.rawData;
            rawData[0] = n11;
            rawData[1] = n12;
            rawData[2] = n13;
            rawData[3] = n14;
            rawData[4] = n21;
            rawData[5] = n22;
            rawData[6] = n23;
            rawData[7] = n24;
            rawData[8] = n31;
            rawData[9] = n32;
            rawData[10] = n33;
            rawData[11] = n34;
            rawData[12] = n41;
            rawData[13] = n42;
            rawData[14] = n43;
            rawData[15] = n44;
            return result;
        };
        Matrix.getScale = function (m, out) {
            out.x = m.rawData[0];
            out.y = m.rawData[5];
            out.z = m.rawData[10];
            return out;
        };
        Matrix.getTranslation = function (m, out) {
            out.x = m.rawData[12];
            out.y = m.rawData[13];
            out.z = m.rawData[14];
            return out;
        };
        Matrix.getQuaternion = function (m, out) {
            var data = m.rawData;
            var m11 = data[0], m12 = data[4], m13 = data[8];
            var m21 = data[1], m22 = data[5], m23 = data[9];
            var m31 = data[2], m32 = data[6], m33 = data[10];
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                out.w = 0.25 / s;
                out.x = (m32 - m23) * s;
                out.y = (m13 - m31) * s;
                out.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                out.w = (m32 - m23) / s;
                out.x = 0.25 * s;
                out.y = (m12 + m21) / s;
                out.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                out.w = (m13 - m31) / s;
                out.x = (m12 + m21) / s;
                out.y = 0.25 * s;
                out.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                out.w = (m21 - m12) / s;
                out.x = (m13 + m31) / s;
                out.y = (m23 + m32) / s;
                out.z = 0.25 * s;
            }
            return out;
        };
        Matrix.add = function (left, right, out) {
            out.rawData[0] = left.rawData[0] + right.rawData[0];
            out.rawData[1] = left.rawData[1] + right.rawData[1];
            out.rawData[2] = left.rawData[2] + right.rawData[2];
            out.rawData[3] = left.rawData[3] + right.rawData[3];
            out.rawData[4] = left.rawData[4] + right.rawData[4];
            out.rawData[5] = left.rawData[5] + right.rawData[5];
            out.rawData[6] = left.rawData[6] + right.rawData[6];
            out.rawData[7] = left.rawData[7] + right.rawData[7];
            out.rawData[8] = left.rawData[8] + right.rawData[8];
            out.rawData[9] = left.rawData[9] + right.rawData[9];
            out.rawData[10] = left.rawData[10] + right.rawData[10];
            out.rawData[11] = left.rawData[11] + right.rawData[11];
            out.rawData[12] = left.rawData[12] + right.rawData[12];
            out.rawData[13] = left.rawData[13] + right.rawData[13];
            out.rawData[14] = left.rawData[14] + right.rawData[14];
            out.rawData[15] = left.rawData[15] + right.rawData[15];
            return out;
        };
        Matrix.multiply = function (lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = lhs.rawData[2], a03 = lhs.rawData[3];
            var a10 = lhs.rawData[4], a11 = lhs.rawData[5], a12 = lhs.rawData[6], a13 = lhs.rawData[7];
            var a20 = lhs.rawData[8], a21 = lhs.rawData[9], a22 = lhs.rawData[10], a23 = lhs.rawData[11];
            var a30 = lhs.rawData[12], a31 = lhs.rawData[13], a32 = lhs.rawData[14], a33 = lhs.rawData[15];
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b2 = rhs.rawData[2], b3 = rhs.rawData[3];
            out.rawData[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b2 = rhs.rawData[6];
            b3 = rhs.rawData[7];
            out.rawData[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[8];
            b1 = rhs.rawData[9];
            b2 = rhs.rawData[10];
            b3 = rhs.rawData[11];
            out.rawData[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[12];
            b1 = rhs.rawData[13];
            b2 = rhs.rawData[14];
            b3 = rhs.rawData[15];
            out.rawData[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            return out;
        };
        Matrix.scale = function (scaler, m) {
            m.rawData[0] *= scaler;
            m.rawData[1] *= scaler;
            m.rawData[2] *= scaler;
            m.rawData[3] *= scaler;
            m.rawData[4] *= scaler;
            m.rawData[5] *= scaler;
            m.rawData[6] *= scaler;
            m.rawData[7] *= scaler;
            m.rawData[8] *= scaler;
            m.rawData[9] *= scaler;
            m.rawData[10] *= scaler;
            m.rawData[11] *= scaler;
            m.rawData[12] *= scaler;
            m.rawData[13] *= scaler;
            m.rawData[14] *= scaler;
            m.rawData[15] *= scaler;
            return m;
        };
        Matrix.transpose = function (m, out) {
            out.rawData[1] = m.rawData[4];
            out.rawData[2] = m.rawData[8];
            out.rawData[3] = m.rawData[12];
            out.rawData[4] = m.rawData[1];
            out.rawData[6] = m.rawData[9];
            out.rawData[7] = m.rawData[13];
            out.rawData[8] = m.rawData[2];
            out.rawData[9] = m.rawData[6];
            out.rawData[11] = m.rawData[14];
            out.rawData[12] = m.rawData[3];
            out.rawData[13] = m.rawData[7];
            out.rawData[14] = m.rawData[11];
            return out;
        };
        Matrix.inverse = function (src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l3 = src.rawData[2];
            var l4 = src.rawData[3];
            var l5 = src.rawData[4];
            var l6 = src.rawData[5];
            var l7 = src.rawData[6];
            var l8 = src.rawData[7];
            var l9 = src.rawData[8];
            var l10 = src.rawData[9];
            var l11 = src.rawData[10];
            var l12 = src.rawData[11];
            var l13 = src.rawData[12];
            var l14 = src.rawData[13];
            var l15 = src.rawData[14];
            var l16 = src.rawData[15];
            var l17 = (l11 * l16) - (l12 * l15);
            var l18 = (l10 * l16) - (l12 * l14);
            var l19 = (l10 * l15) - (l11 * l14);
            var l20 = (l9 * l16) - (l12 * l13);
            var l21 = (l9 * l15) - (l11 * l13);
            var l22 = (l9 * l14) - (l10 * l13);
            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);
            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));
            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);
            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));
            var l27 = 1.0 / ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));
            var l28 = (l7 * l16) - (l8 * l15);
            var l29 = (l6 * l16) - (l8 * l14);
            var l30 = (l6 * l15) - (l7 * l14);
            var l31 = (l5 * l16) - (l8 * l13);
            var l32 = (l5 * l15) - (l7 * l13);
            var l33 = (l5 * l14) - (l6 * l13);
            var l34 = (l7 * l12) - (l8 * l11);
            var l35 = (l6 * l12) - (l8 * l10);
            var l36 = (l6 * l11) - (l7 * l10);
            var l37 = (l5 * l12) - (l8 * l9);
            var l38 = (l5 * l11) - (l7 * l9);
            var l39 = (l5 * l10) - (l6 * l9);
            var rawData = out.rawData;
            rawData[0] = l23 * l27;
            rawData[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;
            rawData[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;
            rawData[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;
            rawData[4] = l24 * l27;
            rawData[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;
            rawData[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;
            rawData[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;
            rawData[8] = l25 * l27;
            rawData[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;
            rawData[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;
            rawData[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;
            rawData[12] = l26 * l27;
            rawData[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;
            rawData[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;
            rawData[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;
            return out;
        };
        Matrix.decompose = function (m, scale, rotation, translation) {
            translation.x = m.rawData[12];
            translation.y = m.rawData[13];
            translation.z = m.rawData[14];
            var xs = egret3d.sign(m.rawData[0] * m.rawData[1] * m.rawData[2] * m.rawData[3]) < 0 ? -1 : 1;
            var ys = egret3d.sign(m.rawData[4] * m.rawData[5] * m.rawData[6] * m.rawData[7]) < 0 ? -1 : 1;
            var zs = egret3d.sign(m.rawData[8] * m.rawData[9] * m.rawData[10] * m.rawData[11]) < 0 ? -1 : 1;
            scale.x = xs * Math.sqrt(m.rawData[0] * m.rawData[0] + m.rawData[1] * m.rawData[1] + m.rawData[2] * m.rawData[2]);
            scale.y = ys * Math.sqrt(m.rawData[4] * m.rawData[4] + m.rawData[5] * m.rawData[5] + m.rawData[6] * m.rawData[6]);
            scale.z = zs * Math.sqrt(m.rawData[8] * m.rawData[8] + m.rawData[9] * m.rawData[9] + m.rawData[10] * m.rawData[10]);
            if (scale.x === 0 || scale.y === 0 || scale.z === 0) {
                rotation.x = 0;
                rotation.y = 0;
                rotation.z = 0;
                rotation.w = 1;
                return false;
            }
            var mat = helpMat_1;
            mat.rawData[0] = m.rawData[0] / scale.x;
            mat.rawData[1] = m.rawData[1] / scale.x;
            mat.rawData[2] = m.rawData[2] / scale.x;
            mat.rawData[3] = 0;
            mat.rawData[4] = m.rawData[4] / scale.y;
            mat.rawData[5] = m.rawData[5] / scale.y;
            mat.rawData[6] = m.rawData[6] / scale.y;
            mat.rawData[7] = 0;
            mat.rawData[8] = m.rawData[8] / scale.z;
            mat.rawData[9] = m.rawData[9] / scale.z;
            mat.rawData[10] = m.rawData[10] / scale.z;
            mat.rawData[11] = 0;
            this.getQuaternion(mat, rotation);
            return true;
        };
        Matrix.copy = function (m, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = m.rawData[i];
            }
            return out;
        };
        Matrix.identify = function (m) {
            m.rawData[0] = 1;
            m.rawData[1] = 0;
            m.rawData[2] = 0;
            m.rawData[3] = 0;
            m.rawData[4] = 0;
            m.rawData[5] = 1;
            m.rawData[6] = 0;
            m.rawData[7] = 0;
            m.rawData[8] = 0;
            m.rawData[9] = 0;
            m.rawData[10] = 1;
            m.rawData[11] = 0;
            m.rawData[12] = 0;
            m.rawData[13] = 0;
            m.rawData[14] = 0;
            m.rawData[15] = 1;
            return m;
        };
        Matrix.zero = function (m) {
            m.rawData[0] = 0;
            m.rawData[1] = 0;
            m.rawData[2] = 0;
            m.rawData[3] = 0;
            m.rawData[4] = 0;
            m.rawData[5] = 0;
            m.rawData[6] = 0;
            m.rawData[7] = 0;
            m.rawData[8] = 0;
            m.rawData[9] = 0;
            m.rawData[10] = 0;
            m.rawData[11] = 0;
            m.rawData[12] = 0;
            m.rawData[13] = 0;
            m.rawData[14] = 0;
            m.rawData[15] = 1;
            return m;
        };
        Matrix.formScale = function (xScale, yScale, zScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0.0;
            out.rawData[4] = 0.0;
            out.rawData[5] = yScale;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = zScale;
            out.rawData[11] = 0.0;
            out.rawData[12] = 0.0;
            out.rawData[13] = 0.0;
            out.rawData[14] = 0.0;
            out.rawData[15] = 1.0;
            return out;
        };
        Matrix.fromTranslate = function (x, y, z, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0;
            out.rawData[4] = 0.0;
            out.rawData[5] = 1.0;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = 1.0;
            out.rawData[11] = 0.0;
            out.rawData[12] = x;
            out.rawData[13] = y;
            out.rawData[14] = z;
            out.rawData[15] = 1.0;
            return out;
        };
        Matrix.fromRTS = function (p, s, q, out) {
            var matS = helpMat_1;
            this.formScale(s.x, s.y, s.z, matS);
            var matR = helpMat_2;
            egret3d.Quaternion.toMatrix(q, matR);
            this.multiply(matR, matS, out);
            out.rawData[12] = p.x;
            out.rawData[13] = p.y;
            out.rawData[14] = p.z;
            out.rawData[15] = 1;
            return out;
        };
        Matrix.getVector3ByOffset = function (src, offset, result) {
            result.x = src.rawData[offset];
            result.y = src.rawData[offset + 1];
            result.z = src.rawData[offset + 2];
            return result;
        };
        Matrix.transformVector3 = function (vector, transformMatrix, result) {
            var transformMatrixRawdata = transformMatrix.rawData;
            var x = (vector.x * transformMatrixRawdata[0]) + (vector.y * transformMatrixRawdata[4]) + (vector.z * transformMatrixRawdata[8]) + transformMatrixRawdata[12];
            var y = (vector.x * transformMatrixRawdata[1]) + (vector.y * transformMatrixRawdata[5]) + (vector.z * transformMatrixRawdata[9]) + transformMatrixRawdata[13];
            var z = (vector.x * transformMatrixRawdata[2]) + (vector.y * transformMatrixRawdata[6]) + (vector.z * transformMatrixRawdata[10]) + transformMatrixRawdata[14];
            var w = (vector.x * transformMatrixRawdata[3]) + (vector.y * transformMatrixRawdata[7]) + (vector.z * transformMatrixRawdata[11]) + transformMatrixRawdata[15];
            result.x = x / w;
            result.y = y / w;
            result.z = z / w;
            return result;
        };
        Matrix.transformNormal = function (vector, transformMatrix, result) {
            var transformMatrixRawdata = transformMatrix.rawData;
            var x = (vector.x * transformMatrixRawdata[0]) + (vector.y * transformMatrixRawdata[4]) + (vector.z * transformMatrixRawdata[8]);
            var y = (vector.x * transformMatrixRawdata[1]) + (vector.y * transformMatrixRawdata[5]) + (vector.z * transformMatrixRawdata[9]);
            var z = (vector.x * transformMatrixRawdata[2]) + (vector.y * transformMatrixRawdata[6]) + (vector.z * transformMatrixRawdata[10]);
            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        };
        Matrix.lerp = function (left, right, v, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = left.rawData[i] * (1 - v) + right.rawData[i] * v;
            }
            return out;
        };
        Matrix.perspectiveProjectLH = function (fov, aspect, znear, zfar, out) {
            var tan = 1.0 / (Math.tan(fov * 0.5));
            out.rawData[0] = tan / aspect;
            out.rawData[1] = out.rawData[2] = out.rawData[3] = 0.0;
            out.rawData[4] = out.rawData[6] = out.rawData[7] = 0.0;
            out.rawData[5] = tan;
            out.rawData[8] = out.rawData[9] = 0.0;
            out.rawData[10] = (zfar + znear) / (zfar - znear);
            out.rawData[11] = 1.0;
            out.rawData[12] = out.rawData[13] = out.rawData[15] = 0.0;
            out.rawData[14] = -2 * (znear * zfar) / (zfar - znear);
            return out;
        };
        Matrix.orthoProjectLH = function (width, height, znear, zfar, out) {
            var hw = 2.0 / width;
            var hh = 2.0 / height;
            var id = 2.0 / (zfar - znear);
            var nid = (znear + zfar) / (znear - zfar);
            out.rawData[0] = hw;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = hh;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = id;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = nid;
            out.rawData[15] = 1;
            return out;
        };
        Matrix.toEulerAngles = function (matrix, out) {
            var x, y, z, sx, sy, sz, m, halfPi;
            var scale = _helpVectorA;
            Matrix.getScale(matrix, scale);
            sx = scale.x;
            sy = scale.y;
            sz = scale.z;
            m = matrix.rawData;
            y = Math.asin(-m[2] / sx);
            halfPi = Math.PI * 0.5;
            if (y < halfPi) {
                if (y > -halfPi) {
                    x = Math.atan2(m[6] / sy, m[10] / sz);
                    z = Math.atan2(m[1] / sx, m[0] / sx);
                }
                else {
                    // Not a unique solution
                    z = 0;
                    x = -Math.atan2(m[4] / sy, m[5] / sy);
                }
            }
            else {
                // Not a unique solution
                z = 0;
                x = Math.atan2(m[4] / sy, m[5] / sy);
            }
            out.x = x * 180 / Math.PI;
            out.y = y * 180 / Math.PI;
            out.z = z * 180 / Math.PI;
            return out;
        };
        Matrix.determinant = function (matrix) {
            var te = matrix.rawData;
            var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
            var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
            var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
            var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
            //TODO: make this more efficient
            //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
            return (n41 * (+n14 * n23 * n32 -
                n13 * n24 * n32 -
                n14 * n22 * n33 +
                n12 * n24 * n33 +
                n13 * n22 * n34 -
                n12 * n23 * n34) +
                n42 * (+n11 * n23 * n34 -
                    n11 * n24 * n33 +
                    n14 * n21 * n33 -
                    n13 * n21 * n34 +
                    n13 * n24 * n31 -
                    n14 * n23 * n31) +
                n43 * (+n11 * n24 * n32 -
                    n11 * n22 * n34 -
                    n14 * n21 * n32 +
                    n12 * n21 * n34 +
                    n14 * n22 * n31 -
                    n12 * n24 * n31) +
                n44 * (-n13 * n22 * n31 -
                    n11 * n23 * n32 +
                    n11 * n22 * n33 +
                    n13 * n21 * n32 -
                    n12 * n21 * n33 +
                    n12 * n23 * n31));
        };
        return Matrix;
    }());
    egret3d.Matrix = Matrix;
    __reflect(Matrix.prototype, "egret3d.Matrix");
    var helpMat_1 = new Matrix();
    var helpMat_2 = new Matrix();
    egret3d.helpMatrixA = new Matrix();
    egret3d.helpMatrixB = new Matrix();
    egret3d.helpMatrixC = new Matrix();
    egret3d.helpMatrixD = new Matrix();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 组件基类
     */
    var BaseComponent = (function (_super) {
        __extends(BaseComponent, _super);
        function BaseComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 组件挂载的 GameObject
             */
            _this.gameObject = BaseComponent._injectGameObject;
            _this._enabled = true;
            return _this;
        }
        /**
         * 添加组件后，组件内部初始化。
         * - 重载此方法时，必须调用 `super.initialize()`。
         */
        BaseComponent.prototype.initialize = function (config) {
        };
        /**
         * 移除组件后，组件内部卸载。
         * - 重载此方法时，必须调用 `super.uninitialize()`。
         */
        BaseComponent.prototype.uninitialize = function () {
        };
        BaseComponent.prototype.serialize = function () {
            var target = paper.serializeRC(this);
            target._enabled = this._enabled;
            if (this.assetUUid) {
                target.assetUUid = this.assetUUid;
            }
            return target;
        };
        BaseComponent.prototype.deserialize = function (element) {
            this._enabled = element._enabled === false ? false : true;
            if (element.uuid) {
                this.uuid = element.uuid;
            }
            if (element.assetUUid) {
                this.assetUUid = element.assetUUid;
            }
        };
        Object.defineProperty(BaseComponent.prototype, "isDestroyed", {
            /**
             *
             */
            get: function () {
                return !this.gameObject;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "enabled", {
            /**
             * 组件的激活状态。
             */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._enabled === value) {
                    return;
                }
                var prevEnabled = this.isActiveAndEnabled;
                this._enabled = value;
                var currentEnabled = this.isActiveAndEnabled;
                if (currentEnabled !== prevEnabled) {
                    paper.EventPool.dispatchEvent(currentEnabled ? "__enabled__" /* Enabled */ : "__disabled__" /* Disabled */, this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "isActiveAndEnabled", {
            /**
             * 组件在场景的激活状态。
             */
            get: function () {
                // return this._enabled && this.gameObject.activeInHierarchy;
                return this._enabled && (this.gameObject._activeDirty ? this.gameObject.activeInHierarchy : this.gameObject._activeInHierarchy);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "_enabled", void 0);
        return BaseComponent;
    }(paper.SerializableObject));
    paper.BaseComponent = BaseComponent;
    __reflect(BaseComponent.prototype, "paper.BaseComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var Vector2 = (function () {
        function Vector2(x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            this.x = x;
            this.y = y;
        }
        Vector2.prototype.serialize = function () {
            return [this.x, this.y];
        };
        Vector2.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
        };
        Vector2.prototype.copy = function (value) {
            this.x = value.x;
            this.y = value.y;
            return this;
        };
        Vector2.prototype.clone = function () {
            var value = new Vector2();
            value.copy(this);
            return value;
        };
        Vector2.prototype.set = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        Vector2.prototype.normalize = function () {
            var l = this.length;
            if (l > Number.MIN_VALUE) {
                this.x /= l;
                this.y /= l;
            }
            else {
                this.x = 1.0;
                this.y = 0.0;
            }
            return this;
        };
        Object.defineProperty(Vector2.prototype, "length", {
            get: function () {
                return Math.sqrt(this.sqrtLength);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector2.prototype, "sqrtLength", {
            get: function () {
                return this.x * this.x + this.y * this.y;
            },
            enumerable: true,
            configurable: true
        });
        Vector2.set = function (x, y, out) {
            out.x = x;
            out.y = y;
            return out;
        };
        Vector2.normalize = function (v) {
            var num = this.getLength(v);
            if (num > Number.MIN_VALUE) {
                v.x = v.x / num;
                v.y = v.y / num;
            }
            else {
                v.x = 1.0;
                v.y = 0.0;
            }
            return v;
        };
        Vector2.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            return out;
        };
        Vector2.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            return out;
        };
        Vector2.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            return out;
        };
        Vector2.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        };
        Vector2.scale = function (v, scaler) {
            v.x = v.x * scaler;
            v.y = v.y * scaler;
            return v;
        };
        Vector2.getLength = function (v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        };
        Vector2.getDistance = function (v1, v2) {
            this.subtract(v1, v2, _helpVector2A);
            return this.getLength(_helpVector2A);
        };
        Vector2.copy = function (v, out) {
            out.x = v.x;
            out.y = v.y;
            return out;
        };
        Vector2.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            return true;
        };
        Vector2.lerp = function (v1, v2, value, out) {
            out.x = v1.x * (1 - value) + v2.x * value;
            out.y = v1.y * (1 - value) + v2.y * value;
            return out;
        };
        Vector2.ZERO = new Vector2(0.0, 0.0);
        Vector2.ONE = new Vector2(1.0, 1.0);
        return Vector2;
    }());
    egret3d.Vector2 = Vector2;
    __reflect(Vector2.prototype, "egret3d.Vector2", ["paper.ISerializable"]);
    var _helpVector2A = new Vector2();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * Base Class for Asset
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 资源基类，扩展资源类型需要继承此抽象类
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Asset = (function (_super) {
        __extends(Asset, _super);
        /**
         *
         */
        function Asset(url) {
            if (url === void 0) { url = ""; }
            var _this = _super.call(this) || this;
            /**
             *
             * 资源的原始URL
             */
            _this.url = "";
            /**
             * @internal
             */
            _this._isLoad = false;
            _this.url = url;
            return _this;
        }
        /**
         * 注册资源
         * 通过此方法注册后，引擎内部可以通过URL字典访问所有注册的资源
         * 使用外部加载器时，需要在加载完成后注册该资源
         */
        Asset.register = function (asset, isLoad) {
            if (isLoad === void 0) { isLoad = false; }
            asset._isLoad = isLoad;
            this._assets[asset.url] = asset;
        };
        /**
         * 获取资源
         * @param name 资源的url
         */
        Asset.find = function (name) {
            var result = this._assets[name];
            if (!result) {
                return RES.getRes(name);
            }
            else {
                return result;
            }
        };
        /**
         * @inheritDoc
         */
        Asset.prototype.serialize = function () {
            var target = paper.serializeRC(this);
            target.url = this.url;
            return target;
        };
        Asset._assets = {};
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Asset.prototype, "url", void 0);
        Asset = __decorate([
            paper.serializedType("assets")
        ], Asset);
        return Asset;
    }(paper.SerializableObject));
    paper.Asset = Asset;
    __reflect(Asset.prototype, "paper.Asset");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * renderer component interface
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 渲染器组件接口
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var BaseRenderer = (function (_super) {
        __extends(BaseRenderer, _super);
        function BaseRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._receiveShadows = false;
            _this._castShadows = false;
            _this._lightmapIndex = -1;
            _this._lightmapScaleOffset = new Float32Array([1.0, 1.0, 0.0, 0.0]);
            return _this;
        }
        Object.defineProperty(BaseRenderer.prototype, "receiveShadows", {
            get: function () {
                return this._receiveShadows;
            },
            set: function (value) {
                if (value === this._receiveShadows) {
                    return;
                }
                this._receiveShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "castShadows", {
            get: function () {
                return this._castShadows;
            },
            set: function (value) {
                if (value === this._castShadows) {
                    return;
                }
                this._castShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "lightmapIndex", {
            get: function () {
                return this._lightmapIndex;
            },
            set: function (value) {
                if (value === this._lightmapIndex) {
                    return;
                }
                this._lightmapIndex = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "lightmapScaleOffset", {
            // @paper.editor.property(paper.editor.EditType.VECTOR4) TODO
            get: function () {
                return this._lightmapScaleOffset;
            },
            enumerable: true,
            configurable: true
        });
        BaseRenderer.prototype.setLightmapScaleOffset = function (scaleX, scaleY, offsetX, offsetY) {
            this._lightmapScaleOffset[0] = scaleX;
            this._lightmapScaleOffset[1] = scaleY;
            this._lightmapScaleOffset[2] = offsetX;
            this._lightmapScaleOffset[3] = offsetY;
        };
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_receiveShadows", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_castShadows", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_lightmapIndex", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_lightmapScaleOffset", void 0);
        __decorate([
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], BaseRenderer.prototype, "receiveShadows", null);
        __decorate([
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], BaseRenderer.prototype, "castShadows", null);
        __decorate([
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseRenderer.prototype, "lightmapIndex", null);
        return BaseRenderer;
    }(paper.BaseComponent));
    paper.BaseRenderer = BaseRenderer;
    __reflect(BaseRenderer.prototype, "paper.BaseRenderer");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 系统基类。
     */
    var BaseSystem = (function () {
        /**
         * @internal
         */
        function BaseSystem() {
            this._enabled = true;
            this._started = false;
            this._bufferedCount = 0;
            /**
             * @internal
             */
            this._level = 0;
            /**
             * 系统对于每个实体关心的组件总数。
             */
            this._interestComponentCount = 0;
            /**
             * 关心列表。
             */
            this._interests = [];
            /**
             * 系统根据关心列表收集的组件列表。
             */
            this._components = [];
            /**
             * 系统收集的实体。
             */
            this._gameObjectOffsets = {};
            /**
             * 缓冲的实体组件，将在下个逻辑循环中加入到系统。
             */
            this._waittingComponents = {};
            /**
             *
             */
            this._globalGameObject = paper.Application.sceneManager.globalGameObject;
            if (!BaseSystem._createEnabled) {
                throw new Error("Create an instance of a system is not allowed.");
            }
            BaseSystem._createEnabled = false;
        }
        /**
         * 当关心的组件被添加时。
         */
        BaseSystem.prototype._onAddComponent = function (component) {
            var gameObject = component.gameObject;
            var uuid = gameObject.uuid;
            if (uuid in this._gameObjectOffsets ||
                uuid in this._waittingComponents) {
                return;
            }
            var components = new Array();
            for (var _i = 0, _a = this._interests; _i < _a.length; _i++) {
                var config = _a[_i];
                var insterestComponent = null;
                if (Array.isArray(config.componentClass)) {
                    for (var _b = 0, _c = config.componentClass; _b < _c.length; _b++) {
                        var componentClass = _c[_b];
                        insterestComponent = gameObject.getComponent(componentClass, config.isExtends); // TODO 更快的查找方式
                        if (insterestComponent) {
                            break;
                        }
                    }
                }
                else {
                    insterestComponent = gameObject.getComponent(config.componentClass, config.isExtends); // TODO 更快的查找方式
                }
                if (config.isExclude ? insterestComponent : !insterestComponent) {
                    return;
                }
                components.push(insterestComponent); // ts 不能推断。
            }
            this._bufferedCount++;
            this._waittingComponents[uuid] = components;
        };
        /**
         * 当关心的组件被移除时。
         */
        BaseSystem.prototype._onRemoveComponent = function (component) {
            var gameObject = component.gameObject;
            var uuid = gameObject.uuid;
            if (uuid in this._gameObjectOffsets) {
                var interestCount = this._interestComponentCount;
                var components = this._components;
                var backupLength = components.length;
                var gameObjectOffset = this._gameObjectOffsets[gameObject.uuid];
                if (backupLength > interestCount) {
                    var lastGameObject = null;
                    for (var i = 0; i < interestCount; ++i) {
                        if (!lastGameObject) {
                            lastGameObject = components[backupLength - interestCount].gameObject;
                        }
                        components[gameObjectOffset + i] = components[backupLength - interestCount + i];
                    }
                    if (lastGameObject) {
                        this._gameObjectOffsets[lastGameObject.uuid] = gameObjectOffset;
                    }
                }
                components.length -= interestCount;
                delete this._gameObjectOffsets[gameObject.uuid];
                this.onRemoveGameObject && this.onRemoveGameObject(gameObject);
            }
            else if (uuid in this._waittingComponents) {
                this._bufferedCount++;
                delete this._waittingComponents[uuid];
            }
        };
        /**
         * 判断实体是否在系统内。
         */
        BaseSystem.prototype._hasGameObject = function (gameObject) {
            return gameObject.uuid in this._gameObjectOffsets;
        };
        /**
         * 根据关心列表的顺序快速查找指定组件。
         */
        BaseSystem.prototype._getComponent = function (gameObject, componentOffset) {
            if (gameObject.uuid in this._gameObjectOffsets) {
                return this._components[this._gameObjectOffsets[gameObject.uuid] + componentOffset];
            }
            return null;
        };
        /**
         * @internal
         */
        BaseSystem.prototype._isEditorUpdate = function () {
            return paper.Application.isEditor && !paper.Application.isPlaying;
        };
        /**
         * 系统内部初始化。
         * @internal
         */
        BaseSystem.prototype.initialize = function () {
            this._onAddComponent = this._onAddComponent.bind(this);
            this._onRemoveComponent = this._onRemoveComponent.bind(this);
            for (var _i = 0, _a = this._interests; _i < _a.length; _i++) {
                var config = _a[_i];
                if (config.listeners) {
                    for (var _b = 0, _c = config.listeners; _b < _c.length; _b++) {
                        var listenerConfig = _c[_b];
                        if (Array.isArray(config.componentClass)) {
                            for (var _d = 0, _e = config.componentClass; _d < _e.length; _d++) {
                                var componentClass = _e[_d];
                                paper.EventPool.addEventListener(listenerConfig.type, componentClass, listenerConfig.listener);
                            }
                        }
                        else {
                            paper.EventPool.addEventListener(listenerConfig.type, config.componentClass, listenerConfig.listener);
                        }
                    }
                }
                this._interestComponentCount++;
                if (Array.isArray(config.componentClass)) {
                    for (var _f = 0, _g = config.componentClass; _f < _g.length; _f++) {
                        var componentClass = _g[_f];
                        paper.EventPool.addEventListener("__enabled__" /* Enabled */, componentClass, this._onAddComponent);
                        paper.EventPool.addEventListener("__disabled__" /* Disabled */, componentClass, this._onRemoveComponent);
                    }
                }
                else {
                    paper.EventPool.addEventListener("__enabled__" /* Enabled */, config.componentClass, this._onAddComponent);
                    paper.EventPool.addEventListener("__disabled__" /* Disabled */, config.componentClass, this._onRemoveComponent);
                }
            }
            this.onAwake && this.onAwake();
            this.onEnable && this.onEnable();
        };
        /**
         * 系统内部卸载。
         * @internal
         */
        BaseSystem.prototype.uninitialize = function () {
            this.onDestroy && this.onDestroy();
            for (var _i = 0, _a = this._interests; _i < _a.length; _i++) {
                var config = _a[_i];
                if (config.listeners) {
                    for (var _b = 0, _c = config.listeners; _b < _c.length; _b++) {
                        var listenerConfig = _c[_b];
                        if (Array.isArray(config.componentClass)) {
                            for (var _d = 0, _e = config.componentClass; _d < _e.length; _d++) {
                                var componentClass = _e[_d];
                                paper.EventPool.removeEventListener(listenerConfig.type, componentClass, listenerConfig.listener);
                            }
                        }
                        else {
                            paper.EventPool.removeEventListener(listenerConfig.type, config.componentClass, listenerConfig.listener);
                        }
                    }
                }
                this._interestComponentCount++;
                if (Array.isArray(config.componentClass)) {
                    for (var _f = 0, _g = config.componentClass; _f < _g.length; _f++) {
                        var componentClass = _g[_f];
                        paper.EventPool.removeEventListener("__enabled__" /* Enabled */, componentClass, this._onAddComponent);
                        paper.EventPool.removeEventListener("__disabled__" /* Disabled */, componentClass, this._onRemoveComponent);
                    }
                }
                else {
                    paper.EventPool.removeEventListener("__enabled__" /* Enabled */, config.componentClass, this._onAddComponent);
                    paper.EventPool.removeEventListener("__disabled__" /* Disabled */, config.componentClass, this._onRemoveComponent);
                }
            }
            this._components.length = 0;
            for (var k in this._gameObjectOffsets) {
                delete this._gameObjectOffsets[k];
            }
            for (var k in this._waittingComponents) {
                delete this._waittingComponents[k];
            }
        };
        /**
         * 系统内部更新。
         * @internal
         */
        BaseSystem.prototype.update = function () {
            if (this._bufferedCount > 0) {
                for (var k in this._waittingComponents) {
                    var components = this._waittingComponents[k];
                    var gameObject = components[0].gameObject;
                    this._gameObjectOffsets[k] = this._components.length;
                    delete this._waittingComponents[k];
                    for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
                        var component = components_1[_i];
                        this._components.push(component);
                    }
                    this.onAddGameObject && this.onAddGameObject(gameObject);
                }
                this._bufferedCount = 0;
            }
            if (!this._started) {
                this._started = true;
                this.onStart && this.onStart();
            }
            if (this._enabled) {
                this.onUpdate && this.onUpdate();
            }
        };
        Object.defineProperty(BaseSystem.prototype, "enabled", {
            /**
             * 该系统是否被激活。
             * - 当禁用时，仅停止 onUpdate 生命周期。
             */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._enabled === value) {
                    return;
                }
                this._enabled = value;
                if (this._enabled) {
                    this.onEnable && this.onEnable();
                }
                else {
                    this.onDisable && this.onDisable();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSystem.prototype, "level", {
            /**
             *
             */
            get: function () {
                return this._level;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSystem.prototype, "components", {
            /**
             * 该系统所关心的所有组件。
             */
            get: function () {
                return this._components;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 防止生成未经管理的系统实例。
         * @internal
         */
        BaseSystem._createEnabled = false;
        return BaseSystem;
    }());
    paper.BaseSystem = BaseSystem;
    __reflect(BaseSystem.prototype, "paper.BaseSystem");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpVec3_3 = new egret3d.Vector3();
    var helpMat4_1 = new egret3d.Matrix();
    var Quaternion = (function () {
        function Quaternion(x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Quaternion.prototype.serialize = function () {
            return [this.x, this.y, this.z, this.w];
        };
        Quaternion.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.z = element[2];
            this.w = element[3];
        };
        Quaternion.prototype.copy = function (value) {
            this.x = value.x;
            this.y = value.y;
            this.z = value.z;
            this.w = value.w;
            return this;
        };
        Quaternion.prototype.clone = function () {
            var value = new egret3d.Vector4();
            value.copy(this);
            return value;
        };
        Quaternion.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        Quaternion.prototype.normalize = function () {
            var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            if (l > Number.MIN_VALUE) {
                this.x /= l;
                this.y /= l;
                this.z /= l;
                this.w /= l;
            }
            else {
                this.x = 0.0;
                this.y = 0.0;
                this.z = 0.0;
                this.w = 1.0;
            }
            return this;
        };
        Quaternion.prototype.inverse = function () {
            var ll = this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z;
            if (ll > 0.0) {
                var ill = 1.0 / ll;
                this.x = -this.x * ill;
                this.y = -this.y * ill;
                this.z = -this.z * ill;
                this.w = this.w * ill;
            }
            return this;
        };
        Quaternion.prototype.multiply = function (value) {
            var w1 = this.w, x1 = this.x, y1 = this.y, z1 = this.z;
            var w2 = value.w, x2 = value.x, y2 = value.y, z2 = value.z;
            this.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            this.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            this.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            this.normalize();
            return this;
        };
        Quaternion.prototype.transformVector3 = function (value) {
            var x2 = value.x, y2 = value.y, z2 = value.z;
            var x1 = this.w * x2 + this.y * z2 - this.z * y2;
            var y1 = this.w * y2 - this.x * z2 + this.z * x2;
            var z1 = this.w * z2 + this.x * y2 - this.y * x2;
            var w1 = -this.x * x2 - this.y * y2 - this.z * z2;
            value.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
            value.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
            value.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;
            return value;
        };
        Quaternion.set = function (x, y, z, w, out) {
            out.x = x;
            out.y = y;
            out.z = z;
            out.w = w;
            return out;
        };
        Quaternion.getMagnitude = function (src) {
            return Math.sqrt(src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z);
        };
        Quaternion.fromYawPitchRoll = function (yaw, pitch, roll, out) {
            // Produces a quaternion from Euler angles in the z-y-x orientation (Tait-Bryan angles)
            var halfRoll = roll * 0.5;
            var halfPitch = pitch * 0.5;
            var halfYaw = yaw * 0.5;
            var sinRoll = Math.sin(halfRoll);
            var cosRoll = Math.cos(halfRoll);
            var sinPitch = Math.sin(halfPitch);
            var cosPitch = Math.cos(halfPitch);
            var sinYaw = Math.sin(halfYaw);
            var cosYaw = Math.cos(halfYaw);
            out.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            out.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            out.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            out.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
            return out;
        };
        Quaternion.fromEulerAngles = function (ax, ay, az, out) {
            ax *= Math.PI / 180;
            ay *= Math.PI / 180;
            az *= Math.PI / 180;
            var halfX = ax * 0.5, halfY = ay * 0.5, halfZ = az * 0.5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            out.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            out.x = sinX * cosY * cosZ + cosX * sinY * sinZ;
            out.y = cosX * sinY * cosZ - sinX * cosY * sinZ;
            out.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            return this.normalize(out);
        };
        Quaternion.fromAxisAngle = function (axis, angle, out) {
            angle *= Math.PI / 180.0;
            var halfAngle = angle * 0.5;
            var sin_a = Math.sin(halfAngle);
            out.w = Math.cos(halfAngle);
            out.x = axis.x * sin_a;
            out.y = axis.y * sin_a;
            out.z = axis.z * sin_a;
            this.normalize(out);
            return out;
        };
        Quaternion.fromMatrix = function (matrix, out) {
            var m00, m01, m02, m10, m11, m12, m20, m21, m22, tr, s, rs, lx, ly, lz;
            var m = matrix.rawData;
            // Cache matrix values for super-speed
            m00 = m[0];
            m01 = m[1];
            m02 = m[2];
            m10 = m[4];
            m11 = m[5];
            m12 = m[6];
            m20 = m[8];
            m21 = m[9];
            m22 = m[10];
            // Remove the scale from the matrix
            lx = 1 / Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
            ly = 1 / Math.sqrt(m10 * m10 + m11 * m11 + m12 * m12);
            lz = 1 / Math.sqrt(m20 * m20 + m21 * m21 + m22 * m22);
            m00 *= lx;
            m01 *= lx;
            m02 *= lx;
            m10 *= ly;
            m11 *= ly;
            m12 *= ly;
            m20 *= lz;
            m21 *= lz;
            m22 *= lz;
            // http://www.cs.ucr.edu/~vbz/resources/quatut.pdf
            tr = m00 + m11 + m22;
            if (tr >= 0) {
                s = Math.sqrt(tr + 1);
                out.w = s * 0.5;
                s = 0.5 / s;
                out.x = (m12 - m21) * s;
                out.y = (m20 - m02) * s;
                out.z = (m01 - m10) * s;
            }
            else {
                if (m00 > m11) {
                    if (m00 > m22) {
                        // XDiagDomMatrix
                        rs = (m00 - (m11 + m22)) + 1;
                        rs = Math.sqrt(rs);
                        out.x = rs * 0.5;
                        rs = 0.5 / rs;
                        out.w = (m12 - m21) * rs;
                        out.y = (m01 + m10) * rs;
                        out.z = (m02 + m20) * rs;
                    }
                    else {
                        // ZDiagDomMatrix
                        rs = (m22 - (m00 + m11)) + 1;
                        rs = Math.sqrt(rs);
                        out.z = rs * 0.5;
                        rs = 0.5 / rs;
                        out.w = (m01 - m10) * rs;
                        out.x = (m20 + m02) * rs;
                        out.y = (m21 + m12) * rs;
                    }
                }
                else if (m11 > m22) {
                    // YDiagDomMatrix
                    rs = (m11 - (m22 + m00)) + 1;
                    rs = Math.sqrt(rs);
                    out.y = rs * 0.5;
                    rs = 0.5 / rs;
                    out.w = (m20 - m02) * rs;
                    out.z = (m12 + m21) * rs;
                    out.x = (m10 + m01) * rs;
                }
                else {
                    // ZDiagDomMatrix
                    rs = (m22 - (m00 + m11)) + 1;
                    rs = Math.sqrt(rs);
                    out.z = rs * 0.5;
                    rs = 0.5 / rs;
                    out.w = (m01 - m10) * rs;
                    out.x = (m20 + m02) * rs;
                    out.y = (m21 + m12) * rs;
                }
            }
            return out;
        };
        Quaternion.lookAt = function (pos, target, out) {
            var dir = helpVec3_1;
            egret3d.Vector3.subtract(target, pos, dir);
            egret3d.Vector3.normalize(dir);
            var dirxz = helpVec3_2;
            helpVec3_2.x = dir.x;
            helpVec3_2.y = 0;
            helpVec3_2.z = dir.z;
            egret3d.Vector3.normalize(dirxz);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            var dirxz1 = helpVec3_3;
            helpVec3_3.x = dir.x;
            helpVec3_3.y = 0;
            helpVec3_3.z = dir.z;
            var v3length = egret3d.Vector3.getLength(dirxz1);
            if (v3length > 0.9999999999) {
                v3length = 1;
            }
            if (v3length < -0.999999999) {
                v3length = -1;
            }
            var pitch = Math.acos(v3length);
            if (dir.y > 0) {
                pitch = -pitch;
            }
            this.fromYawPitchRoll(yaw, pitch, 0, out);
            return this.normalize(out);
        };
        Quaternion.lookAtWithUp = function (pos, target, up, out) {
            var eye = pos;
            var zaxis = egret3d.Vector3.subtract(target, eye, helpVec3_1); // right-hand coordinates system
            egret3d.Vector3.normalize(zaxis);
            var xaxis = egret3d.Vector3.cross(up, zaxis, helpVec3_2);
            egret3d.Vector3.normalize(xaxis);
            var yaxis = egret3d.Vector3.cross(zaxis, xaxis, helpVec3_3);
            return Quaternion.fromMatrix(egret3d.Matrix.set(xaxis.x, yaxis.x, zaxis.x, 0, xaxis.y, yaxis.y, zaxis.y, 0, xaxis.z, yaxis.z, zaxis.z, 0, 0, 0, 0, 1, helpMat4_1), out);
        };
        Quaternion.multiply = function (q1, q2, out) {
            var w1 = q1.w, x1 = q1.x, y1 = q1.y, z1 = q1.z;
            var w2 = q2.w, x2 = q2.x, y2 = q2.y, z2 = q2.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            this.normalize(out);
            return out;
        };
        Quaternion.normalize = function (out) {
            var mag = 1 / Math.sqrt(out.x * out.x + out.y * out.y + out.z * out.z + out.w * out.w);
            out.x *= mag;
            out.y *= mag;
            out.z *= mag;
            out.w *= mag;
            return out;
        };
        Quaternion.copy = function (q, out) {
            out.x = q.x;
            out.y = q.y;
            out.z = q.z;
            out.w = q.w;
            return out;
        };
        Quaternion.inverse = function (q, out) {
            var norm = q.w * q.w + q.x * q.x + q.y * q.y + q.z * q.z;
            if (norm > 0.0) {
                var invNorm = 1.0 / norm;
                out.w = q.w * invNorm;
                out.x = -q.x * invNorm;
                out.y = -q.y * invNorm;
                out.z = -q.z * invNorm;
            }
            return out;
        };
        Quaternion.toEulerAngles = function (q, out) {
            var temp = 2.0 * (q.w * q.x - q.y * q.z);
            temp = egret3d.floatClamp(temp, -1.0, 1.0);
            out.x = Math.asin(temp);
            out.y = Math.atan2(2.0 * (q.w * q.y + q.z * q.x), 1.0 - 2.0 * (q.y * q.y + q.x * q.x));
            out.z = Math.atan2(2.0 * (q.w * q.z + q.y * q.x), 1.0 - 2.0 * (q.x * q.x + q.z * q.z));
            out.x /= Math.PI / 180;
            out.y /= Math.PI / 180;
            out.z /= Math.PI / 180;
            return out;
        };
        Quaternion.toMatrix = function (q, out) {
            var xy2 = 2.0 * q.x * q.y, xz2 = 2.0 * q.x * q.z, xw2 = 2.0 * q.x * q.w;
            var yz2 = 2.0 * q.y * q.z, yw2 = 2.0 * q.y * q.w, zw2 = 2.0 * q.z * q.w;
            var xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z, ww = q.w * q.w;
            out.rawData[0] = xx - yy - zz + ww;
            out.rawData[4] = xy2 - zw2;
            out.rawData[8] = xz2 + yw2;
            out.rawData[12] = 0;
            out.rawData[1] = xy2 + zw2;
            out.rawData[5] = -xx + yy - zz + ww;
            out.rawData[9] = yz2 - xw2;
            out.rawData[13] = 0;
            out.rawData[2] = xz2 - yw2;
            out.rawData[6] = yz2 + xw2;
            out.rawData[10] = -xx - yy + zz + ww;
            out.rawData[14] = 0;
            out.rawData[3] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[11] = 0;
            out.rawData[15] = 1;
            return out;
        };
        Quaternion.toAxisAngle = function (q, axis) {
            var sqrLength = q.x * q.x + q.y * q.y + q.z * q.z;
            var angle = 0;
            if (sqrLength > 0.0) {
                angle = 2.0 * Math.acos(q.w);
                sqrLength = 1.0 / Math.sqrt(sqrLength);
                axis.x = q.x * sqrLength;
                axis.y = q.y * sqrLength;
                axis.z = q.z * sqrLength;
            }
            else {
                angle = 0;
                axis.x = 1.0;
                axis.y = 0;
                axis.z = 0;
            }
            angle /= Math.PI / 180.0;
            return angle;
        };
        Quaternion.transformVector3 = function (src, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            w1 = -src.x * x2 - src.y * y2 - src.z * z2;
            x1 = src.w * x2 + src.y * z2 - src.z * y2;
            y1 = src.w * y2 - src.x * z2 + src.z * x2;
            z1 = src.w * z2 + src.x * y2 - src.y * x2;
            out.x = -w1 * src.x + x1 * src.w - y1 * src.z + z1 * src.y;
            out.y = -w1 * src.y + x1 * src.z + y1 * src.w - z1 * src.x;
            out.z = -w1 * src.z - x1 * src.y + y1 * src.x + z1 * src.w;
            return out;
        };
        Quaternion.transformVector3ByQuaternionData = function (src, srcseek, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            var srcx = src[srcseek];
            var srcy = src[srcseek + 1];
            var srcz = src[srcseek + 2];
            var srcw = src[srcseek + 3];
            w1 = -srcx * x2 - srcy * y2 - srcz * z2;
            x1 = srcw * x2 + srcy * z2 - srcz * y2;
            y1 = srcw * y2 - srcx * z2 + srcz * x2;
            z1 = srcw * z2 + srcx * y2 - srcy * x2;
            out.x = -w1 * srcx + x1 * srcw - y1 * srcz + z1 * srcy;
            out.y = -w1 * srcy + x1 * srcz + y1 * srcw - z1 * srcx;
            out.z = -w1 * srcz - x1 * srcy + y1 * srcx + z1 * srcw;
            return out;
        };
        Quaternion.multiplyByQuaternionData = function (srca, srcaseek, srcb, out) {
            var w1 = srca[srcaseek + 3], x1 = srca[srcaseek + 0], y1 = srca[srcaseek + 1], z1 = srca[srcaseek + 2];
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            this.normalize(out);
            return out;
        };
        Quaternion.lerp = function (srca, srcb, out, t) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            out.w = w1 + t * (w2 - w1);
            out.x = x1 + t * (x2 - x1);
            out.y = y1 + t * (y2 - y1);
            out.z = z1 + t * (z2 - z1);
            var len = 1.0 / Math.sqrt(out.w * out.w + out.x * out.x + out.y * out.y + out.z * out.z);
            out.w *= len;
            out.x *= len;
            out.y *= len;
            out.z *= len;
            return out;
        };
        return Quaternion;
    }());
    egret3d.Quaternion = Quaternion;
    __reflect(Quaternion.prototype, "egret3d.Quaternion", ["paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 引擎启动入口
     */
    function runEgret(options) {
        if (options === void 0) { options = { antialias: false }; }
        // (Ammo as any)().then(() => { // TODO WebAssembly load
        var requiredOptions = getOptions(options);
        var canvas = getMainCanvas();
        egret3d.WebGLKit.init(canvas, requiredOptions);
        egret3d.InputManager.init(canvas);
        egret3d.DefaultMeshes.init();
        egret3d.DefaultTextures.init();
        egret3d.DefaultShaders.init();
        egret3d.stage.init(canvas, requiredOptions);
        paper.Application.init(options);
        //
        paper.Application.sceneManager.createScene("default");
        // });
    }
    egret3d.runEgret = runEgret;
    function getMainCanvas() {
        if (window.canvas) {
            return window.canvas;
        }
        else {
            var div = document.getElementsByClassName("egret-player")[0];
            var canvas = document.createElement("canvas");
            div.appendChild(canvas);
            return canvas;
        }
    }
    function getOptions(options) {
        if (window.canvas) {
            return {
                antialias: options.antialias,
                antialiasSamples: 4,
                contentWidth: options.contentWidth || 640,
                contentHeight: options.contentHeight || 1136
            };
        }
        else {
            var div = document.getElementsByClassName("egret-player")[0];
            return {
                antialias: options.antialias,
                antialiasSamples: 4,
                contentWidth: parseInt(div.getAttribute("data-content-width")),
                contentHeight: parseInt(div.getAttribute("data-content-height"))
            };
            ;
        }
    }
})(egret3d || (egret3d = {}));
window.paper = paper;
window.egret3d = egret3d;
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Pool = (function () {
        function Pool() {
            this._instances = [];
        }
        Pool.prototype.clear = function () {
            this._instances.length = 0;
        };
        Pool.prototype.add = function (instanceOrInstances) {
            if (Array.isArray(instanceOrInstances)) {
                for (var _i = 0, instanceOrInstances_1 = instanceOrInstances; _i < instanceOrInstances_1.length; _i++) {
                    var instance = instanceOrInstances_1[_i];
                    if (this._instances.indexOf(instance) < 0) {
                        this._instances.push(instance);
                    }
                }
            }
            else {
                if (this._instances.indexOf(instanceOrInstances) < 0) {
                    this._instances.push(instanceOrInstances);
                }
            }
        };
        Pool.prototype.remove = function (instanceOrInstances) {
            if (Array.isArray(instanceOrInstances)) {
                for (var _i = 0, instanceOrInstances_2 = instanceOrInstances; _i < instanceOrInstances_2.length; _i++) {
                    var instance = instanceOrInstances_2[_i];
                    var index = this._instances.indexOf(instance);
                    if (index >= 0) {
                        this._instances.splice(index, 1);
                    }
                }
            }
            else {
                var index = this._instances.indexOf(instanceOrInstances);
                if (index >= 0) {
                    this._instances.splice(index, 1);
                }
            }
        };
        Pool.prototype.get = function () {
            return this._instances.pop() || null;
        };
        Object.defineProperty(Pool.prototype, "instances", {
            get: function () {
                return this._instances;
            },
            enumerable: true,
            configurable: true
        });
        return Pool;
    }());
    egret3d.Pool = Pool;
    __reflect(Pool.prototype, "egret3d.Pool");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * SystemManager 是ecs内部的系统管理者，负责每帧循环时轮询每个系统。
     */
    var SystemManager = (function () {
        function SystemManager() {
            this._registerSystems = [];
            this._systems = [];
            this._unregisterSystems = [];
        }
        SystemManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SystemManager();
            }
            return this._instance;
        };
        SystemManager.prototype._preRegister = function (systemClass) {
            // TODO 移除可能正在注销但并未反初始化的系统。
            if (this.getSystem(systemClass)) {
                console.warn("The system has been registered.", egret.getQualifiedClassName(systemClass));
                return true;
            }
            return false;
        };
        /**
         * 注册一个系统到管理器中
         * @param systemClass 要注册的系统
         * @param level 系统的优先级，越小越早执行。
         */
        SystemManager.prototype.register = function (systemClass, level) {
            if (level === void 0) { level = 0; }
            if (this._preRegister(systemClass)) {
                return;
            }
            var isAdded = false;
            paper.BaseSystem._createEnabled = true;
            var system = new systemClass();
            system._level = level;
            for (var i = 0, l = this._systems.length; i < l; ++i) {
                var eachSystem = this._systems[i];
                if (eachSystem && eachSystem._level > system._level) {
                    isAdded = true;
                    this._systems.splice(i, 0, system);
                    break;
                }
            }
            if (!isAdded) {
                this._systems.push(system);
            }
            this._registerSystems.push(system);
        };
        /**
         * 注册一个系统到管理器中
         * @param systemClass 要注册的系统
         * @param target 加入到目标系统的前面。
         */
        SystemManager.prototype.registerBefore = function (systemClass, target) {
            if (this._preRegister(systemClass)) {
                return;
            }
            var isAdded = false;
            paper.BaseSystem._createEnabled = true;
            var system = new systemClass();
            for (var i = 0, l = this._systems.length; i < l; ++i) {
                var eachSystem = this._systems[i];
                if (eachSystem && eachSystem.constructor === target) {
                    isAdded = true;
                    system._level = eachSystem.level;
                    this._systems.splice(i, 0, system);
                    break;
                }
            }
            if (!isAdded) {
                if (this._systems.length > 0) {
                    var lastSystem = this._systems[this._systems.length - 1];
                    if (lastSystem) {
                        system._level = lastSystem.level;
                    }
                }
                this._systems.push(system);
            }
            this._registerSystems.push(system);
        };
        /**
         * 注册一个系统到管理器中
         * @param systemClass 要注册的系统
         * @param target 加入到目标系统的后面。
         */
        SystemManager.prototype.registerAfter = function (systemClass, target) {
            if (this._preRegister(systemClass)) {
                return;
            }
            var isAdded = false;
            paper.BaseSystem._createEnabled = true;
            var system = new systemClass();
            for (var i = 0, l = this._systems.length; i < l; ++i) {
                var eachSystem = this._systems[i];
                if (eachSystem && eachSystem.constructor === target) {
                    isAdded = true;
                    system._level = eachSystem.level;
                    this._systems.splice(i + 1, 0, system);
                    break;
                }
            }
            if (!isAdded) {
                if (this._systems.length > 0) {
                    var lastSystem = this._systems[this._systems.length - 1];
                    if (lastSystem) {
                        system._level = lastSystem.level;
                    }
                }
                this._systems.push(system);
            }
            this._registerSystems.push(system);
        };
        /**
         * 注销一个管理器中的系统
         * @param systemClass 要注销的系统
         */
        SystemManager.prototype.unregister = function (systemClass) {
            // TODO 移除可能正在注册但并未初始化的系统。
            var index = 0;
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.constructor === systemClass) {
                    this._unregisterSystems.push(system);
                    this._systems[index] = null;
                    return;
                }
                index++;
            }
            console.warn("The system has not been registered.", egret.getQualifiedClassName(systemClass));
        };
        /**
         *
         */
        SystemManager.prototype.enableSystem = function (systemClass) {
            var system = this.getSystem(systemClass);
            if (system) {
                system.enabled = true;
            }
            else {
                console.warn("Enable system error.", egret.getQualifiedClassName(systemClass));
            }
        };
        /**
         *
         */
        SystemManager.prototype.disableSystem = function (systemClass) {
            var system = this.getSystem(systemClass);
            if (system) {
                system.enabled = false;
            }
            else {
                console.warn("Disable system error.", egret.getQualifiedClassName(systemClass));
            }
        };
        /**
         * 获取一个管理器中指定的系统实例。
         */
        SystemManager.prototype.getSystem = function (systemClass) {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.constructor === systemClass) {
                    return system;
                }
            }
            return null;
        };
        /**
         * @internal
         */
        SystemManager.prototype.update = function () {
            var index = 0;
            var removeCount = 0;
            if (this._registerSystems.length > 0) {
                for (var _i = 0, _a = this._registerSystems; _i < _a.length; _i++) {
                    var system = _a[_i];
                    if (system) {
                        system.initialize();
                    }
                }
                this._registerSystems.length = 0;
            }
            for (var _b = 0, _c = this._systems; _b < _c.length; _b++) {
                var system = _c[_b];
                if (system) {
                    var systemName = system.constructor.name;
                    egret3d.Profile.startTime(systemName);
                    if (removeCount > 0) {
                        this._systems[index - removeCount] = system;
                        this._systems[index] = null;
                    }
                    system.update();
                    egret3d.Profile.endTime(systemName);
                }
                else {
                    removeCount++;
                }
                index++;
            }
            if (removeCount > 0) {
                this._systems.length -= removeCount;
                if (this._unregisterSystems.length > 0) {
                    for (var _d = 0, _e = this._unregisterSystems; _d < _e.length; _d++) {
                        var system = _e[_d];
                        if (system) {
                            system.uninitialize();
                        }
                    }
                    this._unregisterSystems.length = 0;
                }
            }
        };
        SystemManager._instance = null;
        return SystemManager;
    }());
    paper.SystemManager = SystemManager;
    __reflect(SystemManager.prototype, "paper.SystemManager");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 矩形可序列化对象
     */
    var Rectangle = (function () {
        /**
         *
         */
        function Rectangle(x, y, w, h) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (w === void 0) { w = 0.0; }
            if (h === void 0) { h = 0.0; }
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        Rectangle.prototype.serialize = function () {
            return [this.x, this.y, this.w, this.h];
        };
        Rectangle.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.w = element[2];
            this.h = element[3];
        };
        return Rectangle;
    }());
    egret3d.Rectangle = Rectangle;
    __reflect(Rectangle.prototype, "egret3d.Rectangle", ["egret3d.IRectangle", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Color = (function () {
        function Color(r, g, b, a) {
            if (r === void 0) { r = 1.0; }
            if (g === void 0) { g = 1.0; }
            if (b === void 0) { b = 1.0; }
            if (a === void 0) { a = 1.0; }
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        Color.prototype.serialize = function () {
            return [this.r, this.g, this.b, this.a];
        };
        Color.prototype.deserialize = function (element) {
            this.r = element[0];
            this.g = element[1];
            this.b = element[2];
            this.a = element[3];
        };
        Color.prototype.set = function (r, g, b, a) {
            if (r === void 0) { r = 1; }
            if (g === void 0) { g = 1; }
            if (b === void 0) { b = 1; }
            if (a === void 0) { a = 1; }
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            return this;
        };
        Color.multiply = function (c1, c2, out) {
            out.r = c1.r * c2.r;
            out.g = c1.g * c2.g;
            out.b = c1.b * c2.b;
            out.a = c1.a * c2.a;
            return out;
        };
        Color.scale = function (c, scaler) {
            c.r = c.r * scaler;
            c.g = c.g * scaler;
            c.b = c.b * scaler;
            c.a = c.a * scaler;
            return c;
        };
        Color.copy = function (c, out) {
            out.r = c.r;
            out.g = c.g;
            out.b = c.b;
            out.a = c.a;
            return out;
        };
        Color.lerp = function (c1, c2, value, out) {
            out.a = value * (c2.a - c1.a) + c1.a;
            out.r = value * (c2.r - c1.r) + c1.r;
            out.g = value * (c2.g - c1.g) + c1.g;
            out.b = value * (c2.b - c1.b) + c1.b;
            return out;
        };
        return Color;
    }());
    egret3d.Color = Color;
    __reflect(Color.prototype, "egret3d.Color", ["paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 脚本组件。
     * 生命周期的顺序。
     * - onAwake();
     * - onReset();
     * - onEnable();
     * - onStart();
     * - onFixedUpdate();
     * - onUpdate();
     * - onLateUpdate();
     * - onDisable();
     * - onDestroy();
     */
    var Behaviour = (function (_super) {
        __extends(Behaviour, _super);
        function Behaviour() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._isReseted = false;
            /**
             * @internal
             */
            _this._isStarted = false;
            /**
             * @internal
             */
            _this._isTriggerEnabled = false;
            /**
             * @internal
             */
            _this._isCollisionEnabled = false;
            return _this;
        }
        Behaviour.prototype.initialize = function (config) {
            _super.prototype.initialize.call(this, config);
            this._isTriggerEnabled = Boolean(this.onTriggerEnter || this.onTriggerStay || this.onTriggerExit);
            this._isCollisionEnabled = Boolean(this.onCollisionEnter || this.onCollisionStay || this.onCollisionExit);
            if (!paper.Application.isEditor || paper._executeInEditModeComponents.indexOf(this.constructor) >= 0) {
                this.onAwake && this.onAwake(config);
            }
        };
        Behaviour.prototype.uninitialize = function () {
            if (!paper.Application.isEditor || paper._executeInEditModeComponents.indexOf(this.constructor) >= 0) {
                this.onDestroy && this.onDestroy(); // TODO onDestroy 如果不是 enabled 就不派发
            }
            _super.prototype.uninitialize.call(this);
        };
        /**
         * @deprecated
         */
        Behaviour.prototype.onCollide = function (collider) { };
        __decorate([
            paper.serializedField
        ], Behaviour.prototype, "_isReseted", void 0);
        return Behaviour;
    }(paper.BaseComponent));
    paper.Behaviour = Behaviour;
    __reflect(Behaviour.prototype, "paper.Behaviour");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var EventDispatcher = (function () {
        function EventDispatcher() {
            this._eventMap = {};
        }
        EventDispatcher.prototype.addEventListener = function (type, listener, thisObject) {
            var list = this._eventMap[type];
            if (!list) {
                list = this._eventMap[type] = [];
            }
            list.push({ listener: listener, thisObject: thisObject || this });
        };
        EventDispatcher.prototype.removeEventListener = function (type, listener, thisObject) {
            var list = this._eventMap[type];
            if (!list) {
                return;
            }
            for (var i = 0, len = list.length; i < len; i++) {
                var bin = list[i];
                if (bin.listener == listener && bin.thisObject == (thisObject || this)) {
                    list.splice(i, 1);
                    break;
                }
            }
        };
        EventDispatcher.prototype.dispatchEvent = function (event) {
            event.target = this;
            this.notifyListener(event);
        };
        EventDispatcher.prototype.notifyListener = function (event) {
            var list = this._eventMap[event.type || event];
            if (!list) {
                return;
            }
            for (var i = 0, len = list.length; i < len; i++) {
                var bin = list[i];
                bin.listener.call(bin.thisObject, event);
            }
        };
        return EventDispatcher;
    }());
    egret3d.EventDispatcher = EventDispatcher;
    __reflect(EventDispatcher.prototype, "egret3d.EventDispatcher");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var BaseObjectAsset = (function (_super) {
        __extends(BaseObjectAsset, _super);
        function BaseObjectAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._assets = {};
            _this._raw = null;
            return _this;
        }
        BaseObjectAsset.prototype.$parse = function (json, subAssets) {
            this._raw = json;
            for (var _i = 0, subAssets_1 = subAssets; _i < subAssets_1.length; _i++) {
                var item = subAssets_1[_i];
                this._assets[item.hashCode || item.uuid] = item; // 兼容 hashCode 。
            }
        };
        /**
         * @inheritDoc
         */
        BaseObjectAsset.prototype.dispose = function () {
            for (var k in this._assets) {
                delete this._assets[k];
            }
            this._raw = null;
        };
        /**
         * @inheritDoc
         */
        BaseObjectAsset.prototype.caclByteLength = function () {
            return 0;
        };
        return BaseObjectAsset;
    }(paper.Asset));
    egret3d.BaseObjectAsset = BaseObjectAsset;
    __reflect(BaseObjectAsset.prototype, "egret3d.BaseObjectAsset");
    /**
     * 预制体资源。
     */
    var Prefab = (function (_super) {
        __extends(Prefab, _super);
        function Prefab() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * 从当前预制体生成一个实例。
         */
        Prefab.prototype.createInstance = function () {
            if (!this._raw) {
                return null;
            }
            var gameObject = paper.deserialize(this._raw, this._assets, true);
            return gameObject;
        };
        return Prefab;
    }(BaseObjectAsset));
    egret3d.Prefab = Prefab;
    __reflect(Prefab.prototype, "egret3d.Prefab");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 场景管理器
     */
    var SceneManager = (function () {
        function SceneManager() {
            this._scenes = [];
            this._globalScene = null;
            this._globalGameObject = null;
        }
        SceneManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SceneManager();
            }
            return this._instance;
        };
        /**
         * @internal
         */
        SceneManager.prototype._addScene = function (scene, isActive) {
            if (this._scenes.indexOf(scene) < 0) {
                if (isActive) {
                    this._scenes.unshift(scene);
                }
                else {
                    this._scenes.push(scene);
                }
            }
            else {
                console.debug("Add the scene again.", scene.name);
            }
        };
        /**
         * 创建一个空场景并激活
         */
        SceneManager.prototype.createScene = function (name, isActive) {
            if (isActive === void 0) { isActive = true; }
            var scene = new paper.Scene(isActive);
            scene.name = name;
            return scene;
        };
        /**
         * 加载场景
         * @param resourceName 资源名称
         */
        SceneManager.prototype.loadScene = function (resourceName) {
            var rawScene = RES.getRes(resourceName);
            if (rawScene) {
                var scene = rawScene.createInstance();
                if (scene) {
                    scene.rawScene = rawScene;
                    if (paper.Application.isPlaying) {
                        egret3d.autoCombine(scene);
                    }
                    return scene;
                }
            }
            return null;
        };
        /**
         * 卸载指定场景。
         */
        SceneManager.prototype.unloadScene = function (scene) {
            if (scene === this._globalScene) {
                console.warn("Cannot unload global scene.");
                return;
            }
            var index = this._scenes.indexOf(scene);
            if (index >= 0) {
                scene._destroy();
                this._scenes.splice(index, 1);
            }
        };
        /**
         * 卸载所有场景。
         */
        SceneManager.prototype.unloadAllScene = function () {
            for (var _i = 0, _a = this._scenes; _i < _a.length; _i++) {
                var scene = _a[_i];
                scene._destroy();
            }
            this._scenes.length = 0;
        };
        /**
         *
         */
        SceneManager.prototype.getSceneByName = function (name) {
            for (var _i = 0, _a = this._scenes; _i < _a.length; _i++) {
                var scene = _a[_i];
                if (scene.name === name) {
                    return scene;
                }
            }
            return null;
        };
        Object.defineProperty(SceneManager.prototype, "scenes", {
            /**
             *
             */
            get: function () {
                return this._scenes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "globalScene", {
            /**
             *
             */
            get: function () {
                if (!this._globalScene) {
                    this._globalScene = this.createScene("global", false);
                    this._scenes.pop(); // Remove global scene from scenes.
                }
                return this._globalScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "globalGameObject", {
            /**
             *
             */
            get: function () {
                if (!this._globalGameObject) {
                    this._globalGameObject = new paper.GameObject("global", "global");
                    this._globalGameObject.dontDestroy = true;
                }
                return this._globalGameObject;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "activeScene", {
            /**
             * 获取当前激活的场景
             */
            get: function () {
                if (this._scenes.length === 0) {
                    this.createScene("default");
                }
                return this._scenes[0];
            },
            set: function (value) {
                if (this._scenes.length <= 1 ||
                    this._scenes[0] === value ||
                    this._globalScene === value // Cannot active global scene.
                ) {
                    return;
                }
                var index = this._scenes.indexOf(value);
                if (index >= 0) {
                    this._scenes.splice(index, 1);
                    this._scenes.unshift(value);
                }
                else {
                    console.debug("Active scene error.", value.name, value.uuid);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        SceneManager.prototype.getActiveScene = function () {
            return this.activeScene;
        };
        SceneManager._instance = null;
        return SceneManager;
    }());
    paper.SceneManager = SceneManager;
    __reflect(SceneManager.prototype, "paper.SceneManager");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * Camera系统
     */
    var CameraSystem = (function (_super) {
        __extends(CameraSystem, _super);
        function CameraSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: egret3d.Camera, isExtends: true }
            ];
            _this._drawCalls = _this._globalGameObject.getComponent(egret3d.DrawCalls) || _this._globalGameObject.addComponent(egret3d.DrawCalls);
            return _this;
        }
        CameraSystem.prototype._applyDrawCall = function (context, drawCall) {
            var renderer = drawCall.renderer;
            var lightmapIndex = renderer.lightmapIndex;
            context.drawCall = drawCall;
            context.updateModel(drawCall.matrix || renderer.gameObject.transform.getWorldMatrix());
            var drawType = "base"; // TODO
            if (drawCall.boneData) {
                context.updateBones(drawCall.boneData);
                drawType = "skin";
            }
            if (lightmapIndex >= 0) {
                var activeScene = paper.Application.sceneManager.activeScene;
                if (activeScene.lightmaps.length > lightmapIndex) {
                    context.updateLightmap(activeScene.lightmaps[lightmapIndex], drawCall.mesh.glTFMesh.primitives[drawCall.subMeshIndex].attributes.TEXCOORD_1 ? 1 : 0, renderer.lightmapScaleOffset, activeScene.lightmapIntensity);
                    drawType = "lightmap";
                }
            }
            egret3d.WebGLKit.draw(context, drawType);
        };
        CameraSystem.prototype._onAddComponent = function (component) {
            if (component.gameObject === this._globalGameObject) {
                return;
            }
            _super.prototype._onAddComponent.call(this, component);
        };
        CameraSystem.prototype.$renderCamera = function (camera) {
            //在这里先剔除，然后排序，最后绘制           
            this._drawCalls.sortAfterFrustumCulling(camera);
            // this._drawCalls.sort();
            for (var _i = 0, _a = this._drawCalls.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                if (drawCall.disable) {
                    continue;
                }
                var gameObject = drawCall.renderer.gameObject;
                if (camera.cullingMask & gameObject.layer) {
                    this._applyDrawCall(camera.context, drawCall);
                }
            }
            // Egret2D渲染不加入DrawCallList的排序
            var egret2DRenderSystem = paper.Application.systemManager.getSystem(egret3d.Egret2DRendererSystem);
            if (egret2DRenderSystem && egret2DRenderSystem.enabled) {
                for (var _b = 0, _c = egret2DRenderSystem.components; _b < _c.length; _b++) {
                    var egret2DRenderer = _c[_b];
                    if (camera.cullingMask & egret2DRenderer.gameObject.layer) {
                        egret2DRenderer.render(camera.context, camera);
                    }
                }
            }
        };
        CameraSystem.prototype.onUpdate = function () {
            this._components.sort(function (a, b) {
                return a.order - b.order;
            });
            var lightSystem = paper.Application.systemManager.getSystem(egret3d.LightSystem);
            var lights = lightSystem ? lightSystem.components : null;
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                component.update(paper.Time.deltaTime);
                if (lights && lights.length > 0) {
                    component.context.updateLights(lights); // TODO 性能优化
                }
            }
            egret3d.Performance.startCounter("render");
            if (this._components.length > 0) {
                for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                    var component = _c[_b];
                    if (component.postQueues.length === 0) {
                        component.context.drawtype = "";
                        component._targetAndViewport(component.renderTarget, false);
                        this.$renderCamera(component);
                    }
                    else {
                        for (var _d = 0, _e = component.postQueues; _d < _e.length; _d++) {
                            var item = _e[_d];
                            item.render(component, this);
                        }
                    }
                }
            }
            else {
                egret3d.WebGLKit.webgl.clearColor(0, 0, 0, 1);
                egret3d.WebGLKit.webgl.clearDepth(1.0);
                egret3d.WebGLKit.webgl.clear(egret3d.WebGLKit.webgl.COLOR_BUFFER_BIT | egret3d.WebGLKit.webgl.DEPTH_BUFFER_BIT);
            }
            egret3d.Performance.endCounter("render");
            egret3d.Performance.updateFPS();
        };
        return CameraSystem;
    }(paper.BaseSystem));
    egret3d.CameraSystem = CameraSystem;
    __reflect(CameraSystem.prototype, "egret3d.CameraSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * light component
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 灯光组件
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var BaseLight = (function (_super) {
        __extends(BaseLight, _super);
        function BaseLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.castShadows = false;
            /**
             *
             */
            _this.intensity = 2;
            /**
             *
             */
            _this.distance = 50;
            /**
             *
             */
            _this.decay = 2;
            /**
             *
             */
            _this.angle = Math.PI / 6;
            /**
             *
             */
            _this.penumbra = 0;
            /**
             * spot angel cos
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 聚光灯的开合角度cos值
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.spotAngelCos = 0.9;
            /**
             *
             */
            _this.shadowBias = 0.0003;
            /**
             *
             */
            _this.shadowRadius = 2;
            /**
             *
             */
            _this.shadowSize = 16;
            /**
             *
             */
            _this.shadowCameraNear = 0.1;
            /**
             *
             */
            _this.shadowCameraFar = 200;
            /**
             *
             */
            _this.color = new egret3d.Color(1.0, 1.0, 1.0, 1.0);
            _this.matrix = new egret3d.Matrix();
            return _this;
        }
        BaseLight.prototype._updateMatrix = function (camera) {
            // matrix * 0.5 + 0.5, after identity, range is 0 ~ 1 instead of -1 ~ 1
            var matrix = this.matrix;
            matrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
            camera.calcProjectMatrix(512 / 512, egret3d.helpMatrixA);
            egret3d.helpMatrixB.copy(this.gameObject.transform.getWorldMatrix()).inverse();
            egret3d.Matrix.multiply(matrix, egret3d.helpMatrixA, matrix);
            egret3d.Matrix.multiply(matrix, egret3d.helpMatrixB, matrix);
        };
        BaseLight.prototype.update = function (camera, faceIndex) {
            camera.opvalue = 1.0;
            camera.backgroundColor.set(1.0, 1.0, 1.0, 1.0);
            camera.clearOption_Color = true;
            camera.clearOption_Depth = true;
            this._updateMatrix(camera);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], BaseLight.prototype, "castShadows", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "intensity", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "distance", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "decay", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "angle", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "penumbra", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "spotAngelCos", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowBias", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowRadius", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowSize", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowCameraNear", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowCameraFar", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.COLOR)
        ], BaseLight.prototype, "color", void 0);
        return BaseLight;
    }(paper.BaseComponent));
    egret3d.BaseLight = BaseLight;
    __reflect(BaseLight.prototype, "egret3d.BaseLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * MeshFilter 组件
     */
    var MeshFilter = (function (_super) {
        __extends(MeshFilter, _super);
        function MeshFilter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._mesh = null;
            return _this;
        }
        /**
         * @inheritDoc
         */
        MeshFilter.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                this._mesh.dispose();
            }
            this._mesh = null;
        };
        Object.defineProperty(MeshFilter.prototype, "mesh", {
            /**
             * 组件挂载的 mesh 模型
             */
            get: function () {
                return this._mesh;
            },
            set: function (mesh) {
                if (this._mesh === mesh) {
                    return;
                }
                if (this._mesh) {
                    this._mesh.dispose();
                }
                this._mesh = mesh;
                paper.EventPool.dispatchEvent("mesh" /* Mesh */, this);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], MeshFilter.prototype, "_mesh", void 0);
        __decorate([
            paper.editor.property(paper.editor.EditType.MESH)
        ], MeshFilter.prototype, "mesh", null);
        MeshFilter = __decorate([
            paper.disallowMultipleComponent
        ], MeshFilter);
        return MeshFilter;
    }(paper.BaseComponent));
    egret3d.MeshFilter = MeshFilter;
    __reflect(MeshFilter.prototype, "egret3d.MeshFilter");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        particle.BillboardPerVertexCount = 37;
        particle.MeshPerVertexCount = 42;
        /**
         * 渲染类型为Mesh的属性格式
         */
        particle.MeshShaderAttributeFormat = [
            { key: "POSITION" /* POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "COLOR_0" /* COLOR_0 */, type: "VEC4" /* VEC4 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "START_POSITION" /* START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "START_VELOCITY" /* START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "START_COLOR" /* START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "START_SIZE" /* START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "START_ROTATION" /* START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "TIME" /* TIME */, type: "VEC2" /* VEC2 */ },
            { key: "RANDOM0" /* RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "RANDOM1" /* RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "WORLD_POSITION" /* WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "WORLD_ROTATION" /* WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        /**
         * 渲染类型为Billboard的属性格式
         */
        particle.BillboardShaderAttributeFormat = [
            { key: "CORNER" /* CORNER */, type: "VEC2" /* VEC2 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "START_POSITION" /* START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "START_VELOCITY" /* START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "START_COLOR" /* START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "START_SIZE" /* START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "START_ROTATION" /* START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "TIME" /* TIME */, type: "VEC2" /* VEC2 */ },
            { key: "RANDOM0" /* RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "RANDOM1" /* RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "WORLD_POSITION" /* WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "WORLD_ROTATION" /* WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        var ParticleRenderer = (function (_super) {
            __extends(ParticleRenderer, _super);
            function ParticleRenderer() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._materials = [];
                _this._renderMode = 0 /* Billboard */;
                return _this;
            }
            ParticleRenderer.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                if (element._mesh) {
                    this._mesh = new egret3d.Mesh(); //
                    this._mesh.deserialize(element._mesh);
                }
                this.velocityScale = element.velocityScale;
                this._renderMode = element._renderMode;
                this.lengthScale = element.lengthScale;
                if (element._materials) {
                    this._materials.length = 0;
                    for (var i = 0, l = element._materials.length; i < l; i++) {
                        this._materials.push(paper.getDeserializedObject(element._materials[i]));
                    }
                }
            };
            ParticleRenderer.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                this._mesh = null;
                this._materials.length = 0;
                this._renderMode = 0 /* Billboard */;
                this.velocityScale = 1.0;
                this.lengthScale = 1.0;
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._addShaderDefine = function (key) {
                if (!this.batchMaterial && this._materials.length > 0) {
                    this.batchMaterial = this._materials[0];
                }
                if (this.batchMaterial) {
                    this.batchMaterial.addDefine(key);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._removeShaderDefine = function (key) {
                if (!this.batchMaterial && this._materials.length > 0) {
                    this.batchMaterial = this._materials[0];
                }
                if (this.batchMaterial) {
                    this.batchMaterial.removeDefine(key);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setBoolean = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setBoolean(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setInt = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setInt(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setFloat = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setFloat(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setVector2 = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setVector2(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setVector2v = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setVector2v(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setVector3 = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setVector3(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setVector4 = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setVector4(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setVector3v = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setVector3v(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setVector4v = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setVector4v(_id, _value);
                }
            };
            Object.defineProperty(ParticleRenderer.prototype, "mesh", {
                /**
                 * mesh model
                 * @version paper 1.0
                 * @platform Web
                 * @language en_US
                 */
                /**
                 * 组件挂载的 mesh 模型
                 * @version paper 1.0
                 * @platform Web
                 * @language
                 */
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh === mesh) {
                        return;
                    }
                    this._mesh = mesh;
                    paper.EventPool.dispatchEvent("mesh" /* Mesh */, this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleRenderer.prototype, "materials", {
                /**
                 * material list
                 * @version paper 1.0
                 * @platform Web
                 * @language en_US
                 */
                /**
                 * 材质数组
                 * @version paper 1.0
                 * @platform Web
                 * @language
                 */
                get: function () {
                    return this._materials;
                },
                set: function (value) {
                    if (value === this._materials) {
                        return;
                    }
                    this._materials.length = 0;
                    for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                        var material = value_1[_i];
                        this._materials.push(material);
                    }
                    paper.EventPool.dispatchEvent("materials" /* Materials */, this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleRenderer.prototype, "renderMode", {
                get: function () {
                    return this._renderMode;
                },
                set: function (value) {
                    if (this._renderMode === value) {
                        return;
                    }
                    var old = this._renderMode;
                    this._renderMode = value;
                    paper.EventPool.dispatchEvent("renderMode" /* RenderMode */, this);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_mesh", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_materials", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "velocityScale", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_renderMode", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "lengthScale", void 0);
            __decorate([
                paper.editor.property(paper.editor.EditType.MESH)
            ], ParticleRenderer.prototype, "mesh", null);
            __decorate([
                paper.editor.property(paper.editor.EditType.ARRAY)
            ], ParticleRenderer.prototype, "materials", null);
            ParticleRenderer = __decorate([
                paper.disallowMultipleComponent
            ], ParticleRenderer);
            return ParticleRenderer;
        }(paper.BaseRenderer));
        particle.ParticleRenderer = ParticleRenderer;
        __reflect(ParticleRenderer.prototype, "egret3d.particle.ParticleRenderer");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * get max precision
     * @param gl
     * @param precision {string} the expect precision, can be: "highp"|"mediump"|"lowp"
     */
    function getMaxPrecision(gl, precision) {
        if (precision === void 0) { precision = "highp"; }
        if (precision === 'highp') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                return 'highp';
            }
            precision = 'mediump';
        }
        if (precision === 'mediump') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                return 'mediump';
            }
        }
        return 'lowp';
    }
    function getExtension(gl, name) {
        var browserPrefixes = [
            "",
            "MOZ_",
            "OP_",
            "WEBKIT_"
        ];
        for (var ii = 0; ii < browserPrefixes.length; ++ii) {
            var prefixedName = browserPrefixes[ii] + name;
            var ext = gl.getExtension(prefixedName);
            if (ext) {
                return ext;
            }
        }
        return null;
    }
    var WebGLCapabilities = (function () {
        function WebGLCapabilities() {
            this.precision = "highp";
        }
        WebGLCapabilities.prototype.initialize = function (gl) {
            this.version = parseFloat(/^WebGL\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]);
            this.maxPrecision = getMaxPrecision(gl, this.precision);
            this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            this.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            this.floatTextures = !!getExtension(gl, 'OES_texture_float');
            this.anisotropyExt = getExtension(gl, 'EXT_texture_filter_anisotropic');
            this.shaderTextureLOD = getExtension(gl, 'EXT_shader_texture_lod');
            this.maxAnisotropy = (this.anisotropyExt !== null) ? gl.getParameter(this.anisotropyExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            // use dfdx and dfdy must enable OES_standard_derivatives
            getExtension(gl, "OES_standard_derivatives");
            // GL_OES_standard_derivatives
            getExtension(gl, "GL_OES_standard_derivatives");
        };
        return WebGLCapabilities;
    }());
    egret3d.WebGLCapabilities = WebGLCapabilities;
    __reflect(WebGLCapabilities.prototype, "egret3d.WebGLCapabilities");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 渲染排序
     */
    var RenderQueue;
    (function (RenderQueue) {
        RenderQueue[RenderQueue["Background"] = 1000] = "Background";
        RenderQueue[RenderQueue["Geometry"] = 2000] = "Geometry";
        RenderQueue[RenderQueue["AlphaTest"] = 2450] = "AlphaTest";
        RenderQueue[RenderQueue["Transparent"] = 3000] = "Transparent";
        RenderQueue[RenderQueue["Overlay"] = 4000] = "Overlay";
    })(RenderQueue = egret3d.RenderQueue || (egret3d.RenderQueue = {}));
    /**
     * 材质资源
     */
    var Material = (function (_super) {
        __extends(Material, _super);
        function Material() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             */
            _this.version = 0;
            _this.$uniforms = {};
            _this._defines = new Array();
            _this._textureRef = [];
            _this._renderQueue = -1;
            return _this;
        }
        /**
         * 释放资源。
         */
        Material.prototype.dispose = function () {
            delete this.$uniforms;
            delete this._defines;
            this.version++;
        };
        /**
         * 计算资源字节大小。
         */
        Material.prototype.caclByteLength = function () {
            var total = 0;
            if (this.shader) {
                total += this.shader.caclByteLength();
            }
            for (var k in this.$uniforms) {
                var type = this.$uniforms[k].type;
                var value = this.$uniforms[k].value;
                switch (type) {
                    case egret3d.UniformTypeEnum.Float:
                        total += 4;
                        break;
                    case egret3d.UniformTypeEnum.Floatv:
                        total += value.byteLength;
                        break;
                    case egret3d.UniformTypeEnum.Float4:
                        total += 16;
                        break;
                    case egret3d.UniformTypeEnum.Float4v:
                        total += value.byteLength;
                        break;
                    case egret3d.UniformTypeEnum.Float4x4:
                        total += 64;
                        break;
                    case egret3d.UniformTypeEnum.Float4x4v:
                        total += value.byteLength;
                        break;
                    case egret3d.UniformTypeEnum.Texture:
                        if (value) {
                            total += value.caclByteLength();
                        }
                        break;
                }
            }
            return total;
        };
        Material.prototype._setDefaultUniforms = function (shader) {
            if (!this.shader) {
                console.log("Shader error.", this);
                return;
            }
            for (var key in shader.defaultValue) {
                var uniform = shader.defaultValue[key];
                switch (uniform.type) {
                    case "Texture":
                        this.setTexture(key, uniform.value);
                        break;
                    case "Vector4":
                        if (Array.isArray(uniform.value)) {
                            this.setVector4v(key, uniform.value);
                        }
                        else {
                            this.setVector4(key, uniform.value);
                        }
                        break;
                    case "Range":
                        this.setFloat(key, uniform.value);
                        break;
                }
            }
        };
        /**
         * 设置着色器，不保留原有数据。
         */
        Material.prototype.setShader = function (shader) {
            this.shader = shader;
            this.$uniforms = {};
            this._setDefaultUniforms(this.shader);
        };
        /**
         * 获取当前着色器。
         */
        Material.prototype.getShader = function () {
            return this.shader;
        };
        /**
         * 更改着色器，保留原有数据。
         */
        Material.prototype.changeShader = function (shader) {
            var map = {};
            for (var key in this.$uniforms) {
                if (this.$uniforms[key]) {
                    map[key] = this.$uniforms[key];
                }
            }
            this.setShader(shader);
            for (var key in map) {
                if (this.$uniforms[key]) {
                    this.$uniforms[key] = map[key];
                }
            }
        };
        Object.defineProperty(Material.prototype, "renderQueue", {
            get: function () {
                if (!this.shader) {
                    console.log("Shader error.", this);
                    return this._renderQueue;
                }
                return this._renderQueue === -1 ? this.shader.renderQueue : this._renderQueue;
            },
            set: function (value) {
                this._renderQueue = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "shaderDefine", {
            get: function () {
                var res = "";
                for (var _i = 0, _a = this._defines; _i < _a.length; _i++) {
                    var key = _a[_i];
                    res += "#define " + key + " \n";
                }
                return res;
            },
            enumerable: true,
            configurable: true
        });
        Material.prototype.addDefine = function (key) {
            if (this._defines.indexOf(key) < 0) {
                this._defines.push(key);
            }
            this.version++;
        };
        Material.prototype.removeDefine = function (key) {
            var delIndex = this._defines.indexOf(key);
            if (delIndex >= 0) {
                this._defines.splice(delIndex, 1);
            }
            this.version++;
        };
        Material.prototype.setBoolean = function (_id, _bool) {
            if (this.$uniforms[_id] !== undefined) {
                this.$uniforms[_id].value = _bool;
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Boolean, value: _bool };
            }
            this.version++;
        };
        Material.prototype.setInt = function (_id, _number) {
            if (this.$uniforms[_id] !== undefined) {
                this.$uniforms[_id].value = _number;
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Int, value: _number };
            }
            this.version++;
        };
        Material.prototype.setFloat = function (_id, _number) {
            if (this.$uniforms[_id] !== undefined) {
                this.$uniforms[_id].value = _number;
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Float, value: _number };
            }
            this.version++;
        };
        Material.prototype.setFloatv = function (_id, _numbers) {
            if (this.$uniforms[_id] !== undefined) {
                this.$uniforms[_id].value = _numbers;
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Floatv, value: _numbers };
            }
            this.version++;
        };
        Material.prototype.setVector2 = function (_id, _vector2) {
            if (this.$uniforms[_id] !== undefined) {
                this.$uniforms[_id].value = _vector2;
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Float2, value: _vector2 };
            }
            this.version++;
        };
        Material.prototype.setVector2v = function (_id, _vector2v) {
            if (this.$uniforms[_id] !== undefined) {
                this.$uniforms[_id].value = _vector2v;
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Float2v, value: _vector2v };
            }
            this.version++;
        };
        Material.prototype.setVector3 = function (_id, _vector3) {
            if (this.$uniforms[_id] !== undefined) {
                this.$uniforms[_id].value = _vector3;
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Float3, value: _vector3 };
            }
            this.version++;
        };
        Material.prototype.setVector3v = function (_id, _vector3v) {
            if (this.$uniforms[_id] !== undefined) {
                this.$uniforms[_id].value = _vector3v;
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Float3v, value: _vector3v };
            }
            this.version++;
        };
        Material.prototype.setVector4 = function (_id, _vector4) {
            if (this.$uniforms[_id] !== undefined) {
                this.$uniforms[_id].value = _vector4;
                if (this.$uniforms[_id].type !== egret3d.UniformTypeEnum.Float4) {
                    console.error("设置setVector4类型错误，类型不匹配");
                }
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Float4, value: _vector4 };
            }
            this.version++;
        };
        Material.prototype.setVector4v = function (_id, _vector4v) {
            if (this.$uniforms[_id] !== undefined) {
                this.$uniforms[_id].value = _vector4v;
                if (this.$uniforms[_id].type !== egret3d.UniformTypeEnum.Float4v) {
                    console.error("设置setVector4v类型错误，类型不匹配");
                }
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Float4v, value: _vector4v };
            }
            this.version++;
        };
        Material.prototype.setMatrix = function (_id, _matrix) {
            if (this.$uniforms[_id] !== undefined) {
                this.$uniforms[_id].value = _matrix;
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Float4x4, value: _matrix };
            }
            this.version++;
        };
        Material.prototype.setMatrixv = function (_id, _matrixv) {
            if (this.$uniforms[_id] !== undefined) {
                this.$uniforms[_id].value = _matrixv;
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Float4x4v, value: _matrixv };
            }
            this.version++;
        };
        Material.prototype.setTexture = function (_id, _texture) {
            if (this.$uniforms[_id] !== undefined) {
                if (this.$uniforms[_id].value) {
                    var index = this._textureRef.indexOf(this.$uniforms[_id].value);
                    if (index > -1) {
                        this._textureRef.splice(index, 1);
                    }
                }
                this.$uniforms[_id].value = _texture;
            }
            else {
                this.$uniforms[_id] = { type: egret3d.UniformTypeEnum.Texture, value: _texture };
            }
            this.version++;
            if (_texture) {
                this._textureRef.push(_texture);
            }
        };
        /**
         * 克隆材质资源。
         */
        Material.prototype.clone = function () {
            var mat = new Material();
            mat.setShader(this.shader);
            for (var i in this.$uniforms) {
                var data = this.$uniforms[i];
                var _uniformType = data.type;
                switch (_uniformType) {
                    case egret3d.UniformTypeEnum.Texture:
                        mat.setTexture(i, data.value);
                        break;
                    case egret3d.UniformTypeEnum.Float:
                        mat.setFloat(i, data.value);
                        break;
                    case egret3d.UniformTypeEnum.Float4:
                        if (Array.isArray(data.value)) {
                            mat.setVector4v(i, data.value);
                        }
                        else {
                            mat.setVector4(i, data.value);
                        }
                        break;
                    case egret3d.UniformTypeEnum.Float4v:
                        mat.setVector4v(i, data.value);
                        break;
                    default:
                        break;
                }
            }
            return mat;
        };
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.SHADER, { set: "setShader" })
        ], Material.prototype, "shader", void 0);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Material.prototype, "_textureRef", void 0);
        return Material;
    }(paper.Asset));
    egret3d.Material = Material;
    __reflect(Material.prototype, "egret3d.Material");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Vector4 = (function () {
        function Vector4(x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 0.0; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Vector4.prototype.serialize = function () {
            return [this.x, this.y, this.z, this.w];
        };
        Vector4.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.z = element[2];
            this.w = element[3];
        };
        Vector4.prototype.copy = function (value) {
            this.x = value.x;
            this.y = value.y;
            this.z = value.z;
            this.w = value.w;
            return this;
        };
        Vector4.prototype.clone = function () {
            var value = new Vector4();
            value.copy(this);
            return value;
        };
        Vector4.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        Vector4.prototype.normalize = function () {
            var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            if (l > Number.MIN_VALUE) {
                this.x /= l;
                this.y /= l;
                this.z /= l;
                this.w /= l;
            }
            else {
                this.x = 0.0;
                this.y = 0.0;
                this.z = 0.0;
                this.w = 1.0;
            }
            return this;
        };
        Vector4.set = function (x, y, z, w, out) {
            out.x = x;
            out.y = y;
            out.z = z;
            out.w = w;
            return out;
        };
        Vector4.copy = function (v, out) {
            out.x = v.x;
            out.y = v.y;
            out.z = v.z;
            out.w = v.w;
            return out;
        };
        return Vector4;
    }());
    egret3d.Vector4 = Vector4;
    __reflect(Vector4.prototype, "egret3d.Vector4", ["paper.ISerializable"]);
    egret3d.helpVector4A = new Vector4();
    egret3d.helpVector4B = new Vector4();
    egret3d.helpVector4C = new Vector4();
    egret3d.helpVector4D = new Vector4();
    egret3d.helpVector4E = new Vector4();
    egret3d.helpVector4F = new Vector4();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 单例组件基类。
     */
    var SingletonComponent = (function (_super) {
        __extends(SingletonComponent, _super);
        function SingletonComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SingletonComponent.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            if (this.constructor.prototype["instance"]) {
                console.error("Cannot add singleton component again.", egret.getQualifiedClassName(this), this.uuid);
            }
            else {
                this.constructor.prototype["instance"] = this;
            }
        };
        SingletonComponent.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this.constructor.prototype["instance"] === this) {
                delete this.constructor.prototype["instance"];
            }
        };
        return SingletonComponent;
    }(paper.BaseComponent));
    paper.SingletonComponent = SingletonComponent;
    __reflect(SingletonComponent.prototype, "paper.SingletonComponent");
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 事件派发器
         */
        var EventDispatcher = (function () {
            function EventDispatcher() {
                this.__z_e_listeners = {};
            }
            EventDispatcher.prototype.addEventListener = function (type, fun, thisObj, level) {
                if (level === void 0) { level = 0; }
                var list = this.__z_e_listeners[type];
                if (list === undefined) {
                    list = [];
                    this.__z_e_listeners[type] = list;
                }
                var item = {
                    func: fun,
                    context: thisObj,
                    level: level
                };
                list.push(item);
                list.sort(function (a, b) {
                    return b.level - a.level;
                });
            };
            EventDispatcher.prototype.removeEventListener = function (type, fun, thisObj) {
                var list = this.__z_e_listeners[type];
                if (list !== undefined) {
                    var size = list.length;
                    for (var i = 0; i < size; i++) {
                        var obj = list[i];
                        if (obj.func === fun && obj.context === thisObj) {
                            list.splice(i, 1);
                            return;
                        }
                    }
                }
            };
            EventDispatcher.prototype.dispatchEvent = function (event) {
                var list = this.__z_e_listeners[event.type];
                if (list !== undefined) {
                    list.forEach(function (ef) {
                        ef['___dirty___'] = true;
                    });
                    var size = list.length;
                    for (var i = 0; i < size; i++) {
                        var ef = list[i];
                        if (ef['___dirty___']) {
                            var fun = ef.func;
                            var context = ef.context;
                            if (context) {
                                fun.call(context, event);
                            }
                            else {
                                fun(event);
                            }
                            ef['___dirty___'] = false;
                        }
                        if (size != list.length) {
                            size = list.length;
                            i = 0;
                        }
                    }
                }
            };
            return EventDispatcher;
        }());
        editor.EventDispatcher = EventDispatcher;
        __reflect(EventDispatcher.prototype, "paper.editor.EventDispatcher", ["paper.editor.IEventDispatcher"]);
        /**
         * 事件
         */
        var BaseEvent = (function () {
            function BaseEvent(type, data) {
                this.type = type;
                this.data = data;
            }
            return BaseEvent;
        }());
        editor.BaseEvent = BaseEvent;
        __reflect(BaseEvent.prototype, "paper.editor.BaseEvent");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var CollisionShape = (function (_super) {
            __extends(CollisionShape, _super);
            function CollisionShape() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._margin = 0.05;
                _this._btCollisionShape = null;
                return _this;
            }
            CollisionShape.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                if (this._btCollisionShape) {
                    Ammo.destroy(this._btCollisionShape);
                }
                this._btCollisionShape = null;
            };
            Object.defineProperty(CollisionShape.prototype, "margin", {
                /**
                 *
                 */
                get: function () {
                    return this._margin;
                },
                set: function (value) {
                    if (this._margin === value) {
                        return;
                    }
                    this._margin = value;
                    if (this._btCollisionShape) {
                        this._btCollisionShape.setMargin(this._margin);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CollisionShape.prototype, "btCollisionShape", {
                get: function () {
                    if (!this._btCollisionShape) {
                        this._btCollisionShape = this._createCollisionShape();
                    }
                    return this._btCollisionShape;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], CollisionShape.prototype, "_margin", void 0);
            return CollisionShape;
        }(paper.BaseComponent));
        ammo.CollisionShape = CollisionShape;
        __reflect(CollisionShape.prototype, "egret3d.ammo.CollisionShape");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var TypedConstraint = (function (_super) {
            __extends(TypedConstraint, _super);
            function TypedConstraint() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._collisionEnabled = false;
                _this._autoCalculateConnectedAnchor = true;
                _this._constraintType = 1 /* ConstrainToAnotherBody */;
                _this._overrideNumSolverIterations = 20;
                _this._breakingImpulseThreshold = Infinity;
                _this._anchor = egret3d.Vector3.ZERO.clone();
                _this._axisX = egret3d.Vector3.FORWARD.clone();
                _this._axisY = egret3d.Vector3.UP.clone();
                _this._connectedAnchor = egret3d.Vector3.ZERO.clone();
                _this._connectedAxisX = egret3d.Vector3.FORWARD.clone();
                _this._connectedAxisY = egret3d.Vector3.UP.clone();
                _this._connectedBody = null;
                _this._rigidbody = null;
                _this._btTypedConstraint = null;
                return _this;
            }
            TypedConstraint.prototype._createFrame = function (forward, up, constraintPoint, frame) {
                var vR = egret3d.Vector3.cross(forward, up, TypedConstraint._helpVector3A);
                var vU = egret3d.Vector3.cross(vR, forward, TypedConstraint._helpVector3B).normalize();
                vR.normalize();
                vU.normalize();
                frame.identity();
                frame.set3x3(forward.x, vU.x, vR.x, forward.y, vU.y, vR.y, forward.z, vU.z, vR.z);
                frame.setTranslation(constraintPoint);
            };
            TypedConstraint.prototype._createFrames = function (frameA, frameB) {
                if (!this._connectedBody) {
                    console.debug("Never.");
                    return;
                }
                this._createFrame(this._axisX, this._axisY, this._anchor, frameA);
                if (this._autoCalculateConnectedAnchor) {
                    var thisTransform = this.gameObject.transform;
                    var otherTransform = this._connectedBody.gameObject.transform;
                    var quaternion = egret3d.Quaternion.multiply(thisTransform.getLocalRotation(), egret3d.Quaternion.inverse(otherTransform.getLocalRotation(), TypedConstraint._helpQuaternionA), TypedConstraint._helpQuaternionB);
                    var matrixValues = frameA.rawData;
                    var xx = quaternion.transformVector3(TypedConstraint._helpVector3A.set(matrixValues[0], matrixValues[1], matrixValues[2]));
                    var yy = quaternion.transformVector3(TypedConstraint._helpVector3B.set(matrixValues[4], matrixValues[5], matrixValues[6]));
                    var zz = quaternion.transformVector3(TypedConstraint._helpVector3C.set(matrixValues[8], matrixValues[9], matrixValues[10]));
                    frameB.identity();
                    frameB.set3x3(xx.x, yy.x, zz.x, xx.y, yy.y, zz.y, xx.z, yy.z, zz.z);
                    frameB.setTranslation(TypedConstraint._helpMatrixC.copy(otherTransform.getWorldMatrix()).inverse().transformVector3(thisTransform.getWorldMatrix().transformVector3(TypedConstraint._helpVector3D.copy(this._anchor))));
                }
                else {
                    this._createFrame(this._connectedAxisX, this._connectedAxisY, this._connectedAnchor, frameB);
                }
            };
            TypedConstraint.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                if (this._btTypedConstraint) {
                    Ammo.destroy(this._btTypedConstraint);
                }
                this._btTypedConstraint = null;
            };
            Object.defineProperty(TypedConstraint.prototype, "collisionEnabled", {
                /**
                 *
                 */
                get: function () {
                    return this._collisionEnabled;
                },
                set: function (value) {
                    if (this._collisionEnabled === value) {
                        return;
                    }
                    if (this._btTypedConstraint) {
                        console.warn("Cannot change the disableCollisionsBetweenConstrainedBodies after the constraint has been created.");
                    }
                    else {
                        this._collisionEnabled = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "constraintType", {
                /**
                 *
                 */
                get: function () {
                    return this._constraintType;
                },
                set: function (value) {
                    if (this._constraintType === value) {
                        return;
                    }
                    if (this._btTypedConstraint) {
                        console.warn("Cannot change the constraint type after the constraint has been created.");
                    }
                    else {
                        this._constraintType = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "overrideNumSolverIterations", {
                /**
                 *
                 */
                get: function () {
                    return this._overrideNumSolverIterations;
                },
                set: function (value) {
                    if (this._overrideNumSolverIterations === value) {
                        return;
                    }
                    this._overrideNumSolverIterations = value;
                    if (this._btTypedConstraint) {
                        this._btTypedConstraint.setOverrideNumSolverIterations(this._overrideNumSolverIterations);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "breakingImpulseThreshold", {
                /**
                 *
                 */
                get: function () {
                    return this._breakingImpulseThreshold;
                },
                set: function (value) {
                    if (this._breakingImpulseThreshold === value) {
                        return;
                    }
                    this._breakingImpulseThreshold = value;
                    if (this._btTypedConstraint) {
                        this._btTypedConstraint.setBreakingImpulseThreshold(this._breakingImpulseThreshold);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "anchor", {
                /**
                 *
                 */
                get: function () {
                    return this._anchor;
                },
                set: function (value) {
                    if (this._btTypedConstraint) {
                        console.warn("Cannot change the anchor after the constraint has been created.");
                    }
                    else {
                        this._anchor.copy(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "axisX", {
                /**
                 *
                 */
                get: function () {
                    return this._axisX;
                },
                set: function (value) {
                    if (this._btTypedConstraint) {
                        console.warn("Cannot change the axis x after the constraint has been created.");
                    }
                    else {
                        this._axisX.copy(value).normalize();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "axisY", {
                /**
                 *
                 */
                get: function () {
                    return this._axisY;
                },
                set: function (value) {
                    if (this._btTypedConstraint) {
                        console.warn("Cannot change the axis y after the constraint has been created.");
                    }
                    else {
                        this._axisY.copy(value).normalize();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "autoCalculateConnectedAnchor", {
                /**
                 *
                 */
                get: function () {
                    return this._autoCalculateConnectedAnchor;
                },
                set: function (value) {
                    if (this._btTypedConstraint) {
                        console.warn("Cannot change the axis y after the constraint has been created.");
                    }
                    else {
                        this._autoCalculateConnectedAnchor = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "connectedAnchor", {
                /**
                 *
                 */
                get: function () {
                    return this._connectedAnchor;
                },
                set: function (value) {
                    if (this._btTypedConstraint) {
                        console.warn("Cannot change the anchor after the constraint has been created.");
                    }
                    else {
                        this._connectedAnchor.copy(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "connectedAxisX", {
                /**
                 *
                 */
                get: function () {
                    return this._connectedAxisX;
                },
                set: function (value) {
                    if (this._btTypedConstraint) {
                        console.warn("Cannot change the axis x after the constraint has been created.");
                    }
                    else {
                        this._connectedAxisX.copy(value).normalize();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "connectedAxisY", {
                /**
                 *
                 */
                get: function () {
                    return this._connectedAxisY;
                },
                set: function (value) {
                    if (this._btTypedConstraint) {
                        console.warn("Cannot change the axis y after the constraint has been created.");
                    }
                    else {
                        this._connectedAxisY.copy(value).normalize();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "rigidbody", {
                /**
                 *
                 */
                get: function () {
                    return this._rigidbody;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "connectedBody", {
                /**
                 *
                 */
                get: function () {
                    return this._connectedBody;
                },
                set: function (value) {
                    if (this._connectedBody === value) {
                        return;
                    }
                    if (this._btTypedConstraint) {
                        console.warn("Cannot change the axis y after the constraint has been created.");
                    }
                    else {
                        this._connectedBody = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TypedConstraint.prototype, "btTypedConstraint", {
                get: function () {
                    if (!this._btTypedConstraint) {
                        this._btTypedConstraint = this._createConstraint();
                    }
                    return this._btTypedConstraint;
                },
                enumerable: true,
                configurable: true
            });
            TypedConstraint._helpVector3A = new egret3d.Vector3();
            TypedConstraint._helpVector3B = new egret3d.Vector3();
            TypedConstraint._helpVector3C = new egret3d.Vector3();
            TypedConstraint._helpVector3D = new egret3d.Vector3();
            TypedConstraint._helpQuaternionA = new egret3d.Quaternion();
            TypedConstraint._helpQuaternionB = new egret3d.Quaternion();
            TypedConstraint._helpMatrixA = new egret3d.Matrix();
            TypedConstraint._helpMatrixB = new egret3d.Matrix();
            TypedConstraint._helpMatrixC = new egret3d.Matrix();
            __decorate([
                paper.serializedField
            ], TypedConstraint.prototype, "_collisionEnabled", void 0);
            __decorate([
                paper.serializedField
            ], TypedConstraint.prototype, "_autoCalculateConnectedAnchor", void 0);
            __decorate([
                paper.serializedField
            ], TypedConstraint.prototype, "_constraintType", void 0);
            __decorate([
                paper.serializedField
            ], TypedConstraint.prototype, "_overrideNumSolverIterations", void 0);
            __decorate([
                paper.serializedField
            ], TypedConstraint.prototype, "_breakingImpulseThreshold", void 0);
            __decorate([
                paper.serializedField
            ], TypedConstraint.prototype, "_anchor", void 0);
            __decorate([
                paper.serializedField
            ], TypedConstraint.prototype, "_axisX", void 0);
            __decorate([
                paper.serializedField
            ], TypedConstraint.prototype, "_axisY", void 0);
            __decorate([
                paper.serializedField
            ], TypedConstraint.prototype, "_connectedAnchor", void 0);
            __decorate([
                paper.serializedField
            ], TypedConstraint.prototype, "_connectedAxisX", void 0);
            __decorate([
                paper.serializedField
            ], TypedConstraint.prototype, "_connectedAxisY", void 0);
            __decorate([
                paper.serializedField
            ], TypedConstraint.prototype, "_connectedBody", void 0);
            return TypedConstraint;
        }(paper.BaseComponent));
        ammo.TypedConstraint = TypedConstraint;
        __reflect(TypedConstraint.prototype, "egret3d.ammo.TypedConstraint");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var CollisionObject = (function (_super) {
            __extends(CollisionObject, _super);
            function CollisionObject() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.collisionObjectType = 1 /* CollisionObject */;
                _this._collisionFlags = 0 /* None */;
                _this._collisionGroups = 1 /* DefaultFilter */;
                _this._collisionMask = -1 /* AllFilter */;
                _this._btPointer = new Ammo.btVector3();
                _this._btCollisionObject = null;
                return _this;
            }
            CollisionObject.prototype._createCollisionObject = function () {
                var btCollisionObject = new Ammo.btCollisionObject();
                btCollisionObject.setWorldTransform(this._getBTTransform());
                btCollisionObject.setCollisionFlags(this._collisionFlags);
                btCollisionObject.setUserPointer(this._btPointer);
                this._btPointer.egretComponent = this;
                return btCollisionObject;
            };
            CollisionObject.prototype._getBTTransform = function () {
                var transform = this.gameObject.transform;
                var position = transform.getPosition();
                var rotation = transform.getRotation();
                var helpVectorA = ammo.PhysicsSystem.helpVector3A;
                var helpQuaternionA = ammo.PhysicsSystem.helpQuaternionA;
                var helpTransformA = ammo.PhysicsSystem.helpTransformA;
                helpVectorA.setValue(position.x, position.y, position.z);
                helpQuaternionA.setValue(rotation.x, rotation.y, rotation.z, rotation.w);
                helpTransformA.setIdentity();
                helpTransformA.setOrigin(helpVectorA);
                helpTransformA.setRotation(helpQuaternionA);
                return helpTransformA;
            };
            CollisionObject.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                if (this._btCollisionObject) {
                    Ammo.destroy(this._btCollisionObject);
                    Ammo.destroy(this._btPointer);
                }
                this._btCollisionObject = null;
            };
            /**
             *
             */
            CollisionObject.prototype.isStatic = function () {
                return (this._collisionFlags & 1 /* StaticObject */) !== 0 /* None */;
            };
            /**
             *
             */
            CollisionObject.prototype.isKinematic = function () {
                return (this._collisionFlags & 2 /* KinematicObject */) !== 0 /* None */;
            };
            /**
             *
             */
            CollisionObject.prototype.isStaticOrKinematic = function () {
                return (this._collisionFlags & (1 /* StaticObject */ | 2 /* KinematicObject */)) !== 0 /* None */;
            };
            /**
             *
             */
            CollisionObject.prototype.isDynamic = function () {
                return (this._collisionFlags & (1 /* StaticObject */ | 2 /* KinematicObject */)) === 0 /* None */;
            };
            Object.defineProperty(CollisionObject.prototype, "collisionFlags", {
                /**
                 *
                 */
                get: function () {
                    return this._collisionFlags;
                },
                set: function (value) {
                    if (this._collisionFlags === value) {
                        return;
                    }
                    this._collisionFlags = value;
                    if (this._btCollisionObject) {
                        this._btCollisionObject.setCollisionFlags(this._collisionFlags);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CollisionObject.prototype, "collisionGroups", {
                /**
                 *
                 */
                get: function () {
                    return this._collisionGroups;
                },
                set: function (value) {
                    if (this._collisionGroups === value) {
                        return;
                    }
                    if (this._btCollisionObject) {
                        console.warn("Cannot change the collision groups after the collision object has been created.");
                    }
                    else {
                        this._collisionGroups = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CollisionObject.prototype, "collisionMask", {
                /**
                 *
                 */
                get: function () {
                    return this._collisionMask;
                },
                set: function (value) {
                    if (this.collisionMask === value) {
                        return;
                    }
                    if (this._btCollisionObject) {
                        console.warn("Cannot change the collision mask after the collision object has been created.");
                    }
                    else {
                        this._collisionMask = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CollisionObject.prototype, "btCollisionObject", {
                /**
                 *
                 */
                get: function () {
                    if (!this._btCollisionObject) {
                        this._btCollisionObject = this._createCollisionObject();
                    }
                    return this._btCollisionObject;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], CollisionObject.prototype, "_collisionFlags", void 0);
            __decorate([
                paper.serializedField
            ], CollisionObject.prototype, "_collisionGroups", void 0);
            __decorate([
                paper.serializedField
            ], CollisionObject.prototype, "_collisionMask", void 0);
            return CollisionObject;
        }(paper.BaseComponent));
        ammo.CollisionObject = CollisionObject;
        __reflect(CollisionObject.prototype, "egret3d.ammo.CollisionObject");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 组件事件。
     */
    var EventPool;
    (function (EventPool) {
        var _behaviourComponentType = egret.getQualifiedClassName(paper.Behaviour);
        var _componentListeners = {};
        function _dispatchEvent(type, componentType, component, extend) {
            var componentListeners = _componentListeners[componentType];
            if (type in componentListeners) {
                var eventListeners = componentListeners[type];
                for (var _i = 0, eventListeners_1 = eventListeners; _i < eventListeners_1.length; _i++) {
                    var listener = eventListeners_1[_i];
                    // 监听直接派发，所以监听都应注意 bind 问题。
                    if (extend) {
                        listener(component, extend);
                    }
                    else {
                        listener(component);
                    }
                }
            }
        }
        /**
         * 添加事件监听
         */
        function addEventListener(eventType, componentClass, callback) {
            var componentType = egret.getQualifiedClassName(componentClass);
            var componentListeners = componentType in _componentListeners ? _componentListeners[componentType] : _componentListeners[componentType] = {};
            var eventListeners = eventType in componentListeners ? componentListeners[eventType] : componentListeners[eventType] = [];
            eventListeners.push(callback);
        }
        EventPool.addEventListener = addEventListener;
        /**
         * 移除事件监听
         */
        function removeEventListener(eventType, componentClass, callback) {
            var componentType = egret.getQualifiedClassName(componentClass);
            if (componentType in _componentListeners) {
                var componentListeners = _componentListeners[componentType];
                if (eventType in componentListeners) {
                    var eventListeners = componentListeners[eventType];
                    for (var i = 0, l = eventListeners.length; i < l; i++) {
                        if (eventListeners[i] === callback) {
                            eventListeners.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }
        EventPool.removeEventListener = removeEventListener;
        /**
         * 移除所有该类型的事件监听
         */
        function removeAllEventListener(eventType, componentClass) {
            var componentType = egret.getQualifiedClassName(componentClass);
            if (componentType in _componentListeners) {
                var componentListeners = _componentListeners[componentType];
                if (eventType) {
                    if (eventType in componentListeners) {
                        componentListeners[eventType].length = 0;
                    }
                }
                else {
                    delete _componentListeners[componentType];
                }
            }
        }
        EventPool.removeAllEventListener = removeAllEventListener;
        /**
         * 发送组件事件:
         * @param type event type:
         * @param component component
         */
        function dispatchEvent(type, component, extend) {
            // 如果是组件的添加或删除事件，并且该组件派生自 Behaviour 组件，则需要使用基类的组件类型，这些组件发出的添加或删除事件都能被生命周期系统收到。 
            if (type === "__enabled__" /* Enabled */ || type === "__disabled__" /* Disabled */) {
                if (egret.is(component, _behaviourComponentType)) {
                    _dispatchEvent(type, _behaviourComponentType, component);
                }
            }
            var componentType = egret.getQualifiedClassName(component);
            if (componentType in _componentListeners) {
                _dispatchEvent(type, componentType, component, extend);
            }
        }
        EventPool.dispatchEvent = dispatchEvent;
    })(EventPool = paper.EventPool || (paper.EventPool = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var tmpVecA = new egret3d.Vector3();
    var tmpVecB = new egret3d.Vector3();
    var tmpVecC = new egret3d.Vector3();
    var tmpVecD = new egret3d.Vector3();
    var tmpVecE = new egret3d.Vector3();
    /**
     * aabb box
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 轴对称包围盒
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var AABB = (function () {
        /**
         * build a aabb
         * @param minimum min point
         * @param maximum max point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 构建轴对称包围盒
         * @param minimum 最小点
         * @param maximum 最大点
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        function AABB(minimum, maximum) {
            /**
             * min point
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 最小点
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            this.minimum = new egret3d.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            /**
             * max point
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 最大点
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            this.maximum = new egret3d.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            // TODO local bounding box 与 world bounding box 分离
            this.srcmin = new egret3d.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            this.srcmax = new egret3d.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            this._center = new egret3d.Vector3();
            if (minimum) {
                egret3d.Vector3.copy(minimum, this.srcmin);
                egret3d.Vector3.copy(minimum, this.minimum);
            }
            if (maximum) {
                egret3d.Vector3.copy(maximum, this.srcmax);
                egret3d.Vector3.copy(maximum, this.maximum);
            }
        }
        /**
         * update
         * @param worldmatrix world matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 刷新轴对称包围盒
         * @param worldmatrix 物体的世界矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.update = function (worldmatrix) {
            egret3d.Matrix.getTranslation(worldmatrix, tmpVecA);
            egret3d.Matrix.getTranslation(worldmatrix, tmpVecB);
            if (worldmatrix.rawData[0] > 0) {
                tmpVecA.x += worldmatrix.rawData[0] * this.srcmin.x;
                tmpVecB.x += worldmatrix.rawData[0] * this.srcmax.x;
            }
            else {
                tmpVecA.x += worldmatrix.rawData[0] * this.srcmax.x;
                tmpVecB.x += worldmatrix.rawData[0] * this.srcmin.x;
            }
            if (worldmatrix.rawData[1] > 0) {
                tmpVecA.y += worldmatrix.rawData[1] * this.srcmin.y;
                tmpVecB.y += worldmatrix.rawData[1] * this.srcmax.y;
            }
            else {
                tmpVecA.y += worldmatrix.rawData[1] * this.srcmax.y;
                tmpVecB.y += worldmatrix.rawData[1] * this.srcmin.y;
            }
            if (worldmatrix.rawData[2] > 0) {
                tmpVecA.z += worldmatrix.rawData[2] * this.srcmin.z;
                tmpVecB.z += worldmatrix.rawData[2] * this.srcmax.z;
            }
            else {
                tmpVecA.z += worldmatrix.rawData[2] * this.srcmax.z;
                tmpVecB.z += worldmatrix.rawData[2] * this.srcmin.z;
            }
            if (worldmatrix.rawData[4] > 0) {
                tmpVecA.x += worldmatrix.rawData[4] * this.srcmin.x;
                tmpVecB.x += worldmatrix.rawData[4] * this.srcmax.x;
            }
            else {
                tmpVecA.x += worldmatrix.rawData[4] * this.srcmax.x;
                tmpVecB.x += worldmatrix.rawData[4] * this.srcmin.x;
            }
            if (worldmatrix.rawData[5] > 0) {
                tmpVecA.y += worldmatrix.rawData[5] * this.srcmin.y;
                tmpVecB.y += worldmatrix.rawData[5] * this.srcmax.y;
            }
            else {
                tmpVecA.y += worldmatrix.rawData[5] * this.srcmax.y;
                tmpVecB.y += worldmatrix.rawData[5] * this.srcmin.y;
            }
            if (worldmatrix.rawData[6] > 0) {
                tmpVecA.z += worldmatrix.rawData[6] * this.srcmin.z;
                tmpVecB.z += worldmatrix.rawData[6] * this.srcmax.z;
            }
            else {
                tmpVecA.z += worldmatrix.rawData[6] * this.srcmax.z;
                tmpVecB.z += worldmatrix.rawData[6] * this.srcmin.z;
            }
            if (worldmatrix.rawData[8] > 0) {
                tmpVecA.x += worldmatrix.rawData[8] * this.srcmin.x;
                tmpVecB.x += worldmatrix.rawData[8] * this.srcmax.x;
            }
            else {
                tmpVecA.x += worldmatrix.rawData[8] * this.srcmax.x;
                tmpVecB.x += worldmatrix.rawData[8] * this.srcmin.x;
            }
            if (worldmatrix.rawData[9] > 0) {
                tmpVecA.y += worldmatrix.rawData[9] * this.srcmin.y;
                tmpVecB.y += worldmatrix.rawData[9] * this.srcmax.y;
            }
            else {
                tmpVecA.y += worldmatrix.rawData[9] * this.srcmax.y;
                tmpVecB.y += worldmatrix.rawData[9] * this.srcmin.y;
            }
            if (worldmatrix.rawData[10] > 0) {
                tmpVecA.z += worldmatrix.rawData[10] * this.srcmin.z;
                tmpVecB.z += worldmatrix.rawData[10] * this.srcmax.z;
            }
            else {
                tmpVecA.z += worldmatrix.rawData[10] * this.srcmax.z;
                tmpVecB.z += worldmatrix.rawData[10] * this.srcmin.z;
            }
            egret3d.Vector3.copy(tmpVecA, this.minimum);
            egret3d.Vector3.copy(tmpVecB, this.maximum);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
        };
        /**
         * extend by a point
         * @param vec a world point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 包含一个点
         * @param vec 世界坐标
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.addVector3 = function (vec) {
            egret3d.Vector3.max(this.maximum, vec, this.maximum);
            egret3d.Vector3.min(this.minimum, vec, this.minimum);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
        };
        /**
         * check contains vector
         * @param vec a world point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 检查是否包含点
         * @param vec 世界坐标
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.containsVector3 = function (vec) {
            return (vec.x > this.minimum.x) && (vec.x < this.maximum.x) &&
                (vec.y > this.minimum.y) && (vec.x < this.maximum.y) &&
                (vec.z > this.minimum.z) && (vec.z < this.maximum.z);
        };
        /**
         * intersect with aabb
         * @param aabb aabb
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 检查是否与aabb相交
         * @param aabb 轴对称包围盒
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.intersectAABB = function (aabb) {
            if (this.minimum.x > aabb.maximum.x)
                return false;
            if (this.maximum.x < aabb.minimum.x)
                return false;
            if (this.minimum.x > aabb.maximum.x)
                return false;
            if (this.maximum.x < aabb.minimum.x)
                return false;
            if (this.minimum.x > aabb.maximum.x)
                return false;
            if (this.maximum.x < aabb.minimum.x)
                return false;
            return true;
        };
        /**
         *
         * 用于视锥检测的计算，引擎内部使用
         * 这里采用包围球式计算以提高性能
         */
        AABB.prototype.intersectPlane = function (v0, v1, v2) {
            var subV0 = tmpVecA;
            var subV1 = tmpVecB;
            var cross = tmpVecC;
            var hitPoint = tmpVecD;
            var distVec = tmpVecE;
            var center = this.center;
            egret3d.Vector3.subtract(v1, v0, subV0);
            egret3d.Vector3.subtract(v2, v1, subV1);
            egret3d.Vector3.cross(subV0, subV1, cross);
            egret3d.calPlaneLineIntersectPoint(cross, v0, cross, center, hitPoint);
            egret3d.Vector3.subtract(hitPoint, center, distVec);
            var val = egret3d.Vector3.dot(cross, distVec);
            if (val <= 0) {
                return true;
            }
            var dist = egret3d.Vector3.getDistance(center, hitPoint);
            if (dist < this.radius) {
                return true;
            }
            return false;
        };
        /**
         * extend by aabb
         * @param aabb aabb
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 包含一个aabb
         * @param aabb 轴对称包围盒
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.addAABB = function (aabb) {
            egret3d.Vector3.max(this.maximum, aabb.maximum, this.maximum);
            egret3d.Vector3.min(this.minimum, aabb.minimum, this.minimum);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
        };
        Object.defineProperty(AABB.prototype, "center", {
            /**
             * get center
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 获取中心点位置
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                if (this._dirtyCenter) {
                    egret3d.Vector3.add(this.maximum, this.minimum, this._center);
                    egret3d.Vector3.scale(this._center, 0.5);
                    this._dirtyCenter = false;
                }
                return this._center;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "radius", {
            /**
             * get bounding sphere radius
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 获取包围球的半径
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                if (this._dirtyRadius) {
                    egret3d.Vector3.subtract(this.maximum, this.minimum, tmpVecA);
                    egret3d.Vector3.scale(tmpVecA, 0.5);
                    this._dirtyRadius = false;
                }
                return egret3d.Vector3.getLength(tmpVecA);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * clear
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 清空
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.clear = function () {
            egret3d.Vector3.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this.minimum);
            egret3d.Vector3.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this.maximum);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
        };
        /**
         * clone
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 克隆
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.clone = function () {
            var aabb = new egret3d.AABB(this.minimum, this.maximum);
            return aabb;
        };
        /**
         * copy
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 复制
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.copy = function (aabb) {
            egret3d.Vector3.copy(aabb.minimum, this.minimum);
            egret3d.Vector3.copy(aabb.maximum, this.maximum);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            return this;
        };
        /**
         * get vectors
         * @param vecs output vectors
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取包围盒顶点数据
         * @param vecs 引用数组
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.getVec3 = function (vecs) {
            vecs[0] = egret3d.Vector3.copy(this.minimum, new egret3d.Vector3());
            vecs[1] = egret3d.Vector3.copy(this.minimum, new egret3d.Vector3());
            vecs[1].z = this.maximum.z;
            vecs[2] = egret3d.Vector3.copy(this.minimum, new egret3d.Vector3());
            vecs[2].x = this.maximum.x;
            vecs[3] = egret3d.Vector3.copy(this.maximum, new egret3d.Vector3());
            vecs[3].y = this.minimum.y;
            vecs[4] = egret3d.Vector3.copy(this.minimum, new egret3d.Vector3());
            vecs[4].y = this.maximum.y;
            vecs[5] = egret3d.Vector3.copy(this.maximum, new egret3d.Vector3());
            vecs[5].x = this.minimum.x;
            vecs[6] = egret3d.Vector3.copy(this.maximum, new egret3d.Vector3());
            vecs[6].z = this.minimum.z;
            vecs[7] = egret3d.Vector3.copy(this.maximum, new egret3d.Vector3());
        };
        return AABB;
    }());
    egret3d.AABB = AABB;
    __reflect(AABB.prototype, "egret3d.AABB");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = new egret3d.Vector3();
    var _helpVector3B = new egret3d.Vector3();
    /**
     * obb box
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 定向包围盒
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var OBB = (function (_super) {
        __extends(OBB, _super);
        function OBB() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * center
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 包围盒中心
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.center = new egret3d.Vector3();
            /**
             * size
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 包围盒各轴向长
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.size = new egret3d.Vector3();
            /**
             * vectors
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 包围盒世界空间下各个点坐标
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.vectors = [
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
            ];
            _this._directions = [
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
            ];
            return _this;
        }
        OBB.prototype._computeBoxExtents = function (axis, box, out) {
            var p = egret3d.Vector3.dot(box.center, axis);
            //
            var r0 = Math.abs(egret3d.Vector3.dot(box._directions[0], axis)) * box.size.x * 0.5;
            var r1 = Math.abs(egret3d.Vector3.dot(box._directions[1], axis)) * box.size.y * 0.5;
            var r2 = Math.abs(egret3d.Vector3.dot(box._directions[2], axis)) * box.size.z * 0.5;
            //
            var r = r0 + r1 + r2;
            out.x = p - r;
            out.y = p + r;
            return out;
        };
        OBB.prototype._axisOverlap = function (axis, a, b) {
            var resultA = this._computeBoxExtents(axis, a, _helpVector3A);
            var resultB = this._computeBoxExtents(axis, b, _helpVector3B);
            return !(resultA.x > resultA.y || resultB.x > resultB.y);
        };
        /**
         * clone a obb
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 克隆一个obb
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.clone = function () {
            var value = new OBB();
            egret3d.Vector3.copy(this.center, value.center);
            egret3d.Vector3.copy(this.center, value.size);
            for (var key in this._directions) {
                egret3d.Vector3.copy(this._directions[key], value._directions[key]);
            }
            return value;
        };
        /**
         * build by min point and max point
         * @param minimum min point
         * @param maximum max point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 由最大最小点构建定向包围盒
         * @param minimum 最小点坐标
         * @param maximum 最大点坐标
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.setByMaxMin = function (minimum, maximum) {
            egret3d.Vector3.copy(minimum, this.vectors[0]);
            egret3d.Vector3.copy(minimum, this.vectors[1]);
            egret3d.Vector3.copy(minimum, this.vectors[2]);
            egret3d.Vector3.copy(maximum, this.vectors[3]);
            egret3d.Vector3.copy(minimum, this.vectors[4]);
            egret3d.Vector3.copy(maximum, this.vectors[5]);
            egret3d.Vector3.copy(maximum, this.vectors[6]);
            egret3d.Vector3.copy(maximum, this.vectors[7]);
            //
            this.vectors[1].z = maximum.z;
            this.vectors[2].x = maximum.x;
            this.vectors[3].y = minimum.y;
            this.vectors[4].y = maximum.y;
            this.vectors[5].x = minimum.x;
            this.vectors[6].z = minimum.z;
            //
            egret3d.Vector3.add(maximum, minimum, this.center);
            egret3d.Vector3.scale(this.center, 0.5);
            egret3d.Vector3.subtract(maximum, minimum, this.size);
        };
        /**
         * build by center and size
         * @param center center
         * @param size size
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 由中心点和各轴向长度构建定向包围盒
         * @param center 中心点坐标
         * @param size 各轴向长度
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.setByCenterSize = function (center, size) {
            egret3d.Vector3.copy(center, this.center);
            egret3d.Vector3.copy(size, this.size);
            //
            var hsx = this.size.x * 0.5;
            var hsy = this.size.y * 0.5;
            var hsz = this.size.z * 0.5;
            var cenx = this.center.x;
            var ceny = this.center.y;
            var cenz = this.center.z;
            //
            egret3d.Vector3.set(cenx - hsx, ceny - hsy, cenz - hsz, this.vectors[0]);
            egret3d.Vector3.set(cenx - hsx, ceny - hsy, cenz + hsz, this.vectors[1]);
            egret3d.Vector3.set(cenx + hsx, ceny - hsy, cenz - hsz, this.vectors[2]);
            egret3d.Vector3.set(cenx + hsx, ceny - hsy, cenz + hsz, this.vectors[3]);
            egret3d.Vector3.set(cenx - hsx, ceny + hsy, cenz - hsz, this.vectors[4]);
            egret3d.Vector3.set(cenx - hsx, ceny + hsy, cenz + hsz, this.vectors[5]);
            egret3d.Vector3.set(cenx + hsx, ceny + hsy, cenz - hsz, this.vectors[6]);
            egret3d.Vector3.set(cenx + hsx, ceny + hsy, cenz + hsz, this.vectors[7]);
        };
        /**
         * update by world matrix
         * @param worldmatrix world matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 刷新定向包围盒
         * @param worldmatrix 世界矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.update = function (worldMatrix) {
            egret3d.Matrix.getTranslation(worldMatrix, this.center);
            egret3d.Matrix.getVector3ByOffset(worldMatrix, 0, this._directions[0]);
            egret3d.Matrix.getVector3ByOffset(worldMatrix, 4, this._directions[1]);
            egret3d.Matrix.getVector3ByOffset(worldMatrix, 8, this._directions[2]);
        };
        /**
         * intersect width obb
         * @param value obb
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * obb的碰撞检测
         * @param value 待检测obb
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.intersects = function (value) {
            var a = this;
            var b = value;
            //
            if (!this._axisOverlap(a._directions[0], a, b))
                return false;
            if (!this._axisOverlap(a._directions[1], a, b))
                return false;
            if (!this._axisOverlap(a._directions[2], a, b))
                return false;
            if (!this._axisOverlap(b._directions[0], a, b))
                return false;
            if (!this._axisOverlap(b._directions[1], a, b))
                return false;
            if (!this._axisOverlap(b._directions[2], a, b))
                return false;
            var result = _helpVector3A;
            egret3d.Vector3.cross(a._directions[0], b._directions[0], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[0], b._directions[1], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[0], b._directions[2], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[1], b._directions[0], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[1], b._directions[1], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[1], b._directions[2], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[2], b._directions[0], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[2], b._directions[1], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[2], b._directions[2], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            return true;
        };
        /**
         * update vectors by world matrix
         * @param vectors vectors
         * @param worldMatrix world matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 计算世界空间下各点坐标
         * @param vectors 结果数组
         * @param worldMatrix 物体的世界矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.caclWorldVectors = function (vectors, worldMatrix) {
            for (var i = 0; i < 8; ++i) {
                egret3d.Matrix.transformVector3(this.vectors[i], worldMatrix, vectors[i]);
            }
        };
        OBB.prototype.deserialize = function (element) {
            this.center.deserialize(element.center);
            this.size.deserialize(element.size);
        };
        __decorate([
            paper.serializedField
        ], OBB.prototype, "center", void 0);
        __decorate([
            paper.serializedField
        ], OBB.prototype, "size", void 0);
        return OBB;
    }(paper.SerializableObject));
    egret3d.OBB = OBB;
    __reflect(OBB.prototype, "egret3d.OBB");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 贝塞尔曲线，目前定义了三种：线性贝塞尔曲线(两个点形成),二次方贝塞尔曲线（三个点形成），三次方贝塞尔曲线（四个点形成）
     */
    var Curve3 = (function () {
        function Curve3(points, nbPoints) {
            this._beizerPoints = points;
            this._bezierPointNum = nbPoints;
        }
        Object.defineProperty(Curve3.prototype, "beizerPoints", {
            get: function () {
                return this._beizerPoints;
            },
            set: function (value) {
                this._beizerPoints = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Curve3.prototype, "bezierPointNum", {
            get: function () {
                return this._bezierPointNum;
            },
            set: function (value) {
                this._bezierPointNum = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 线性贝塞尔曲线
         */
        Curve3.CreateLinearBezier = function (start, end, indices) {
            indices = indices > 2 ? indices : 3;
            var bez = new Array();
            var equation = function (t, va10, va11) {
                var res = (1.0 - t) * va10 + t * va11;
                return res;
            };
            bez.push(start);
            for (var i = 1; i <= indices; i++) {
                bez.push(new egret3d.Vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
            }
            return new Curve3(bez, indices);
        };
        /**
         * 二次方贝塞尔曲线路径
         * @param v0 起始点
         * @param v1 选中的节点
         * @param v2 结尾点
         * @param nbPoints 将贝塞尔曲线拆分nbPoints段，一共有nbPoints + 1个点
         */
        Curve3.CreateQuadraticBezier = function (v0, v1, v2, bezierPointNum) {
            bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2) {
                var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        /**
         * 三次方贝塞尔曲线路径
         * @param v0
         * @param v1
         * @param v2
         * @param v3
         * @param nbPoints
         */
        Curve3.CreateCubicBezier = function (v0, v1, v2, v3, bezierPointNum) {
            bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2, val3) {
                var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        /**
         * 贝塞尔曲线上的点
         */
        Curve3.prototype.getPoints = function () {
            return this._beizerPoints;
        };
        return Curve3;
    }());
    egret3d.Curve3 = Curve3;
    __reflect(Curve3.prototype, "egret3d.Curve3");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 可以挂载Component的实体类。
     */
    var GameObject = (function (_super) {
        __extends(GameObject, _super);
        /**
         * 创建GameObject，并添加到当前场景中
         */
        function GameObject(name, tag) {
            if (name === void 0) { name = "NoName"; }
            if (tag === void 0) { tag = ""; }
            var _this = _super.call(this) || this;
            /**
             * 是否是静态，启用这个属性可以提升性能
             */
            _this.isStatic = false;
            /**
             * 层级
             */
            _this.layer = 2 /* Default */;
            /**
             * 名称
             */
            _this.name = "";
            /**
             * 标签
             */
            _this.tag = "";
            /**
             * 变换组件
             */
            _this.transform = null;
            /**
             *
             */
            _this.renderer = null;
            /**
             * 预制体
             */
            _this.prefab = null;
            /**
             * @internal
             */
            _this.prefabEditInfo = null;
            _this._activeSelf = true;
            /**
             * @internal
             */
            _this._activeInHierarchy = true;
            /**
             * @internal
             */
            _this._activeDirty = true;
            /**
             * @internal
             */
            _this._components = [];
            _this._scene = null;
            _this.name = name;
            _this.tag = tag;
            _this.addComponent(egret3d.Transform);
            _this._addToScene(paper.Application.sceneManager.activeScene);
            return _this;
        }
        /**
         * @internal
         */
        GameObject.prototype._activeInHierarchyDirty = function (prevActive) {
            this._activeDirty = true;
            var currentActive = this.activeInHierarchy;
            if (currentActive !== prevActive) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (component.enabled) {
                        paper.EventPool.dispatchEvent(currentActive ? "__enabled__" /* Enabled */ : "__disabled__" /* Disabled */, component);
                    }
                }
            }
            for (var _b = 0, _c = this.transform.children; _b < _c.length; _b++) {
                var child = _c[_b];
                child.gameObject._activeInHierarchyDirty(prevActive);
            }
        };
        GameObject.prototype._addToScene = function (value) {
            if (this._scene) {
                this._scene._removeGameObject(this);
            }
            this._scene = value;
            this._scene._addGameObject(this);
        };
        GameObject.prototype._canRemoveComponent = function (value) {
            if (value === this.transform) {
                console.warn("Cannot remove the transform component from a game object.");
                return false;
            }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                var className = egret.getQualifiedClassName(component);
                if (className in paper._requireComponents) {
                    var requireComponents = paper._requireComponents[className];
                    if (requireComponents.indexOf(value.constructor) >= 0) {
                        console.warn("Cannot remove the " + egret.getQualifiedClassName(value) + " component from the game object (" + this.path + "), because it is required from the " + className + " component.");
                        return false;
                    }
                }
            }
            return true;
        };
        GameObject.prototype._removeComponentReference = function (component) {
            component.enabled = false;
            component.gameObject = null;
            if (component === this.renderer) {
                this.renderer = null;
            }
            var destroySystem = paper.Application.systemManager.getSystem(paper.DestroySystem);
            if (destroySystem) {
                destroySystem.bufferComponent(component);
            }
        };
        GameObject.prototype._getComponentsInChildren = function (componentClass, child, array, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var components = child._components;
            for (var _i = 0, components_2 = components; _i < components_2.length; _i++) {
                var component = components_2[_i];
                if (isExtends ? egret.is(component, egret.getQualifiedClassName(componentClass)) : component.constructor === componentClass) {
                    array.push(component);
                }
            }
            for (var _a = 0, _b = child.transform.children; _a < _b.length; _a++) {
                var childOfChild = _b[_a];
                this._getComponentsInChildren(componentClass, childOfChild.gameObject, array, isExtends);
            }
        };
        GameObject.prototype._destroy = function () {
            var destroySystem = paper.Application.systemManager.getSystem(paper.DestroySystem);
            if (destroySystem) {
                destroySystem.bufferGameObject(this);
            }
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child.gameObject._destroy();
            }
            for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                var component = _c[_b];
                this._removeComponentReference(component);
            }
            this.transform = null;
            this.renderer = null;
            this._components.length = 0;
            this._scene._removeGameObject(this);
            this._scene = null;
        };
        /**
         *
         */
        GameObject.prototype.destroy = function () {
            if (this.isDestroyed) {
                console.warn("The game object (" + this.path + ") has been destroyed.");
                return;
            }
            if (this === paper.Application.sceneManager.globalGameObject) {
                console.warn("Cannot destroy global game object.");
                return;
            }
            var parent = this.transform.parent;
            if (parent) {
                parent._children.splice(parent._children.indexOf(this.transform), 1);
            }
            this._destroy();
        };
        /**
         * 根据类型名获取组件
         */
        GameObject.prototype.addComponent = function (componentClass, config) {
            if (paper._disallowMultipleComponents.indexOf(componentClass) >= 0) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component_1 = _a[_i];
                    if (component_1 instanceof componentClass) {
                        console.warn("Cannot add the " + egret.getQualifiedClassName(componentClass) + " component to the game object (" + this.path + ") again.");
                        return;
                    }
                }
            }
            var className = egret.getQualifiedClassName(componentClass);
            if (className in paper._requireComponents) {
                var requireComponents = paper._requireComponents[className];
                for (var _b = 0, requireComponents_1 = requireComponents; _b < requireComponents_1.length; _b++) {
                    var requireComponentClass = requireComponents_1[_b];
                    this.getComponent(requireComponentClass) || this.addComponent(requireComponentClass);
                }
            }
            paper.BaseComponent._injectGameObject = this;
            var component = new componentClass();
            if (component instanceof egret3d.Transform) {
                this.transform = component;
            }
            else if (component instanceof paper.BaseRenderer) {
                this.renderer = component;
            }
            this._components.push(component);
            if (config) {
                component.initialize(config);
            }
            else {
                component.initialize();
            }
            if (component.isActiveAndEnabled) {
                paper.EventPool.dispatchEvent("__enabled__" /* Enabled */, component);
            }
            return component;
        };
        /**
         * 移除组件
         */
        GameObject.prototype.removeComponent = function (componentInstanceOrClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentInstanceOrClass instanceof paper.BaseComponent) {
                var index = 0;
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (component === componentInstanceOrClass) {
                        if (!this._canRemoveComponent(component)) {
                            return;
                        }
                        this._removeComponentReference(component);
                        this._components.splice(index, 1);
                        return;
                    }
                    index++;
                }
            }
            else {
                var i = this._components.length;
                while (i--) {
                    var component = this._components[i];
                    if (isExtends ? egret.is(component, egret.getQualifiedClassName(componentInstanceOrClass)) : component.constructor === componentInstanceOrClass) {
                        if (!this._canRemoveComponent(component)) {
                            return;
                        }
                        this._removeComponentReference(component);
                        this._components.splice(i, 1);
                        return;
                    }
                }
            }
        };
        /**
         * 移除自身的所有组件
         */
        GameObject.prototype.removeAllComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentClass) {
                var i = this._components.length;
                while (i--) {
                    var component = this._components[i];
                    if (isExtends ? egret.is(component, egret.getQualifiedClassName(componentClass)) : component.constructor === componentClass) {
                        if (!this._canRemoveComponent(component)) {
                            return;
                        }
                        this._removeComponentReference(component);
                        this._components.splice(i, 1);
                    }
                }
            }
            else {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (component instanceof egret3d.Transform) {
                        continue;
                    }
                    this._removeComponentReference(component);
                    this._components.length = 0;
                    this._components.push(this.transform);
                }
            }
        };
        /**
         * 根据类型名获取组件
         */
        GameObject.prototype.getComponent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (egret.is(component, egret.getQualifiedClassName(componentClass))) {
                        return component;
                    }
                }
            }
            else {
                for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                    var component = _c[_b];
                    if (component.constructor === componentClass) {
                        return component;
                    }
                }
            }
            return null;
        };
        GameObject.prototype.getComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var components = [];
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (isExtends ? egret.is(component, egret.getQualifiedClassName(componentClass)) : component.constructor === componentClass) {
                    components.push(component);
                }
            }
            return components;
        };
        /**
         * 搜索自己和父节点中所有特定类型的组件
         */
        GameObject.prototype.getComponentInParent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var result = null;
            var parent = this.transform.parent;
            while (!result && parent) {
                result = parent.gameObject.getComponent(componentClass, isExtends);
                parent = parent.parent;
            }
            return result;
        };
        /**
         * 搜索自己和子节点中所有特定类型的组件
         */
        GameObject.prototype.getComponentsInChildren = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var components = [];
            this._getComponentsInChildren(componentClass, this, components, isExtends);
            return components;
        };
        /**
         * 针对同级的组件发送消息
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (component.isActiveAndEnabled && component.constructor instanceof paper.Behaviour) {
                    if (methodName in component) {
                        component[methodName](parameter);
                    }
                    else if (requireReceiver) {
                        console.warn(this.name, egret.getQualifiedClassName(component), methodName); // TODO
                    }
                }
            }
        };
        /**
         * 针对直接父级发送消息
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessageUpwards = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            this.sendMessage(methodName, parameter, requireReceiver);
            //
            var parent = this.transform.parent;
            if (parent && parent.gameObject.activeInHierarchy) {
                parent.gameObject.sendMessage(methodName, parameter, requireReceiver);
            }
        };
        /**
         * 群发消息
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.broadcastMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            this.sendMessage(methodName, parameter, requireReceiver);
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.gameObject.activeInHierarchy) {
                    child.gameObject.broadcastMessage(methodName, parameter, requireReceiver);
                }
            }
        };
        Object.defineProperty(GameObject.prototype, "isDestroyed", {
            /**
             *
             */
            get: function () {
                return !this._scene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "dontDestroy", {
            /**
             *
             */
            get: function () {
                return this._scene === paper.Application.sceneManager.globalScene;
            },
            set: function (value) {
                if (this.dontDestroy === value) {
                    return;
                }
                for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child.gameObject.dontDestroy = value;
                }
                if (value) {
                    this._addToScene(paper.Application.sceneManager.globalScene);
                }
                else {
                    if (this === paper.Application.sceneManager.globalGameObject) {
                        console.warn("Cannot change the `dontDestroy` value of the global game object.", this.name, this.uuid);
                        return;
                    }
                    this._addToScene(paper.Application.sceneManager.activeScene);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeSelf", {
            /**
             * 当前GameObject对象自身激活状态
             */
            get: function () {
                return this._activeSelf;
            },
            set: function (value) {
                if (this._activeSelf === value) {
                    return;
                }
                var parent = this.transform.parent;
                if (!parent || parent.gameObject.activeInHierarchy) {
                    var prevActive = this._activeSelf;
                    this._activeSelf = value;
                    this._activeInHierarchyDirty(prevActive);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeInHierarchy", {
            /**
             * 获取当前GameObject对象在场景中激活状态。
             * 如果当前对象父级的activeSelf为false，那么当前GameObject对象在场景中为禁用状态。
             */
            get: function () {
                if (this._activeDirty) {
                    var parent_1 = this.transform.parent;
                    if (!parent_1 || parent_1.gameObject.activeInHierarchy) {
                        this._activeInHierarchy = this._activeSelf;
                    }
                    else {
                        this._activeInHierarchy = false;
                    }
                    this._activeDirty = false;
                }
                return this._activeInHierarchy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "path", {
            get: function () {
                var path = this.name;
                if (this.transform) {
                    var parent_2 = this.transform.parent;
                    while (parent_2) {
                        path = parent_2.gameObject.name + "/" + path;
                        parent_2 = parent_2.gameObject.transform;
                    }
                    return this._scene.name + "/" + path;
                }
                return path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "components", {
            /**
             * 组件列表
             */
            get: function () {
                return this._components;
            },
            /**
             * 仅用于反序列化。
             * @internal
             */
            set: function (value) {
                this._components.length = 0;
                for (var _i = 0, value_2 = value; _i < value_2.length; _i++) {
                    var component = value_2[_i];
                    if (component instanceof paper.MissingObject) {
                        this.addComponent(paper.MissingComponent).missingObject = component;
                    }
                    else {
                        if (component instanceof paper.BaseRenderer) {
                            this.renderer = component;
                        }
                        this._components.push(component);
                    }
                }
                this.transform = this.getComponent(egret3d.Transform) || this.addComponent(egret3d.Transform);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "scene", {
            /**
             * 获取物体所在场景实例。
             */
            get: function () {
                return this._scene;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         * @see paper.Scene#find()
         */
        GameObject.find = function (name, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).find(name);
        };
        /**
         * @deprecated
         * @see paper.Scene#findWithTag()
         */
        GameObject.findWithTag = function (tag, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).findWithTag(tag);
        };
        /**
         * @deprecated
         * @see paper.Scene#findGameObjectsWithTag()
         */
        GameObject.findGameObjectsWithTag = function (tag, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).findGameObjectsWithTag(tag);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], GameObject.prototype, "isStatic", void 0);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], GameObject.prototype, "layer", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.TEXT)
        ], GameObject.prototype, "name", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "tag", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "prefab", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "prefabEditInfo", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "_activeSelf", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "components", null);
        return GameObject;
    }(paper.SerializableObject));
    paper.GameObject = GameObject;
    __reflect(GameObject.prototype, "paper.GameObject");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    egret3d.RAD_DEG = 180.0 / Math.PI;
    /**
     *
     */
    egret3d.DEG_RAD = Math.PI / 180.0;
    function floatClamp(v, min, max) {
        if (min === void 0) { min = 0; }
        if (max === void 0) { max = 1; }
        if (v < min)
            return min;
        else if (v > max)
            return max;
        else
            return v;
    }
    egret3d.floatClamp = floatClamp;
    function sign(value) {
        value = +value; // convert to a number
        if (value === 0 || isNaN(value))
            return value;
        return value > 0 ? 1 : -1;
    }
    egret3d.sign = sign;
    function numberLerp(fromV, toV, v) {
        return fromV * (1 - v) + toV * v;
    }
    egret3d.numberLerp = numberLerp;
    function calPlaneLineIntersectPoint(planeVector, planePoint, lineVector, linePoint, out) {
        var vp1 = planeVector.x;
        var vp2 = planeVector.y;
        var vp3 = planeVector.z;
        var n1 = planePoint.x;
        var n2 = planePoint.y;
        var n3 = planePoint.z;
        var v1 = lineVector.x;
        var v2 = lineVector.y;
        var v3 = lineVector.z;
        var m1 = linePoint.x;
        var m2 = linePoint.y;
        var m3 = linePoint.z;
        var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
        if (vpt === 0) {
            out = null;
        }
        else {
            var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
            out.x = m1 + v1 * t;
            out.y = m2 + v2 * t;
            out.z = m3 + v3 * t;
        }
        return out;
    }
    egret3d.calPlaneLineIntersectPoint = calPlaneLineIntersectPoint;
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpVec3_3 = new egret3d.Vector3();
    var helpVec3_4 = new egret3d.Vector3();
    var helpVec3_5 = new egret3d.Vector3();
    function getPointAlongCurve(curveStart, curveStartHandle, curveEnd, curveEndHandle, t, out, crease) {
        if (crease === void 0) { crease = 0.3; }
        var oneMinT = 1 - t;
        var oneMinTPow3 = Math.pow(oneMinT, 3);
        var oneMinTPow2 = Math.pow(oneMinT, 2);
        var oneMinCrease = 1 - crease;
        var tempt1 = helpVec3_1;
        egret3d.Vector3.copy(curveStart, tempt1);
        egret3d.Vector3.scale(tempt1, oneMinTPow3 * oneMinCrease);
        var tempt2 = helpVec3_2;
        egret3d.Vector3.copy(curveStartHandle, tempt2);
        egret3d.Vector3.scale(tempt2, 3 * oneMinTPow2 * t * crease);
        var tempt3 = helpVec3_3;
        egret3d.Vector3.copy(curveEndHandle, tempt3);
        egret3d.Vector3.scale(tempt3, 3 * oneMinT * Math.pow(t, 2) * crease);
        var tempt4 = helpVec3_4;
        egret3d.Vector3.copy(curveEnd, tempt4);
        egret3d.Vector3.scale(tempt4, Math.pow(t, 3) * oneMinCrease);
        var tempt5 = helpVec3_5;
        egret3d.Vector3.add(tempt1, tempt2, tempt5);
        egret3d.Vector3.add(tempt5, tempt3, tempt5);
        egret3d.Vector3.add(tempt5, tempt4, tempt5);
        egret3d.Vector3.copy(tempt5, out);
        egret3d.Vector3.scale(out, 1 / (oneMinTPow3 * oneMinCrease + 3 * oneMinTPow2 * t * crease + 3 * oneMinT * Math.pow(t, 2) * crease + Math.pow(t, 3) * oneMinCrease));
    }
    egret3d.getPointAlongCurve = getPointAlongCurve;
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 场景类
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        /**
         * @internal
         */
        function Scene(isActive) {
            if (isActive === void 0) { isActive = true; }
            var _this = _super.call(this) || this;
            /**
             * 场景名称。
             */
            _this.name = "";
            /**
             * 场景的light map列表。
             */
            _this.lightmaps = [];
            /**
             * lightmap强度
             */
            _this.lightmapIntensity = 1.0;
            /**
             * 存储着关联的数据
             * 场景保存时，将场景快照数据保存至对应的资源中
             */
            _this.rawScene = null;
            /**
             * @internal
             */
            _this._gameObjects = [];
            paper.Application.sceneManager._addScene(_this, isActive);
            return _this;
        }
        /**
         * @internal
         */
        Scene.prototype._destroy = function () {
            var i = this._gameObjects.length;
            while (i--) {
                var gameObject = this._gameObjects[i];
                if (!gameObject || gameObject.transform.parent) {
                    continue;
                }
                gameObject.destroy();
            }
            this.lightmaps.length = 0;
            this._gameObjects.length = 0;
            this.rawScene = null;
        };
        /**
         * @internal
         */
        Scene.prototype._removeGameObject = function (gameObject) {
            var index = this._gameObjects.indexOf(gameObject);
            if (index > -1) {
                this._gameObjects.splice(index, 1);
            }
            else {
                console.debug("Remove game object again.", gameObject.name, gameObject.uuid);
            }
        };
        /**
         * @internal
         */
        Scene.prototype._addGameObject = function (gameObject) {
            if (this._gameObjects.indexOf(gameObject) < 0) {
                this._gameObjects.push(gameObject);
            }
            else {
                console.debug("Add game object again.", gameObject.name, gameObject.uuid);
            }
        };
        /**
         * 返回当前激活场景中查找对应名称的GameObject
         * @param name
         */
        Scene.prototype.find = function (name) {
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.name === name) {
                    return gameObject;
                }
            }
            return null;
        };
        /**
         * 返回一个在当前激活场景中查找对应tag的GameObject
         * @param tag
         */
        Scene.prototype.findWithTag = function (tag) {
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.tag === tag) {
                    return gameObject;
                }
            }
            return null;
        };
        /**
         * 返回一个在当前激活场景中查找对应 uuid 的GameObject
         * @param uuid
         */
        Scene.prototype.findWithUUID = function (uuid) {
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.uuid === uuid) {
                    return gameObject;
                }
            }
            return null;
        };
        /**
         * 返回所有在当前激活场景中查找对应tag的GameObject
         * @param name
         */
        Scene.prototype.findGameObjectsWithTag = function (tag) {
            var gameObjects = [];
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.tag === tag) {
                    gameObjects.push(gameObject);
                }
            }
            return gameObjects;
        };
        /**
         * 获取所有根级GameObject对象
         */
        Scene.prototype.getRootGameObjects = function () {
            var gameObjects = [];
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (!gameObject.transform.parent) {
                    gameObjects.push(gameObject);
                }
            }
            return gameObjects;
        };
        Object.defineProperty(Scene.prototype, "gameObjectCount", {
            get: function () {
                return this._gameObjects.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene.prototype, "gameObjects", {
            /**
             * 当前场景的所有GameObject对象池
             */
            get: function () {
                return this._gameObjects;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Scene.prototype, "name", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "lightmaps", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "lightmapIntensity", void 0);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Scene.prototype, "gameObjects", null);
        return Scene;
    }(paper.SerializableObject));
    paper.Scene = Scene;
    __reflect(Scene.prototype, "paper.Scene");
})(paper || (paper = {}));
var paper;
(function (paper) {
    var Time = (function () {
        function Time() {
        }
        Time.initialize = function () {
            this._lastTimer = this._beginTimer = Date.now() * 0.001;
        };
        Time.update = function (timer) {
            var now = timer || Date.now() * 0.001;
            this._frameCount += 1;
            this._unscaledTime = now - this._beginTimer;
            this._unscaledDeltaTime = now - this._lastTimer;
            this._lastTimer = now;
        };
        Object.defineProperty(Time, "frameCount", {
            get: function () {
                return this._frameCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Time, "time", {
            get: function () {
                return this._unscaledTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Time, "unscaledTime", {
            get: function () {
                return this._unscaledTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Time, "deltaTime", {
            get: function () {
                return this._unscaledDeltaTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Time, "unscaledDeltaTime", {
            get: function () {
                return this._unscaledDeltaTime;
            },
            enumerable: true,
            configurable: true
        });
        Time.maxFixedSubSteps = 3;
        Time.timeScale = 1.0;
        Time.fixedTimeStep = 1 / 30.0;
        Time._frameCount = 0;
        Time._lastTimer = 0.0;
        Time._beginTimer = 0.0;
        Time._unscaledTime = 0.0;
        Time._unscaledDeltaTime = 0.0;
        return Time;
    }());
    paper.Time = Time;
    __reflect(Time.prototype, "paper.Time");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * scene asset
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 场景数据资源
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var RawScene = (function (_super) {
        __extends(RawScene, _super);
        function RawScene() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * clone from this scene
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 从当前场景克隆。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        RawScene.prototype.createInstance = function () {
            if (!this._raw) {
                return null;
            }
            return paper.deserialize(this._raw, this._assets);
        };
        return RawScene;
    }(egret3d.BaseObjectAsset));
    egret3d.RawScene = RawScene;
    __reflect(RawScene.prototype, "egret3d.RawScene");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * textrue asset
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 纹理资源。
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._realName = "";
            return _this;
        }
        /**
         * @inheritDoc
         */
        Texture.prototype.dispose = function () {
            this.glTexture.dispose(egret3d.WebGLKit.webgl);
        };
        /**
         * @inheritDoc
         */
        Texture.prototype.caclByteLength = function () {
            if (this.glTexture) {
                return this.glTexture.caclByteLength();
            }
            return 0;
        };
        Object.defineProperty(Texture.prototype, "realName", {
            /**
             * real image name
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 如果是imgdesc加载来的图片，通过这个可以获取到真实的图片名字。
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                return this._realName;
            },
            set: function (name) {
                this._realName = name;
            },
            enumerable: true,
            configurable: true
        });
        return Texture;
    }(paper.Asset));
    egret3d.Texture = Texture;
    __reflect(Texture.prototype, "egret3d.Texture");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * glTF 资源。
     */
    var GLTFAsset = (function (_super) {
        __extends(GLTFAsset, _super);
        function GLTFAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Buffer 列表。
             */
            _this.buffers = [];
            /**
             * 配置。
             */
            _this.config = null;
            return _this;
        }
        /**
         *
         */
        GLTFAsset.getComponentTypeCount = function (type) {
            switch (type) {
                case 5120 /* Byte */:
                case 5121 /* UnsignedByte */:
                    return 1;
                case 5122 /* Short */:
                case 5123 /* UnsignedShort */:
                    return 2;
                case 5124 /* Int */:
                case 5125 /* UnsignedInt */:
                    return 4;
                case 5126 /* Float */:
                    return 4;
                default:
                    throw new Error();
            }
        };
        /**
         *
         */
        GLTFAsset.getAccessorTypeCount = function (type) {
            switch (type) {
                case "SCALAR" /* SCALAR */:
                    return 1;
                case "VEC2" /* VEC2 */:
                    return 2;
                case "VEC3" /* VEC3 */:
                    return 3;
                case "VEC4" /* VEC4 */:
                case "MAT2" /* MAT2 */:
                    return 4;
                case "MAT3" /* MAT3 */:
                    return 9;
                case "MAT4" /* MAT4 */:
                    return 16;
                default:
                    throw new Error();
            }
        };
        /**
         * 自定义 Mesh 的属性枚举。
         */
        GLTFAsset.getMeshAttributeType = function (type) {
            switch (type) {
                case "POSITION" /* POSITION */:
                case "NORMAL" /* NORMAL */:
                    return "VEC3" /* VEC3 */;
                case "TEXCOORD_0" /* TEXCOORD_0 */:
                case "TEXCOORD_1" /* TEXCOORD_1 */:
                    return "VEC2" /* VEC2 */;
                case "TANGENT" /* TANGENT */:
                case "COLOR_0" /* COLOR_0 */:
                case "COLOR_1" /* COLOR_1 */:
                case "JOINTS_0" /* JOINTS_0 */:
                case "WEIGHTS_0" /* WEIGHTS_0 */:
                    return "VEC4" /* VEC4 */;
                default:
                    throw new Error();
            }
        };
        /**
         *
         */
        GLTFAsset.createGLTFAsset = function () {
            var glftAsset = new GLTFAsset("");
            glftAsset.config = {
                asset: {
                    version: "2.0"
                },
                extensionsRequired: ["paper"],
                extensionsUsed: ["paper"],
            };
            return glftAsset;
        };
        /**
         * @internal
         */
        GLTFAsset.prototype.parse = function (config, buffers) {
            this.config = config;
            for (var _i = 0, buffers_1 = buffers; _i < buffers_1.length; _i++) {
                var buffer = buffers_1[_i];
                this.buffers.push(buffer);
            }
        };
        /**
         * 从二进制数据中解析资源。
         */
        GLTFAsset.prototype.parseFromBinary = function (array) {
            var index = 0;
            if (array[index++] !== 0x46546C67 ||
                array[index++] !== 2) {
                console.assert(false, "Nonsupport glTF data.");
                return;
            }
            if (array[index++] !== array.byteLength) {
                console.assert(false, "Error glTF data.");
                return;
            }
            var chunkLength = 0;
            var chunkType = 0;
            while (index < array.length) {
                chunkLength = array[index++];
                chunkType = array[index++];
                if (chunkLength % 4) {
                    console.assert(false, "Error glTF data.");
                }
                if (chunkType === 0x4E4F534A) {
                    var jsonArray = new Uint8Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint8Array.BYTES_PER_ELEMENT);
                    var jsonString = egret3d.io.BinReader.utf8ArrayToString(jsonArray);
                    this.config = JSON.parse(jsonString);
                }
                else if (chunkType === 0x004E4942) {
                    var buffer = new Uint32Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint32Array.BYTES_PER_ELEMENT);
                    this.buffers.push(buffer);
                }
                else {
                    console.assert(false, "Nonsupport glTF data.");
                    return;
                }
                index += chunkLength / 4;
            }
        };
        /**
         * 根据指定 BufferView 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromBufferView = function (bufferView, componentType) {
            var buffer = this.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0);
            // assert.config.buffers[bufferView.buffer];
            switch (componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int8Array.BYTES_PER_ELEMENT);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint8Array.BYTES_PER_ELEMENT);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int16Array.BYTES_PER_ELEMENT);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                case 5125 /* UnsignedInt */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int32Array.BYTES_PER_ELEMENT);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint32Array.BYTES_PER_ELEMENT);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Float32Array.BYTES_PER_ELEMENT);
            }
            throw new Error();
        };
        /**
         * 根据指定 Accessor 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromAccessor = function (accessor) {
            var bufferCount = GLTFAsset.getAccessorTypeCount(accessor.type) * accessor.count;
            var bufferView = this.getBufferView(accessor);
            var buffer = this.buffers[bufferView.buffer];
            // assert.config.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
            switch (accessor.componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5125 /* UnsignedInt */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferCount);
            }
            throw new Error();
        };
        /**
         * 通过 Accessor 获取指定 BufferLength。
         */
        GLTFAsset.prototype.getBufferLength = function (accessor) {
            return GLTFAsset.getAccessorTypeCount(accessor.type) * GLTFAsset.getComponentTypeCount(accessor.componentType) * accessor.count;
        };
        /**
         * 通过 Accessor 获取指定 BufferOffset。
         */
        GLTFAsset.prototype.getBufferOffset = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // const buffer = this.buffers[bufferView.buffer];
            return (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
        };
        /**
         * 通过 Accessor 获取指定 Buffer。
         */
        GLTFAsset.prototype.getBuffer = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // this.config.buffers[bufferView.buffer];
            return this.buffers[bufferView.buffer];
        };
        /**
         * 通过 Accessor 获取指定 BufferView。
         */
        GLTFAsset.prototype.getBufferView = function (accessor) {
            if (!this.config.bufferViews) {
                throw new Error();
            }
            return this.config.bufferViews[accessor.bufferView || 0];
        };
        /**
         * 通过 Accessor 索引，获取指定 Accessor。
         */
        GLTFAsset.prototype.getAccessor = function (index) {
            if (!this.config.accessors) {
                throw new Error();
            }
            return this.config.accessors[index];
        };
        /**
         * 获取节点。
         */
        GLTFAsset.prototype.getNode = function (index) {
            if (!this.config.nodes) {
                throw new Error();
            }
            return this.config.nodes[index];
        };
        /*
         * 获取动画剪辑。
         */
        GLTFAsset.prototype.getAnimationClip = function (name) {
            if (!this.config.animations ||
                this.config.animations.length === 0) {
                return null;
            }
            var animation = this.config.animations[0];
            if (animation.extensions.paper.clips.length === 0) {
                return null;
            }
            if (!name) {
                return animation.extensions.paper.clips[0];
            }
            for (var _i = 0, _a = this.config.animations; _i < _a.length; _i++) {
                var animation_1 = _a[_i];
                for (var _b = 0, _c = animation_1.extensions.paper.clips; _b < _c.length; _b++) {
                    var animationClip = _c[_b];
                    if (animationClip.name === name) {
                        return animationClip;
                    }
                }
            }
            return null;
        };
        GLTFAsset.prototype.caclByteLength = function () {
            return 0; // TODO
        };
        GLTFAsset.prototype.dispose = function () {
            this.buffers.length = 0;
        };
        return GLTFAsset;
    }(paper.Asset));
    egret3d.GLTFAsset = GLTFAsset;
    __reflect(GLTFAsset.prototype, "egret3d.GLTFAsset");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpVec3_3 = new egret3d.Vector3();
    var helpVec3_4 = new egret3d.Vector3();
    var helpVec3_5 = new egret3d.Vector3();
    var helpVec3_6 = new egret3d.Vector3();
    var helpVec3_7 = new egret3d.Vector3();
    // const helpVec3_8: Vector3 = new Vector3();
    /**
     * Mesh.
     * @version egret3D 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 网格模型。
     * @version egret3D 1.0
     * @platform Web
     * @language zh_CN
     */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        function Mesh() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.call(this) || this;
            /**
             * @internal
             */
            _this.vertexCount = 0;
            /**
             * true :所有subMesh公用一个buffer; false :每个subMesh使用单独的buffer
             * @internal
             */
            _this.isSharedBuffer = true;
            _this._drawMode = 1 /* Static */; // TODO
            /**
             * @internal
             */
            _this._version = 0;
            _this._glTFMeshIndex = 0;
            _this._glTFAsset = null;
            _this._glTFMesh = null;
            _this._vertexBuffer = null;
            /**
             * 暂时实现在这里，应实现到 gltf material。
             */
            _this._attributeType = {};
            /**
             * 暂时实现在这里，应该下放到 web，并将此方法抽象。
             */
            _this.ibos = [];
            _this.vbo = null;
            if (args.length === 0) {
                return _this;
            }
            if ((args[0] instanceof egret3d.GLTFAsset)) {
                _this._drawMode = args[2] || 1 /* Static */;
                _this._glTFMeshIndex = args[1];
                _this._glTFAsset = args[0];
            }
            else {
                var isSubIndexCountParameter = typeof args[2] === "number";
                var isAttributeTypeParameter = Array.isArray(args[4]);
                if (isAttributeTypeParameter) {
                    _this._drawMode = args[5] || 1 /* Static */;
                    _this._cacheMeshAttributeType(args[3], args[4]);
                }
                else {
                    _this._drawMode = (isSubIndexCountParameter ? args[4] : args[3]) || 1 /* Static */;
                }
                // Create gltf asset.
                _this._glTFAsset = egret3d.GLTFAsset.createGLTFAsset();
                _this._glTFAsset.config.buffers = [{ byteLength: 0 }];
                _this._glTFAsset.config.bufferViews = [{ buffer: 0, byteOffset: 0, byteLength: 0, target: 34962 /* ArrayBuffer */ }];
                _this._glTFAsset.config.accessors = [];
                _this._glTFMesh = { primitives: [{ attributes: { POSITION: 0 } }] };
                _this._glTFAsset.config.meshes = [_this._glTFMesh];
                //
                var attributeNames = (isSubIndexCountParameter ? args[3] : args[2]);
                var buffer = _this._glTFAsset.config.buffers[0];
                var vertexBufferView = _this._glTFAsset.config.bufferViews[0];
                var accessors = _this._glTFAsset.config.accessors;
                var primitive = _this._glTFMesh.primitives[0];
                var attributes = primitive.attributes;
                {
                    var isVertexCountParameter = typeof args[0] === "number";
                    var vertexBuffer = isVertexCountParameter ? null : args[0];
                    var count = isVertexCountParameter ? args[0] : _this._getVertexCountFromBuffer(vertexBuffer, attributeNames);
                    for (var _a = 0, attributeNames_1 = attributeNames; _a < attributeNames_1.length; _a++) {
                        var attributeName = attributeNames_1[_a];
                        // const type = GLTFAsset.getMeshAttributeType(attributeName);
                        var type = _this._getMeshAttributeType(attributeName);
                        var byteOffset = vertexBufferView.byteLength;
                        vertexBufferView.byteLength += count * egret3d.GLTFAsset.getAccessorTypeCount(type) * Float32Array.BYTES_PER_ELEMENT;
                        attributes[attributeName] = accessors.length;
                        accessors.push({
                            bufferView: 0,
                            byteOffset: byteOffset,
                            count: count,
                            componentType: 5126 /* Float */,
                            type: type,
                        });
                    }
                    buffer.byteLength = vertexBufferView.byteLength;
                    if (isVertexCountParameter) {
                        _this._glTFAsset.buffers[0] = new Float32Array(vertexBufferView.byteLength);
                    }
                    else {
                        _this._glTFAsset.buffers[0] = vertexBuffer;
                    }
                }
                if (args[1]) {
                    var isIndexCountParameter = typeof args[1] === "number";
                    var indexBuffer = isIndexCountParameter ? null : args[1];
                    var totalCount = isIndexCountParameter ? args[1] : indexBuffer.length;
                    var count = isSubIndexCountParameter ? args[2] : totalCount;
                    var indexBufferView = _this._glTFAsset.config.bufferViews[1] = {
                        buffer: 1,
                        byteOffset: 0,
                        byteLength: totalCount * egret3d.GLTFAsset.getAccessorTypeCount("SCALAR" /* SCALAR */) * Uint16Array.BYTES_PER_ELEMENT,
                        target: 34963 /* ElementArrayBuffer */,
                    };
                    primitive.indices = accessors.length;
                    accessors.push({
                        bufferView: 1, byteOffset: 0, count: count,
                        componentType: 5123 /* UnsignedShort */, type: "SCALAR" /* SCALAR */,
                    });
                    _this._glTFAsset.config.buffers[1] = { byteLength: indexBufferView.byteLength };
                    if (isIndexCountParameter) {
                        _this._glTFAsset.buffers[1] = new Uint16Array(indexBufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                    }
                    else {
                        _this._glTFAsset.buffers[1] = indexBuffer;
                    }
                }
            }
            _this.initialize();
            return _this;
        }
        Mesh.prototype._getDrawMode = function (mode) {
            var webgl = egret3d.WebGLKit.webgl;
            switch (mode) {
                case 1 /* Static */:
                    return webgl.STATIC_DRAW;
                case 2 /* Dynamic */:
                    return webgl.DYNAMIC_DRAW;
                case 3 /* Stream */:
                    return webgl.STREAM_DRAW;
            }
            throw new Error();
        };
        Mesh.prototype._cacheVertexCount = function () {
            var primitives = this._glTFMesh.primitives;
            var isSameAccessor = true;
            var firstPosAccessor = primitives[0].attributes.POSITION;
            for (var i = 1; i < primitives.length; i++) {
                var posAccessor = primitives[i].attributes.POSITION;
                if (posAccessor !== firstPosAccessor) {
                    isSameAccessor = false;
                    break;
                }
            }
            this.vertexCount = 0;
            //
            if (isSameAccessor) {
                this.vertexCount = this.getVertexCount();
            }
            else {
                for (var i = 0; i < primitives.length; i++) {
                    this.vertexCount += this.getVertexCount(i);
                }
            }
        };
        Mesh.prototype._cacheMeshAttributeType = function (attributeNames, attributeTypes) {
            //
            if (attributeNames.length !== attributeTypes.length) {
                throw "_cacheMeshAttributeType: attributeNames.length is not equal attributeType.length";
            }
            for (var i = 0, l = attributeNames.length; i < l; i++) {
                this._attributeType[attributeNames[i]] = attributeTypes[i];
            }
        };
        Mesh.prototype._getMeshAttributeType = function (attributeName) {
            if (attributeName in this._attributeType) {
                return this._attributeType[attributeName];
            }
            return egret3d.GLTFAsset.getMeshAttributeType(attributeName);
        };
        Mesh.prototype._getVertexCountFromBuffer = function (vertexBuffer, attributeNames) {
            var vertexPerCount = 0;
            for (var _i = 0, attributeNames_2 = attributeNames; _i < attributeNames_2.length; _i++) {
                var attributeName = attributeNames_2[_i];
                // vertexPerCount += GLTFAsset.getAccessorTypeCount(GLTFAsset.getMeshAttributeType(attributeName));
                vertexPerCount += egret3d.GLTFAsset.getAccessorTypeCount(this._getMeshAttributeType(attributeName));
            }
            return vertexBuffer.length / vertexPerCount;
        };
        Mesh.prototype.serialize = function () {
            if (!this._glTFAsset.url) {
                return null;
            }
            var target = paper.serializeC(this);
            target._glTFMeshIndex = this._glTFMeshIndex;
            target._glTFAsset = paper.serializeAsset(this._glTFAsset);
            return target;
        };
        Mesh.prototype.deserialize = function (element) {
            if (element._glTFAsset) {
                this._glTFMeshIndex = element._glTFMeshIndex;
                this._glTFAsset = paper.getDeserializedObject(element._glTFAsset);
            }
            else {
                var mesh = paper.getDeserializedObject(element);
                this._glTFMeshIndex = mesh._glTFMeshIndex;
                this._glTFAsset = mesh._glTFAsset;
            }
            this.initialize();
        };
        /**
         * @inheritDoc
         */
        Mesh.prototype.dispose = function () {
            var webgl = egret3d.WebGLKit.webgl;
            if (this.vbo) {
                webgl.deleteBuffer(this.vbo);
            }
            for (var _i = 0, _a = this.ibos; _i < _a.length; _i++) {
                var ibo = _a[_i];
                webgl.deleteBuffer(ibo);
            }
            this.ibos.length = 0;
            this.vbo = null;
            this._glTFAsset = null;
            this._glTFMesh = null;
            this._vertexBuffer = null;
        };
        /**
         * @inheritDoc
         */
        Mesh.prototype.caclByteLength = function () {
            return 0;
        };
        /**
         *
         */
        Mesh.prototype.initialize = function (drawMode) {
            if (this._vertexBuffer) {
                // console.warn("The mesh instance bas been initialized.");
                // return;
            }
            var config = this._glTFAsset.config;
            if (!config.buffers ||
                !config.bufferViews ||
                !config.accessors ||
                !config.meshes ||
                config.meshes.length <= this._glTFMeshIndex) {
                console.error("Error glTF asset.");
                return;
            }
            this._glTFMesh = config.meshes[this._glTFMeshIndex];
            if (drawMode) {
                this._drawMode = drawMode;
            }
            //
            var vertexBufferViewAccessor = this._glTFAsset.getAccessor(this._glTFMesh.primitives[0].attributes.POSITION);
            this._vertexBuffer = this._glTFAsset.createTypeArrayFromBufferView(this._glTFAsset.getBufferView(vertexBufferViewAccessor), 5126 /* Float */);
            this._cacheVertexCount();
            // 暂时实现在这里，应该下放到 web，并将此类抽象。
            var webgl = egret3d.WebGLKit.webgl;
            var vbo = webgl.createBuffer();
            if (vbo) {
                this.vbo = vbo;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, this._vertexBuffer.byteLength, this._getDrawMode(this._drawMode));
                var subMeshIndex = 0;
                for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                    var primitive = _a[_i];
                    var attributeNames = [];
                    for (var k in primitive.attributes) {
                        attributeNames.push(k);
                    }
                    this.uploadSubVertexBuffer(attributeNames, subMeshIndex);
                    if (primitive.indices !== undefined) {
                        var accessor = this._glTFAsset.getAccessor(primitive.indices);
                        var ibo = webgl.createBuffer();
                        if (ibo) {
                            this.ibos.push(ibo);
                            webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                            webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, this._glTFAsset.getBufferLength(accessor), this._getDrawMode(this._drawMode));
                            this.uploadSubIndexBuffer(subMeshIndex);
                        }
                        else {
                            this.ibos.push(null);
                            console.log("Create webgl element buffer error.");
                        }
                    }
                    else {
                        this.ibos.push(null);
                    }
                    subMeshIndex++;
                }
            }
            else {
                console.log("Create webgl buffer error.");
            }
        };
        /**
         * @internal
         */
        Mesh.prototype.addSubMesh = function (indexOffset, indexCount, materialIndex, sourceSubMeshIndex) {
            if (materialIndex === void 0) { materialIndex = 0; }
            if (sourceSubMeshIndex === void 0) { sourceSubMeshIndex = 0; }
            if (0 <= sourceSubMeshIndex && sourceSubMeshIndex < this._glTFMesh.primitives.length) {
                this._glTFAsset.config.accessors = this._glTFAsset.config.accessors || [];
                //
                var sourcePrimitive = this._glTFMesh.primitives[sourceSubMeshIndex];
                var sourceIndiceAccessor = this._glTFAsset.getAccessor(sourcePrimitive.indices || 0);
                var primitive = {
                    attributes: sourcePrimitive.attributes,
                    indices: this._glTFAsset.config.accessors.length,
                    material: materialIndex,
                };
                this._glTFMesh.primitives.push(primitive);
                this._glTFAsset.config.accessors.push({
                    bufferView: sourceIndiceAccessor.bufferView,
                    byteOffset: indexOffset * egret3d.GLTFAsset.getComponentTypeCount(5123 /* UnsignedShort */) * egret3d.GLTFAsset.getAccessorTypeCount("SCALAR" /* SCALAR */),
                    count: indexCount,
                    componentType: 5123 /* UnsignedShort */,
                    type: "SCALAR" /* SCALAR */,
                });
                var accessor = this._glTFAsset.getAccessor(primitive.indices);
                var webgl = egret3d.WebGLKit.webgl;
                var ibo = webgl.createBuffer();
                if (ibo) {
                    this.ibos.push(ibo);
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                    webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, this._glTFAsset.getBufferLength(accessor), this._getDrawMode(this._drawMode));
                }
                else {
                    this.ibos.push(null);
                    console.log("Create webgl element buffer error.");
                }
                return this._glTFMesh.primitives.length - 1;
            }
            console.warn("Error arguments.");
            return -1;
        };
        Mesh.prototype.getVertexCount = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var accessor = this._glTFAsset.getAccessor(this._glTFMesh.primitives[subMeshIndex].attributes.POSITION);
                return accessor.count;
            }
            console.warn("Error arguments.");
            return 0;
        };
        Mesh.prototype.getVertices = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            return this.getAttributes("POSITION" /* POSITION */, subMeshIndex);
        };
        Mesh.prototype.getUVs = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            return this.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */, subMeshIndex);
        };
        Mesh.prototype.getColors = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            return this.getAttributes("COLOR_0" /* COLOR_0 */, subMeshIndex);
        };
        Mesh.prototype.getNormals = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            return this.getAttributes("NORMAL" /* NORMAL */, subMeshIndex);
        };
        Mesh.prototype.getTangents = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            return this.getAttributes("TANGENT" /* TANGENT */, subMeshIndex);
        };
        Mesh.prototype.getAttributes = function (attributeType, subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var accessorIndex = this._glTFMesh.primitives[subMeshIndex].attributes[attributeType];
                if (accessorIndex === undefined) {
                    return null;
                }
                var accessor = this._glTFAsset.getAccessor(accessorIndex);
                return this._glTFAsset.createTypeArrayFromAccessor(accessor);
            }
            console.warn("Error arguments.");
            return null;
        };
        Mesh.prototype.getIndices = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var accessorIndex = this._glTFMesh.primitives[subMeshIndex].indices;
                if (accessorIndex === undefined) {
                    return null;
                }
                var accessor = this._glTFAsset.getAccessor(accessorIndex);
                return this._glTFAsset.createTypeArrayFromAccessor(accessor);
            }
            console.warn("Error arguments.");
            return null;
        };
        Mesh.prototype.getAttribute = function (vertexIndex, attributeType, subMeshIndex, result) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var attributeIndex = this._glTFMesh.primitives[subMeshIndex].attributes[attributeType];
                if (attributeIndex !== undefined) {
                    var accessor = this._glTFAsset.getAccessor(attributeIndex);
                    if (0 <= vertexIndex && vertexIndex < accessor.count) {
                        // const bufferOffset = this._glTFAsset.getBufferOffset(accessor);
                        // const typeCount= GLTFAsset.getComponentTypeCount(accessor.componentType);
                        // const offset = bufferOffset / typeCount + vertexIndex * typeCount;
                        var typeCount = egret3d.GLTFAsset.getAccessorTypeCount(accessor.type);
                        var offset = vertexIndex * typeCount;
                        var buffers = this._glTFAsset.createTypeArrayFromAccessor(accessor);
                        switch (accessor.type) {
                            case "VEC2" /* VEC2 */: {
                                if (!result) {
                                    result = new egret3d.Vector2();
                                }
                                result.x = buffers[offset];
                                result.y = buffers[offset + 1];
                                break;
                            }
                            case "VEC3" /* VEC3 */: {
                                if (!result) {
                                    result = new egret3d.Vector3();
                                }
                                result.x = buffers[offset];
                                result.y = buffers[offset + 1];
                                result.z = buffers[offset + 2];
                                break;
                            }
                            case "VEC4" /* VEC4 */: {
                                if (!result) {
                                    result = new egret3d.Vector4();
                                }
                                result.x = buffers[offset];
                                result.y = buffers[offset + 1];
                                result.z = buffers[offset + 2];
                                result.w = buffers[offset + 3];
                                break;
                            }
                        }
                        return result;
                    }
                }
            }
            console.warn("Error arguments.");
            return result;
        };
        Mesh.prototype.uploadVertexSubData = function (uploadAttributes, startVertexIndex, vertexCount, subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var webgl = egret3d.WebGLKit.webgl;
                var primitive = this._glTFMesh.primitives[subMeshIndex];
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                var attributes = primitive.attributes;
                for (var _i = 0, uploadAttributes_1 = uploadAttributes; _i < uploadAttributes_1.length; _i++) {
                    var attributeName = uploadAttributes_1[_i];
                    var accessorIndex = attributes[attributeName];
                    if (accessorIndex !== undefined) {
                        var accessor = this._glTFAsset.getAccessor(accessorIndex);
                        var compType = egret3d.GLTFAsset.getComponentTypeCount(accessor.componentType);
                        var typeCount = egret3d.GLTFAsset.getAccessorTypeCount(accessor.type);
                        var startOffset = this._glTFAsset.getBufferOffset(accessor);
                        var bufferOffset = startOffset + startVertexIndex * typeCount * compType;
                        var subVertexBuffer = this._glTFAsset.createTypeArrayFromAccessor(accessor);
                        var letray = new Float32Array(subVertexBuffer.buffer, bufferOffset, typeCount * vertexCount);
                        webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, letray);
                    }
                    else {
                        console.warn("Error arguments.");
                    }
                }
                this._version++;
            }
            else {
                console.warn("Error arguments.");
            }
        };
        /**
         * 暂时实现在这里，应该下放到 web，并将此方法抽象。
         */
        Mesh.prototype.uploadSubVertexBuffer = function (uploadAttributes, subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var webgl = egret3d.WebGLKit.webgl;
                var primitive = this._glTFMesh.primitives[subMeshIndex];
                var attributes = primitive.attributes;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                if (typeof uploadAttributes === "string") {
                    var accessorIndex = attributes[uploadAttributes];
                    if (accessorIndex !== undefined) {
                        var accessor = this._glTFAsset.getAccessor(accessorIndex);
                        var bufferOffset = this._glTFAsset.getBufferOffset(accessor);
                        var subVertexBuffer = this._glTFAsset.createTypeArrayFromAccessor(accessor);
                        webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, subVertexBuffer);
                    }
                    else {
                        console.warn("Error arguments.");
                    }
                }
                else {
                    for (var _i = 0, uploadAttributes_2 = uploadAttributes; _i < uploadAttributes_2.length; _i++) {
                        var attributeName = uploadAttributes_2[_i];
                        var accessorIndex = attributes[attributeName];
                        if (accessorIndex !== undefined) {
                            var accessor = this._glTFAsset.getAccessor(accessorIndex);
                            var bufferOffset = this._glTFAsset.getBufferOffset(accessor);
                            var subVertexBuffer = this._glTFAsset.createTypeArrayFromAccessor(accessor);
                            webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, subVertexBuffer);
                        }
                        else {
                            console.warn("Error arguments.");
                        }
                    }
                }
                this._version++;
            }
            else {
                console.warn("Error arguments.");
            }
        };
        /**
         * 暂时实现在这里，应该下放到 web，并将此方法抽象。
         */
        Mesh.prototype.uploadSubIndexBuffer = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var webgl = egret3d.WebGLKit.webgl;
                var primitive = this._glTFMesh.primitives[subMeshIndex];
                if (primitive.indices !== undefined) {
                    var accessor = this._glTFAsset.getAccessor(primitive.indices);
                    // const bufferOffset = this._glTFAsset.getBufferOffset(accessor);
                    var subIndexBuffer = this._glTFAsset.createTypeArrayFromAccessor(accessor);
                    var ibo = this.ibos[subMeshIndex];
                    if (ibo) {
                        webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                        //ibo每个单独上传，偏移一直是0
                        webgl.bufferSubData(webgl.ELEMENT_ARRAY_BUFFER, 0, subIndexBuffer);
                        this._version++;
                    }
                    else {
                        console.error("Error webgl element buffer.");
                    }
                }
                else {
                    console.warn("Error arguments.");
                }
            }
            else {
                console.warn("Error arguments.");
            }
        };
        /**
         * 检测射线碰撞
         * @param ray 射线
         * @param matrix 所在transform的矩阵
         *
         */
        Mesh.prototype.intersects = function (ray, matrix) {
            var pickInfo = null; // TODO
            var subMeshIndex = 0;
            for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                if (primitive.mode === 1 /* Lines */ ||
                    primitive.mode === 2 /* LineLoop */ ||
                    primitive.mode === 3 /* LineStrip */) {
                }
                else {
                    if (primitive.indices === undefined) {
                        // 不使用index TODO
                    }
                    else {
                        var indices = this.getIndices(subMeshIndex);
                        if (indices) {
                            var t0 = helpVec3_1;
                            var t1 = helpVec3_2;
                            var t2 = helpVec3_3;
                            var vertices = this.getVertices(subMeshIndex);
                            for (var i = 0; i < indices.length; i += 3) {
                                var p0 = helpVec3_4;
                                var p1 = helpVec3_5;
                                var p2 = helpVec3_6;
                                var index = indices[i] * 3;
                                egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p0);
                                index = indices[i + 1] * 3;
                                egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p1);
                                index = indices[i + 2] * 3;
                                egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p2);
                                egret3d.Matrix.transformVector3(p0, matrix, t0);
                                egret3d.Matrix.transformVector3(p1, matrix, t1);
                                egret3d.Matrix.transformVector3(p2, matrix, t2);
                                var result = ray.intersectsTriangle(t0, t1, t2);
                                if (result) {
                                    if (result.distance < 0) {
                                        continue;
                                    }
                                    if (!pickInfo || pickInfo.distance > result.distance) {
                                        pickInfo = result;
                                        pickInfo.triangleIndex = i / 3;
                                        pickInfo.subMeshIndex = i;
                                        var tdir = helpVec3_7;
                                        egret3d.Vector3.copy(ray.direction, tdir);
                                        egret3d.Vector3.scale(tdir, result.distance);
                                        egret3d.Vector3.add(ray.origin, tdir, pickInfo.position);
                                    }
                                }
                            }
                        }
                    }
                }
                subMeshIndex++;
            }
            return pickInfo;
        };
        Object.defineProperty(Mesh.prototype, "subMeshCount", {
            /**
             * 获取子网格数量。
             */
            get: function () {
                return this._glTFMesh.primitives.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "glTFAsset", {
            /**
             * 获取 mesh 数据所属的 glTF 资源。
             */
            get: function () {
                return this._glTFAsset;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "glTFMesh", {
            /**
             * 获取 glTFMesh 数据。
             */
            get: function () {
                return this._glTFMesh;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Mesh.prototype.setAttribute = function (vertexIndex, attributeType, subMeshIndex) {
            var args = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                args[_i - 3] = arguments[_i];
            }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var attributeIndex = this._glTFMesh.primitives[subMeshIndex].attributes[attributeType];
                if (attributeIndex !== undefined) {
                    var accessor = this._glTFAsset.getAccessor(attributeIndex);
                    if (0 <= vertexIndex && vertexIndex < accessor.count) {
                        var offset = this._glTFAsset.getBufferOffset(accessor) / egret3d.GLTFAsset.getComponentTypeCount(accessor.componentType) + vertexIndex * egret3d.GLTFAsset.getAccessorTypeCount(accessor.type);
                        switch (accessor.type) {
                            case "SCALAR" /* SCALAR */: {
                                this._vertexBuffer[offset] = args[0];
                                break;
                            }
                            case "VEC2" /* VEC2 */: {
                                this._vertexBuffer[offset] = args[0];
                                this._vertexBuffer[offset + 1] = args[1];
                                break;
                            }
                            case "VEC3" /* VEC3 */: {
                                this._vertexBuffer[offset] = args[0];
                                this._vertexBuffer[offset + 1] = args[1];
                                this._vertexBuffer[offset + 2] = args[2];
                                break;
                            }
                            case "VEC4" /* VEC4 */: {
                                this._vertexBuffer[offset] = args[0];
                                this._vertexBuffer[offset + 1] = args[1];
                                this._vertexBuffer[offset + 2] = args[2];
                                this._vertexBuffer[offset + 3] = args[3];
                                break;
                            }
                        }
                    }
                }
            }
            else {
                console.warn("Error arguments.");
            }
        };
        __decorate([
            paper.serializedField
        ], Mesh.prototype, "_drawMode", void 0);
        __decorate([
            paper.serializedField
        ], Mesh.prototype, "_glTFMeshIndex", void 0);
        __decorate([
            paper.serializedField
        ], Mesh.prototype, "_glTFAsset", void 0);
        return Mesh;
    }(paper.SerializableObject));
    egret3d.Mesh = Mesh;
    __reflect(Mesh.prototype, "egret3d.Mesh");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var MissingObject = (function () {
        function MissingObject() {
        }
        MissingObject.prototype.serialize = function () {
            return this;
        };
        MissingObject.prototype.deserialize = function (element) {
            for (var k in element) {
                this[k] = element[k];
            }
        };
        return MissingObject;
    }());
    paper.MissingObject = MissingObject;
    __reflect(MissingObject.prototype, "paper.MissingObject", ["paper.ISerializable"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var helpVec3 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpMat4 = new egret3d.Matrix();
    var helpQuat4 = new egret3d.Quaternion();
    var helpQuat4_2 = new egret3d.Quaternion();
    var helpVector = new egret3d.Vector3();
    var helpRotation = new egret3d.Quaternion();
    var helpUp = new egret3d.Vector3(0, 1, 0);
    var helpRight = new egret3d.Vector3(1, 0, 0);
    var helpFoward = new egret3d.Vector3(0, 0, 1);
    /**
     * Transform Class
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * Transform实例可以被添加到3D场景中，并持有一个GameObejct实例
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Transform = (function (_super) {
        __extends(Transform, _super);
        function Transform() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._dirtyAABB = true;
            _this._dirtyLocal = true;
            _this._dirtyWorld = true;
            /**
             * 世界矩阵的行列式，如果小于0，说明进行了反转
             * @internal
             */
            _this._worldMatrixDeterminant = 0.0;
            _this.localMatrix = new egret3d.Matrix();
            _this.worldMatrix = new egret3d.Matrix();
            _this.localPosition = new egret3d.Vector3();
            _this.position = new egret3d.Vector3();
            _this.localRotation = new egret3d.Quaternion();
            _this.rotation = new egret3d.Quaternion();
            _this.localEulerAngles = new egret3d.Vector3();
            _this.eulerAngles = new egret3d.Vector3();
            _this.localScale = new egret3d.Vector3(1.0, 1.0, 1.0);
            _this.scale = new egret3d.Vector3(1.0, 1.0, 1.0);
            /**
             * @internal
             */
            _this._children = [];
            _this._aabb = null;
            _this._parent = null;
            return _this;
        }
        Transform_1 = Transform;
        Transform.prototype._removeFromChildren = function (value) {
            var index = 0;
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child === value) {
                    this._children.splice(index, 1);
                    break;
                }
                index++;
            }
        };
        Transform.prototype._buildAABB = function () {
            var vertexPosition = new egret3d.Vector3();
            var minimum = new egret3d.Vector3();
            var maximum = new egret3d.Vector3();
            var filter = this.gameObject.getComponent(egret3d.MeshFilter);
            if (filter && filter.mesh) {
                egret3d.Vector3.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                egret3d.Vector3.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                var subMeshIndex = 0;
                for (var _i = 0, _a = filter.mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                    var _primitive = _a[_i];
                    var vertices = filter.mesh.getVertices(subMeshIndex);
                    for (var i = 0, l = vertices.length; i < l; i += 3) {
                        egret3d.Vector3.set(vertices[i], vertices[i + 1], vertices[i + 2], vertexPosition);
                        egret3d.Vector3.max(vertexPosition, maximum, maximum);
                        egret3d.Vector3.min(vertexPosition, minimum, minimum);
                    }
                    subMeshIndex++;
                }
            }
            else {
                var skinmesh = this.gameObject.getComponent(egret3d.SkinnedMeshRenderer);
                if (skinmesh && skinmesh.mesh) {
                    egret3d.Vector3.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                    egret3d.Vector3.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                    var subMeshIndex = 0;
                    for (var _b = 0, _c = skinmesh.mesh.glTFMesh.primitives; _b < _c.length; _b++) {
                        var _primitive = _c[_b];
                        var vertices = skinmesh.mesh.getVertices(subMeshIndex);
                        for (var i = 0, l = vertices.length; i < l; i += 3) {
                            egret3d.Vector3.set(vertices[i], vertices[i + 1], vertices[i + 2], vertexPosition);
                            egret3d.Vector3.max(vertexPosition, maximum, maximum);
                            egret3d.Vector3.min(vertexPosition, minimum, minimum);
                        }
                        subMeshIndex++;
                    }
                }
                else {
                    minimum.x = -1;
                    minimum.y = -1;
                    minimum.z = -1;
                    maximum.x = 1;
                    maximum.y = 1;
                    maximum.z = 1;
                }
            }
            var aabb = new egret3d.AABB(minimum, maximum);
            return aabb;
        };
        Transform.prototype._sync = function () {
            if (this._dirtyLocal) {
                egret3d.Matrix.fromRTS(this.localPosition, this.localScale, this.localRotation, this.localMatrix);
                this._dirtyLocal = false;
            }
            if (this._dirtyWorld) {
                if (!this._parent) {
                    egret3d.Matrix.copy(this.localMatrix, this.worldMatrix);
                }
                else {
                    egret3d.Matrix.multiply(this._parent.worldMatrix, this.localMatrix, this.worldMatrix);
                }
                this._worldMatrixDeterminant = egret3d.Matrix.determinant(this.worldMatrix);
                this._dirtyWorld = false;
            }
        };
        Transform.prototype._dirtify = function (local) {
            if (local === void 0) { local = false; }
            if ((!local || (local && this._dirtyLocal)) && this._dirtyWorld) {
                return;
            }
            if (local) {
                this._dirtyLocal = true;
            }
            if (!this._dirtyWorld) {
                this._dirtyWorld = true;
                var i = this._children.length;
                while (i--) {
                    if (this._children[i]._dirtyWorld) {
                        continue;
                    }
                    this._children[i]._dirtify();
                }
            }
            // transform dirty
            this._dirtyAABB = true;
        };
        /**
         * 父节点发生改变的回调方法
         * 子类可通过重载此方法进行标脏状态传递
         */
        Transform.prototype._onParentChange = function (newParent, oldParent) {
            var prevActive = oldParent ? oldParent.gameObject.activeInHierarchy : this.gameObject.activeSelf;
            if ((newParent ? newParent.gameObject.activeInHierarchy : this.gameObject.activeSelf) !== prevActive) {
                this.gameObject._activeInHierarchyDirty(prevActive);
            }
            this._dirtify();
        };
        Transform.prototype._getAllChildren = function (children) {
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                children.push(child);
                child._getAllChildren(children);
            }
        };
        /**
         * @internal
         */
        Transform.prototype.getAllChildren = function () {
            var children = [];
            this._getAllChildren(children);
            return children;
        };
        Transform.prototype.deserialize = function (element) {
            _super.prototype.deserialize.call(this, element); // TODO
            this.localPosition.deserialize(element.localPosition);
            this.localRotation.deserialize(element.localRotation);
            this.localScale.deserialize(element.localScale);
            this._children.length = 0;
            if (element.children) {
                for (var i = 0, l = element.children.length; i < l; i++) {
                    var child = paper.getDeserializedObject(element.children[i]);
                    if (child) {
                        child._parent = this;
                        this._children.push(child);
                    }
                }
            }
        };
        /**
         * 设置父节点
         */
        Transform.prototype.setParent = function (newParent, worldPositionStays) {
            if (worldPositionStays === void 0) { worldPositionStays = false; }
            var oldParent = this._parent;
            if (oldParent === newParent) {
                return;
            }
            if (worldPositionStays) {
                egret3d.Vector3.copy(this.getPosition(), egret3d.helpVector3A);
            }
            if (oldParent) {
                oldParent._removeFromChildren(this);
            }
            if (newParent) {
                newParent._children.push(this);
            }
            this._parent = newParent;
            this._onParentChange(newParent, oldParent);
            if (worldPositionStays) {
                this.setPosition(egret3d.helpVector3A);
            }
        };
        Transform.prototype.getChildIndex = function (value) {
            if (value.parent !== this) {
                return -1;
            }
            return this._children.indexOf(value);
        };
        Transform.prototype.setChildIndex = function (value, index) {
            if (value.parent !== this) {
                return;
            }
            var prevIndex = this._children.indexOf(value);
            if (prevIndex === index) {
                return;
            }
            this._children.splice(prevIndex, 1);
            this._children.splice(index, 0, value);
        };
        /**
         * 获取对象下标的子集对象
         * @param index
         */
        Transform.prototype.getChildAt = function (index) {
            return 0 <= index && index < this._children.length ? this._children[index] : null;
        };
        /**
         * get local matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得本地矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalMatrix = function () {
            if (this._dirtyLocal) {
                egret3d.Matrix.fromRTS(this.localPosition, this.localScale, this.localRotation, this.localMatrix);
                this._dirtyLocal = false;
            }
            return this.localMatrix;
        };
        /**
         * get world matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得世界矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getWorldMatrix = function () {
            if (!this._dirtyLocal && !this._dirtyWorld) {
                return this.worldMatrix;
            }
            if (this._parent) {
                this._parent.getWorldMatrix();
            }
            this._sync();
            return this.worldMatrix;
        };
        /**
         * get local position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得本地位置
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalPosition = function () {
            return this.localPosition;
        };
        Transform.prototype.setLocalPosition = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                egret3d.Vector3.copy(p1, this.localPosition);
            }
            else {
                this.localPosition.x = p1;
                this.localPosition.y = p2 || 0;
                this.localPosition.z = p3 || 0;
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得位置
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getPosition = function () {
            egret3d.Matrix.getTranslation(this.getWorldMatrix(), this.position);
            return this.position;
        };
        Transform.prototype.setPosition = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                egret3d.Vector3.copy(p1, helpVec3);
            }
            else {
                helpVec3.x = p1;
                helpVec3.y = p2 || 0;
                helpVec3.z = p3 || 0;
            }
            if (!this._parent) {
                egret3d.Vector3.copy(helpVec3, this.localPosition);
            }
            else {
                egret3d.Matrix.inverse(this._parent.getWorldMatrix(), helpMat4);
                egret3d.Matrix.transformVector3(helpVec3, helpMat4, this.localPosition); // transform point
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get local rotation
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取本地旋转
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalRotation = function () {
            return this.localRotation;
        };
        Transform.prototype.setLocalRotation = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this.localRotation.copy(p1);
            }
            else {
                this.localRotation.x = p1;
                this.localRotation.y = p2 || 0;
                this.localRotation.z = p3 || 0;
                this.localRotation.w = p4 !== undefined ? p4 : 1;
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get rotation
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得旋转
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getRotation = function () {
            egret3d.Quaternion.fromMatrix(this.getWorldMatrix(), this.rotation);
            return this.rotation;
        };
        Transform.prototype.setRotation = function (q1, q2, q3, q4) {
            if (q1.hasOwnProperty("x")) {
                egret3d.Quaternion.copy(q1, helpQuat4);
            }
            else {
                helpQuat4.x = q1;
                helpQuat4.y = q2 || 0;
                helpQuat4.z = q3 || 0;
                helpQuat4.w = q4 !== undefined ? q4 : 1;
            }
            if (!this._parent) {
                egret3d.Quaternion.copy(helpQuat4, this.localRotation);
            }
            else {
                var parentRot = this._parent.getRotation();
                egret3d.Quaternion.copy(parentRot, helpQuat4_2);
                egret3d.Quaternion.multiply(helpQuat4_2.inverse(), helpQuat4, this.localRotation);
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get local euler angles
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取本地欧拉角
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalEulerAngles = function () {
            egret3d.Quaternion.toEulerAngles(this.localRotation, this.localEulerAngles);
            return this.localEulerAngles;
        };
        Transform.prototype.setLocalEulerAngles = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                p1 = p1;
                egret3d.Quaternion.fromEulerAngles(p1.x, p1.y, p1.z, this.localRotation);
            }
            else {
                egret3d.Quaternion.fromEulerAngles(p1, p2, p3, this.localRotation);
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get euler angles
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取欧拉角
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getEulerAngles = function () {
            egret3d.Matrix.toEulerAngles(this.getWorldMatrix(), this.eulerAngles);
            return this.eulerAngles;
        };
        Transform.prototype.setEulerAngles = function (q1, q2, q3) {
            if (q1.hasOwnProperty("x")) {
                q1 = q1;
                egret3d.Quaternion.fromEulerAngles(q1.x, q1.y, q1.z, helpQuat4);
            }
            else {
                egret3d.Quaternion.fromEulerAngles(q1, q2 || 0, q3 || 0, helpQuat4);
            }
            if (!this._parent) {
                egret3d.Quaternion.copy(helpQuat4, this.localRotation);
            }
            else {
                var parentRot = this._parent.getRotation();
                egret3d.Quaternion.copy(parentRot, helpQuat4_2);
                egret3d.Quaternion.multiply(helpQuat4_2.inverse(), helpQuat4, this.localRotation);
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get local scale
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得本地缩放
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalScale = function () {
            return this.localScale;
        };
        Transform.prototype.setLocalScale = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                egret3d.Vector3.copy(p1, this.localScale);
            }
            else {
                this.localScale.x = p1;
                this.localScale.y = p2 !== undefined ? p2 : 1;
                this.localScale.z = p3 !== undefined ? p3 : 1;
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get scale
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得缩放
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getScale = function () {
            egret3d.Matrix.getScale(this.getWorldMatrix(), this.scale);
            return this.scale;
        };
        Transform.prototype.setScale = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                egret3d.Vector3.copy(p1, helpVec3);
            }
            else {
                helpVec3.x = p1;
                helpVec3.y = p2 !== undefined ? p2 : 1;
                helpVec3.z = p3 !== undefined ? p3 : 1;
            }
            if (!this._parent) {
                egret3d.Vector3.copy(helpVec3, this.localScale);
            }
            else {
                egret3d.Matrix.inverse(this._parent.getWorldMatrix(), helpMat4);
                egret3d.Matrix.transformVector3(helpVec3, helpMat4, this.localScale); // transform vector3
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * look at a target
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 旋转当前transform 到指定的目标
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.lookAt = function (target, up) {
            if (target instanceof Transform_1) {
                egret3d.Vector3.copy(target.getPosition(), helpVector);
            }
            else {
                egret3d.Vector3.copy(target, helpVector);
            }
            if (up === undefined) {
                egret3d.Quaternion.lookAt(this.getPosition(), helpVector, helpRotation);
            }
            else {
                egret3d.Quaternion.lookAtWithUp(this.getPosition(), helpVector, up, helpRotation);
            }
            this.setRotation(helpRotation);
        };
        /**
         * z-axis towards in world space
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取世界坐标系下当前z轴的朝向
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getForward = function (out) {
            egret3d.Matrix.transformNormal(helpFoward, this.getWorldMatrix(), out);
            egret3d.Vector3.normalize(out);
            return out;
        };
        /**
         * x-axis towards in world space
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取世界坐标系下当前x轴的朝向
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getRight = function (out) {
            egret3d.Matrix.transformNormal(helpRight, this.getWorldMatrix(), out);
            egret3d.Vector3.normalize(out);
        };
        /**
         * y-axis towards in world space
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取世界坐标系下当前y轴的朝向
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getUp = function (out) {
            egret3d.Matrix.transformNormal(helpUp, this.getWorldMatrix(), out);
            egret3d.Vector3.normalize(out);
        };
        /**
         * Finds a child by name or path and returns it.
         * @param nameOrPath
         */
        Transform.prototype.find = function (nameOrPath) {
            var names = nameOrPath.split("/");
            var ancestor = this;
            var result = null;
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name_1 = names_1[_i];
                for (var _a = 0, _b = ancestor._children; _a < _b.length; _a++) {
                    var child = _b[_a];
                    if (child.gameObject.name === name_1) {
                        result = child;
                        break;
                    }
                }
                if (result) {
                    ancestor = result;
                }
                else {
                    break;
                }
            }
            return result;
        };
        Object.defineProperty(Transform.prototype, "childCount", {
            /**
             * 当前子集对象的数量
             */
            get: function () {
                return this._children.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "aabb", {
            /**
             *
             */
            get: function () {
                if (!this._aabb) {
                    this._aabb = this._buildAABB();
                }
                if (this._dirtyAABB) {
                    this._aabb.update(this.getWorldMatrix());
                    this._dirtyAABB = false;
                }
                return this._aabb;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "children", {
            /**
             * children list
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 子物体列表
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                return this._children;
            },
            /**
             * 仅用于反序列化。
             * @internal
             */
            set: function (value) {
                this._children.length = 0;
                for (var _i = 0, value_3 = value; _i < value_3.length; _i++) {
                    var component = value_3[_i];
                    this._children.push(component);
                }
            },
            enumerable: true,
            configurable: true
        });
        ;
        ;
        Object.defineProperty(Transform.prototype, "parent", {
            /**
             * instance of parent transform
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 父元素实例
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                return this._parent;
            },
            set: function (value) {
                this.setParent(value, false);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.VECTOR3, { set: "setLocalPosition" })
        ], Transform.prototype, "localPosition", void 0);
        __decorate([
            paper.editor.extraProperty(paper.editor.EditType.VECTOR3, { set: "setPosition" })
        ], Transform.prototype, "position", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.QUATERNION, { set: "setLocalRotation" })
        ], Transform.prototype, "localRotation", void 0);
        __decorate([
            paper.editor.extraProperty(paper.editor.EditType.QUATERNION, { set: "setRotation" })
        ], Transform.prototype, "rotation", void 0);
        __decorate([
            paper.editor.extraProperty(paper.editor.EditType.VECTOR3, { set: "setLocalEulerAngles" })
        ], Transform.prototype, "localEulerAngles", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.VECTOR3, { set: "setLocalScale" })
        ], Transform.prototype, "localScale", void 0);
        __decorate([
            paper.editor.extraProperty(paper.editor.EditType.VECTOR3, { set: "setScale" })
        ], Transform.prototype, "scale", void 0);
        __decorate([
            paper.serializedField
        ], Transform.prototype, "children", null);
        Transform = Transform_1 = __decorate([
            paper.disallowMultipleComponent
        ], Transform);
        return Transform;
        var Transform_1;
    }(paper.BaseComponent));
    egret3d.Transform = Transform;
    __reflect(Transform.prototype, "egret3d.Transform");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 克隆
     */
    function clone(object) {
        var cacheParent = null;
        // TODO 太多的字符串依赖。
        // 将parent设置为空，避免向上引用 // TODO 这并不能根本解决问题，自定义组件依然可能会引用这些，导致错误的序列化和反序列化
        if (object instanceof paper.GameObject) {
            cacheParent = object.transform.parent;
            object.transform._parent = null; // TODO
        }
        else if (object instanceof egret3d.Transform) {
            cacheParent = object.parent;
            object._parent = null; // TODO
        }
        var data = paper.serialize(object);
        if (object instanceof paper.GameObject) {
            object.transform._parent = cacheParent; // TODO
        }
        else if (object instanceof egret3d.Transform) {
            object._parent = cacheParent; // TODO
        }
        var assets = {};
        if ("assets" in data) {
            for (var _i = 0, _a = data["assets"]; _i < _a.length; _i++) {
                var asset = _a[_i];
                assets[asset.uuid] = paper.Asset.find(asset.url); // 获取资源引用
            }
        }
        return paper.deserialize(data, assets, true);
    }
    paper.clone = clone;
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var helpRectA = new egret3d.Rectangle();
    /**
     * camera component
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 相机组件
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var Camera = (function (_super) {
        __extends(Camera, _super);
        function Camera() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * clear color option
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 是否清除颜色缓冲区
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.clearOption_Color = true;
            /**
             * clear depth option
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 是否清除深度缓冲区
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.clearOption_Depth = true;
            /**
             * culling mask
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 相机的渲染剔除，对应GameObject的层级
             * @default CullingMask.Everything
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.cullingMask = 16777215 /* Everything */;
            /**
             * camera render order
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 相机渲染排序
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.order = 0;
            /**
             * fov
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 透视投影的fov
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.fov = Math.PI * 0.25;
            /**
             * size
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 正交投影的竖向size
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.size = 2.0;
            /**
             * op value
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 0=正交， 1=透视 中间值可以在两种相机间过度
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.opvalue = 1.0;
            /**
             * back ground color
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 背景色
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.backgroundColor = new egret3d.Color(0.13, 0.28, 0.51, 1); // TODO 
            /**
             * camera viewport
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 相机视窗
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.viewport = new egret3d.Rectangle(0, 0, 1, 1);
            /**
             * TODO 功能完善后开放此接口
             */
            _this.postQueues = [];
            /**
             * 相机渲染上下文
             */
            _this.context = null;
            /**
             * render target
             * @defualt null
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 渲染目标，如果为null，则为画布
             * @defualt null
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.renderTarget = null;
            _this._near = 0.01;
            _this._far = 1000;
            _this.matProjP = new egret3d.Matrix;
            _this.matProjO = new egret3d.Matrix;
            _this.frameVecs = [
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3()
            ];
            return _this;
        }
        Object.defineProperty(Camera, "main", {
            /**
             * current main camera
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前主相机。
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                var entity = paper.GameObject.findWithTag("MainCamera");
                if (entity) {
                    return entity.getComponent(Camera, true);
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 计算相机视锥区域
         */
        Camera.prototype.calcCameraFrame = function () {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var farLD = this.frameVecs[0];
            var nearLD = this.frameVecs[1];
            var farRD = this.frameVecs[2];
            var nearRD = this.frameVecs[3];
            var farLT = this.frameVecs[4];
            var nearLT = this.frameVecs[5];
            var farRT = this.frameVecs[6];
            var nearRT = this.frameVecs[7];
            var near_h = this.near * Math.tan(this.fov * 0.5);
            var asp = vpp.w / vpp.h;
            var near_w = near_h * asp;
            egret3d.Vector3.set(-near_w, near_h, this.near, nearLT);
            egret3d.Vector3.set(-near_w, -near_h, this.near, nearLD);
            egret3d.Vector3.set(near_w, near_h, this.near, nearRT);
            egret3d.Vector3.set(near_w, -near_h, this.near, nearRD);
            var far_h = this.far * Math.tan(this.fov * 0.5);
            var far_w = far_h * asp;
            egret3d.Vector3.set(-far_w, far_h, this.far, farLT);
            egret3d.Vector3.set(-far_w, -far_h, this.far, farLD);
            egret3d.Vector3.set(far_w, far_h, this.far, farRT);
            egret3d.Vector3.set(far_w, -far_h, this.far, farRD);
            var matrix = this.gameObject.transform.getWorldMatrix();
            egret3d.Matrix.transformVector3(farLD, matrix, farLD);
            egret3d.Matrix.transformVector3(nearLD, matrix, nearLD);
            egret3d.Matrix.transformVector3(farRD, matrix, farRD);
            egret3d.Matrix.transformVector3(nearRD, matrix, nearRD);
            egret3d.Matrix.transformVector3(farLT, matrix, farLT);
            egret3d.Matrix.transformVector3(nearLT, matrix, nearLT);
            egret3d.Matrix.transformVector3(farRT, matrix, farRT);
            egret3d.Matrix.transformVector3(nearRT, matrix, nearRT);
        };
        /**
         * 设置render target与viewport
         * @param target render target
         * @param withoutClear 强制不清除缓存
         *
         */
        Camera.prototype._targetAndViewport = function (target, withoutClear) {
            var w;
            var h;
            var webgl = egret3d.WebGLKit.webgl;
            if (!target) {
                w = egret3d.stage.screenViewport.w;
                h = egret3d.stage.screenViewport.h;
                egret3d.GlRenderTarget.useNull(webgl);
            }
            else {
                w = target.width;
                h = target.height;
                target.use(webgl);
            }
            webgl.viewport(w * this.viewport.x, h * this.viewport.y, w * this.viewport.w, h * this.viewport.h);
            webgl.depthRange(0, 1);
            if (withoutClear) {
                return;
            }
            // clear buffer
            if (this.clearOption_Color && this.clearOption_Depth) {
                egret3d.WebGLKit.zWrite(true);
                // webgl.depthMask(true);
                webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                webgl.clearDepth(1.0);
                webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
            }
            else if (this.clearOption_Depth) {
                egret3d.WebGLKit.zWrite(true);
                // webgl.depthMask(true);
                webgl.clearDepth(1.0);
                webgl.clear(webgl.DEPTH_BUFFER_BIT);
            }
            else if (this.clearOption_Color) {
                webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                webgl.clear(webgl.COLOR_BUFFER_BIT);
            }
            else {
            }
        };
        /**
         * @inheritDoc
         */
        Camera.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.context = new egret3d.RenderContext();
            this.near = this._near;
            this.far = this._far;
        };
        /**
         *
         */
        Camera.prototype.update = function (_delta) {
            this.calcCameraFrame();
            this.context.updateCamera(this, this.gameObject.transform.getWorldMatrix());
        };
        /**
         * 计算相机的 view matrix（视图矩阵）
         */
        Camera.prototype.calcViewMatrix = function (matrix) {
            matrix.copy(this.gameObject.transform.getWorldMatrix()).inverse();
            return matrix;
        };
        /**
         * 计算相机的 project matrix（投影矩阵）
         */
        Camera.prototype.calcProjectMatrix = function (asp, matrix) {
            if (this.opvalue > 0) {
                egret3d.Matrix.perspectiveProjectLH(this.fov, asp, this.near, this.far, this.matProjP);
            }
            if (this.opvalue < 1) {
                egret3d.Matrix.orthoProjectLH(this.size * asp, this.size, this.near, this.far, this.matProjO);
            }
            if (this.opvalue === 0.0) {
                egret3d.Matrix.copy(this.matProjO, matrix);
            }
            else if (this.opvalue === 1.0) {
                egret3d.Matrix.copy(this.matProjP, matrix);
            }
            else {
                egret3d.Matrix.lerp(this.matProjO, this.matProjP, this.opvalue, matrix);
            }
            return matrix;
        };
        /**
         * calcViewPortPixel
         * @param viewPortPixel output rect
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 计算相机视口像素rect
         * @param viewPortPixel 输出的rect
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Camera.prototype.calcViewPortPixel = function (viewPortPixel) {
            var w;
            var h;
            var renderTarget = this.renderTarget;
            var viewport = this.viewport;
            if (renderTarget) {
                w = renderTarget.width;
                h = renderTarget.height;
            }
            else {
                w = egret3d.stage.screenViewport.w;
                h = egret3d.stage.screenViewport.h;
            }
            viewPortPixel.x = w * viewport.x;
            viewPortPixel.y = h * viewport.y;
            viewPortPixel.w = w * viewport.w;
            viewPortPixel.h = h * viewport.h;
            //asp = this.viewPortPixel.w / this.viewPortPixel.h;
        };
        /**
         * createRayByScreen
         * @param screenpos screen coords
         * @param app application
         * @return Ray ray
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 由屏幕坐标发射射线
         * @param screenpos 屏幕坐标
         * @param app 主程序实例
         * @return Ray 射线
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Camera.prototype.createRayByScreen = function (screenPosX, screenPosY) {
            var src1 = egret3d.helpVector3C;
            src1.x = screenPosX;
            src1.y = screenPosY;
            src1.z = 0.0;
            var src2 = egret3d.helpVector3D;
            src2.x = screenPosX;
            src2.y = screenPosY;
            src2.z = 1.0;
            var dest1 = egret3d.helpVector3E;
            var dest2 = egret3d.helpVector3F;
            this.calcWorldPosFromScreenPos(src1, dest1);
            this.calcWorldPosFromScreenPos(src2, dest2);
            var dir = egret3d.helpVector3G;
            egret3d.Vector3.subtract(dest2, dest1, dir);
            egret3d.Vector3.normalize(dir);
            var ray = new egret3d.Ray(dest1, dir);
            return ray;
        };
        /**
         * calcWorldPosFromScreenPos
         * @param app application
         * @param screenpos screen coords
         * @param outWorldPos world coords
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 由屏幕坐标得到世界坐标
         * @param app 主程序
         * @param screenpos 屏幕坐标
         * @param outWorldPos 世界坐标
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Camera.prototype.calcWorldPosFromScreenPos = function (screenPos, outWorldPos) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var vppos = egret3d.helpVector3A;
            vppos.x = screenPos.x / vpp.w * 2.0 - 1.0;
            vppos.y = 1.0 - screenPos.y / vpp.h * 2.0;
            vppos.z = screenPos.z;
            var matrixView = egret3d.helpMatrixA;
            var matrixProject = egret3d.helpMatrixB;
            var asp = vpp.w / vpp.h;
            this.calcViewMatrix(matrixView);
            this.calcProjectMatrix(asp, matrixProject);
            var matrixViewProject = egret3d.helpMatrixC;
            var matinv = egret3d.helpMatrixD;
            egret3d.Matrix.multiply(matrixProject, matrixView, matrixViewProject);
            egret3d.Matrix.inverse(matrixViewProject, matinv);
            egret3d.Matrix.transformVector3(vppos, matinv, outWorldPos);
        };
        /**
         * calcScreenPosFromWorldPos
         * @param app application
         * @param worldPos world coords
         * @param outScreenPos screen coords
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 由世界坐标得到屏幕坐标
         * @param app 主程序
         * @param worldPos 世界坐标
         * @param outScreenPos 屏幕坐标
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Camera.prototype.calcScreenPosFromWorldPos = function (worldPos, outScreenPos) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var matrixView = egret3d.helpMatrixA;
            var matrixProject = egret3d.helpMatrixB;
            var asp = vpp.w / vpp.h;
            this.calcViewMatrix(matrixView);
            this.calcProjectMatrix(asp, matrixProject);
            var matrixViewProject = egret3d.helpMatrixC;
            egret3d.Matrix.multiply(matrixProject, matrixView, matrixViewProject);
            var ndcPos = egret3d.helpVector3A;
            egret3d.Matrix.transformVector3(worldPos, matrixViewProject, ndcPos);
            outScreenPos.x = (ndcPos.x + 1.0) * vpp.w * 0.5;
            outScreenPos.y = (1.0 - ndcPos.y) * vpp.h * 0.5;
        };
        /**
         *
         */
        Camera.prototype.getPosAtXPanelInViewCoordinateByScreenPos = function (screenPos, z, out) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var nearpos = egret3d.helpVector3A;
            nearpos.z = -this.near;
            nearpos.x = screenPos.x - vpp.w * 0.5;
            nearpos.y = vpp.h * 0.5 - screenPos.y;
            var farpos = egret3d.helpVector3B;
            farpos.z = -this.far;
            farpos.x = this.far * nearpos.x / this.near;
            farpos.y = this.far * nearpos.y / this.near;
            var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
            out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
            out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
        };
        Camera.prototype.testFrustumCulling = function (node) {
            var aabb = node.aabb;
            if (!aabb.intersectPlane(this.frameVecs[0], this.frameVecs[1], this.frameVecs[5]))
                return false;
            if (!aabb.intersectPlane(this.frameVecs[1], this.frameVecs[3], this.frameVecs[7]))
                return false;
            if (!aabb.intersectPlane(this.frameVecs[3], this.frameVecs[2], this.frameVecs[6]))
                return false;
            if (!aabb.intersectPlane(this.frameVecs[2], this.frameVecs[0], this.frameVecs[4]))
                return false;
            if (!aabb.intersectPlane(this.frameVecs[5], this.frameVecs[7], this.frameVecs[6]))
                return false;
            if (!aabb.intersectPlane(this.frameVecs[0], this.frameVecs[2], this.frameVecs[3]))
                return false;
            return true;
        };
        Object.defineProperty(Camera.prototype, "near", {
            /**
             * distance between camera and near plane
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 相机到近裁剪面距离
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._near;
            },
            set: function (value) {
                if (value >= this.far) {
                    value = this.far - 1.0;
                }
                if (value < 0.01) {
                    value = 0.01;
                }
                this._near = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "far", {
            /**
             * distance between camera and far plane
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 相机到远裁剪面距离
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._far;
            },
            set: function (value) {
                if (value <= this.near) {
                    value = this.near + 1.0;
                }
                if (value >= 1000.0) {
                    value = 1000.0;
                }
                this._far = value;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Camera.prototype, "clearOption_Color", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "clearOption_Depth", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "cullingMask", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "order", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "fov", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "size", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "opvalue", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "backgroundColor", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "viewport", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "_near", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "_far", void 0);
        return Camera;
    }(paper.BaseComponent));
    egret3d.Camera = Camera;
    __reflect(Camera.prototype, "egret3d.Camera");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 深度绘制通道
     * TODO 完善后public给开发者
     */
    var CameraPostQueueDepth = (function () {
        function CameraPostQueueDepth() {
            /**
             * @inheritDoc
             */
            this.renderTarget = null;
        }
        /**
         * @inheritDoc
         */
        CameraPostQueueDepth.prototype.render = function (camera, renderSystem) {
            var webgl = egret3d.WebGLKit.webgl;
            camera._targetAndViewport(this.renderTarget, true); // 最后一个参数true 表示不用camera的clear 配置
            egret3d.WebGLKit.zWrite(true);
            // webgl.depthMask(true); // 开启 zwrite 以便正常 clear depth
            webgl.clearColor(0, 0, 0, 0);
            webgl.clearDepth(1.0);
            webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
            camera.context.drawtype = "_depth";
            // camera._renderOnce(scene, context, "_depth");
            renderSystem.$renderCamera(camera);
            egret3d.GlRenderTarget.useNull(webgl);
        };
        return CameraPostQueueDepth;
    }());
    egret3d.CameraPostQueueDepth = CameraPostQueueDepth;
    __reflect(CameraPostQueueDepth.prototype, "egret3d.CameraPostQueueDepth", ["egret3d.ICameraPostQueue"]);
    // /**
    //  * framebuffer绘制通道
    //  * TODO 完善后public给开发者
    //  */
    // export class CameraPostQueueQuad implements ICameraPostQueue {
    //     /**
    //      * shader & uniform
    //      */
    //     public readonly material: Material = new Material();
    //     /**
    //      * @inheritDoc
    //      */
    //     public renderTarget: GlRenderTarget = null as any;
    //     /**
    //      * @inheritDoc
    //      */
    //     public render(camera: Camera, _renderSystem: CameraSystem) {
    //         const webgl = WebGLKit.webgl;
    //         camera._targetAndViewport(this.renderTarget, true);
    //         WebGLKit.zWrite(true);
    //         // webgl.depthMask(true); // 开启 zwrite 以便正常 clear depth
    //         webgl.clearColor(0, 0.3, 0, 0);
    //         webgl.clearDepth(1.0);
    //         webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
    //         const mesh = DefaultMeshes.QUAD;
    //         camera.context.drawtype = "";
    //         WebGLKit.draw(camera.context, this.material, mesh, 0, "quad");
    //     }
    // }
    /**
     * 颜色绘制通道
     * TODO 完善后public给开发者
     */
    var CameraPostQueueColor = (function () {
        function CameraPostQueueColor() {
            /**
             * @inheritDoc
             */
            this.renderTarget = null;
        }
        /**
         * @inheritDoc
         */
        CameraPostQueueColor.prototype.render = function (camera, renderSystem) {
            var webgl = egret3d.WebGLKit.webgl;
            camera._targetAndViewport(this.renderTarget, false);
            camera.context.drawtype = "";
            // camera._renderOnce(scene, context, "");
            renderSystem.$renderCamera(camera);
            egret3d.GlRenderTarget.useNull(webgl);
        };
        return CameraPostQueueColor;
    }());
    egret3d.CameraPostQueueColor = CameraPostQueueColor;
    __reflect(CameraPostQueueColor.prototype, "egret3d.CameraPostQueueColor", ["egret3d.ICameraPostQueue"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var helpVec3_1 = new egret3d.Vector3();
    /**
     * 缓存场景通用数据
     * 包括矩阵信息，灯光，光照贴图，viewport尺寸等等
     */
    var RenderContext = (function () {
        function RenderContext() {
            /**
             *
             */
            this.version = 0;
            /**
             *
             */
            this.lightmapUV = 1;
            this.lightCount = 0;
            this.directLightCount = 0;
            this.pointLightCount = 0;
            this.spotLightCount = 0;
            /**
             *
             */
            this.drawtype = "";
            /**
             *
             */
            this.lightmap = null;
            this.lightmapIntensity = 1.0;
            this.boneData = null;
            // 15: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, intensity, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
            this.directLightArray = new Float32Array(0);
            // 19: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, intensity, distance, decay, shadow, shadowBias, shadowRadius, shadowCameraNear, shadowCameraFar, shadowMapSizeX, shadowMapSizeY
            this.pointLightArray = new Float32Array(0);
            // 19: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, intensity, distance, decay, coneCos, penumbraCos, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
            this.spotLightArray = new Float32Array(0);
            this.directShadowMatrix = new Float32Array(0);
            this.spotShadowMatrix = new Float32Array(0);
            this.matrix_m = new egret3d.Matrix();
            this.matrix_mvp = new egret3d.Matrix();
            this.directShadowMaps = [];
            this.pointShadowMaps = [];
            this.spotShadowMaps = [];
            this.viewPortPixel = { x: 0, y: 0, w: 0, h: 0 };
            //
            this.cameraPosition = new egret3d.Vector3();
            this.cameraForward = new egret3d.Vector3();
            this.cameraUp = new egret3d.Vector3();
            // transforms
            // eyePos: Vector4 = new Vector4();
            this.matrix_v = new egret3d.Matrix();
            this.matrix_p = new egret3d.Matrix();
            this.matrix_mv = new egret3d.Matrix();
            this.matrix_vp = new egret3d.Matrix();
            /**
             *
             */
            this.lightmapOffset = null;
            this.lightPosition = new Float32Array([0.0, 0.0, 0.0, 1.0]);
            this.lightShadowCameraNear = 0;
            this.lightShadowCameraFar = 0;
        }
        RenderContext.prototype.updateLightmap = function (texture, uv, offset, intensity) {
            this.lightmap = texture;
            this.lightmapUV = uv;
            this.lightmapOffset = offset;
            this.lightmapIntensity = intensity;
            this.version++;
        };
        RenderContext.prototype.updateCamera = function (camera, matrix) {
            camera.calcViewPortPixel(this.viewPortPixel); // update viewport
            var asp = this.viewPortPixel.w / this.viewPortPixel.h;
            this.matrix_v.copy(matrix).inverse();
            camera.calcProjectMatrix(asp, this.matrix_p);
            egret3d.Matrix.multiply(this.matrix_p, this.matrix_v, this.matrix_vp);
            var worldMatrix = matrix.rawData;
            this.cameraPosition.x = worldMatrix[12];
            this.cameraPosition.y = worldMatrix[13];
            this.cameraPosition.z = worldMatrix[14];
            this.cameraUp.x = worldMatrix[4];
            this.cameraUp.y = worldMatrix[5];
            this.cameraUp.z = worldMatrix[6];
            this.cameraForward.x = -worldMatrix[8];
            this.cameraForward.y = -worldMatrix[9];
            this.cameraForward.z = -worldMatrix[10];
            this.version++;
        };
        RenderContext.prototype.updateLights = function (lights) {
            var allLightCount = 0, directLightCount = 0, pointLightCount = 0, spotLightCount = 0;
            for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
                var light = lights_1[_i];
                if (light instanceof egret3d.DirectLight) {
                    directLightCount++;
                }
                else if (light instanceof egret3d.PointLight) {
                    pointLightCount++;
                }
                else if (light instanceof egret3d.SpotLight) {
                    spotLightCount++;
                }
                allLightCount++;
            }
            // TODO
            if (this.directLightArray.length !== directLightCount * 15) {
                this.directLightArray = new Float32Array(directLightCount * 15);
            }
            if (this.pointLightArray.length !== pointLightCount * 19) {
                this.pointLightArray = new Float32Array(pointLightCount * 19);
            }
            if (this.spotLightArray.length !== spotLightCount * 19) {
                this.spotLightArray = new Float32Array(spotLightCount * 19);
            }
            if (this.directShadowMatrix.length !== directLightCount * 16) {
                this.directShadowMatrix = new Float32Array(directLightCount * 16);
            }
            if (this.spotShadowMatrix.length !== spotLightCount * 16) {
                this.spotShadowMatrix = new Float32Array(spotLightCount * 16);
            }
            this.directShadowMaps.length = directLightCount;
            this.pointShadowMaps.length = pointLightCount;
            this.spotShadowMaps.length = spotLightCount;
            this.lightCount = allLightCount;
            this.directLightCount = directLightCount;
            this.pointLightCount = pointLightCount;
            this.spotLightCount = spotLightCount;
            var directLightIndex = 0, pointLightIndex = 0, spotLightIndex = 0, index = 0, size = 0;
            for (var _a = 0, lights_2 = lights; _a < lights_2.length; _a++) {
                var light = lights_2[_a];
                var lightArray = this.directLightArray;
                if (light.type === 1 /* Direction */) {
                    lightArray = this.directLightArray;
                    index = directLightIndex;
                    size = 15;
                }
                else if (light.type === 2 /* Point */) {
                    lightArray = this.pointLightArray;
                    index = pointLightIndex;
                    size = 19;
                }
                else if (light.type === 3 /* Spot */) {
                    lightArray = this.spotLightArray;
                    index = spotLightIndex;
                    size = 19;
                }
                var offset = 0;
                var pos = light.gameObject.transform.getPosition();
                lightArray[index * size + offset++] = pos.x;
                lightArray[index * size + offset++] = pos.y;
                lightArray[index * size + offset++] = pos.z;
                var dir = light.gameObject.transform.getForward(helpVec3_1);
                lightArray[index * size + offset++] = dir.x;
                lightArray[index * size + offset++] = dir.y;
                lightArray[index * size + offset++] = dir.z;
                lightArray[index * size + offset++] = light.color.r;
                lightArray[index * size + offset++] = light.color.g;
                lightArray[index * size + offset++] = light.color.b;
                lightArray[index * size + offset++] = light.intensity;
                if (light.type === 2 /* Point */ || light.type === 3 /* Spot */) {
                    lightArray[index * size + offset++] = light.distance;
                    lightArray[index * size + offset++] = light.decay;
                    if (light.type === 3 /* Spot */) {
                        lightArray[index * size + offset++] = Math.cos(light.angle);
                        lightArray[index * size + offset++] = Math.cos(light.angle * (1 - light.penumbra));
                    }
                }
                if (light.castShadows) {
                    lightArray[index * size + offset++] = 1;
                    if (light.type === 1 /* Direction */) {
                        lightArray[index * size + offset++] = light.shadowBias;
                        lightArray[index * size + offset++] = light.shadowRadius;
                        lightArray[index * size + offset++] = light.shadowSize;
                        lightArray[index * size + offset++] = light.shadowSize;
                        this.directShadowMatrix.set(light.matrix.rawData, directLightIndex * 16);
                        this.directShadowMaps[directLightIndex] = light.renderTarget.texture;
                    }
                    else if (light.type === 2 /* Point */) {
                        lightArray[index * size + offset++] = light.shadowBias;
                        lightArray[index * size + offset++] = light.shadowRadius;
                        lightArray[index * size + offset++] = light.shadowCameraNear;
                        lightArray[index * size + offset++] = light.shadowCameraFar;
                        lightArray[index * size + offset++] = light.shadowSize;
                        lightArray[index * size + offset++] = light.shadowSize;
                        this.pointShadowMaps[pointLightIndex] = light.renderTarget.texture;
                    }
                    else if (light.type === 3 /* Spot */) {
                        lightArray[index * size + offset++] = light.shadowBias;
                        lightArray[index * size + offset++] = light.shadowRadius;
                        lightArray[index * size + offset++] = light.shadowSize;
                        lightArray[index * size + offset++] = light.shadowSize;
                        this.spotShadowMatrix.set(light.matrix.rawData, spotLightIndex * 16);
                        this.spotShadowMaps[spotLightIndex] = light.renderTarget.texture;
                    }
                }
                else {
                    lightArray[index * size + offset++] = 0;
                    lightArray[index * size + offset++] = 0;
                    lightArray[index * size + offset++] = 0;
                    lightArray[index * size + offset++] = 0;
                    lightArray[index * size + offset++] = 0;
                    if (light.type === 1 /* Direction */) {
                        this.directShadowMaps[directLightIndex] = null;
                    }
                    else if (light.type === 2 /* Point */) {
                        this.pointShadowMaps[pointLightIndex] = null;
                    }
                    else if (light.type === 3 /* Spot */) {
                        this.spotShadowMaps[spotLightIndex] = null;
                    }
                }
                if (light.type === 1 /* Direction */) {
                    directLightIndex++;
                }
                else if (light.type === 2 /* Point */) {
                    pointLightIndex++;
                }
                else if (light.type === 3 /* Spot */) {
                    spotLightIndex++;
                }
            }
            this.version++;
        };
        RenderContext.prototype.updateOverlay = function () {
            egret3d.Matrix.identify(this.matrix_mvp);
            this.version++;
        };
        RenderContext.prototype.updateModel = function (matrix) {
            egret3d.Matrix.copy(matrix, this.matrix_m); // clone matrix because getWorldMatrix returns a reference
            egret3d.Matrix.multiply(this.matrix_v, this.matrix_m, this.matrix_mv);
            // paper._Matrix.inverse(this.matrixModelView, this.matrixNormal);
            // paper.matrixTranspose(this.matrixNormal, this.matrixNormal);
            egret3d.Matrix.multiply(this.matrix_vp, this.matrix_m, this.matrix_mvp);
            this.version++;
        };
        // for trial effect
        RenderContext.prototype.updateModeTrail = function () {
            egret3d.Matrix.copy(this.matrix_v, this.matrix_mv);
            egret3d.Matrix.copy(this.matrix_vp, this.matrix_mvp);
            this.version++;
        };
        RenderContext.prototype.updateBones = function (data) {
            this.boneData = data;
            this.version++;
        };
        RenderContext.prototype.updateLightDepth = function (light) {
            var position = light.gameObject.transform.getPosition();
            this.lightPosition[0] = position.x;
            this.lightPosition[1] = position.y;
            this.lightPosition[2] = position.z;
            // this.lightPosition[3] = 1.0;
            this.lightShadowCameraNear = light.shadowCameraNear;
            this.lightShadowCameraFar = light.shadowCameraFar;
        };
        return RenderContext;
    }());
    egret3d.RenderContext = RenderContext;
    __reflect(RenderContext.prototype, "egret3d.RenderContext");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 可以添加egret2d显示对象（包括EUI）进行渲染。
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Egret2DRenderer = (function (_super) {
        __extends(Egret2DRenderer, _super);
        function Egret2DRenderer() {
            var _this = _super.call(this) || this;
            /**
             * 是否使用视锥剔除
             */
            _this.frustumTest = false;
            _this._screenAdapter = new egret3d.ConstantAdapter();
            _this._catchedEvent = {};
            _this._stageWidth = 0;
            _this._stageHeight = 0;
            _this._scaler = 1;
            _this.stage = new egret.Stage();
            _this.stage.maxTouches = 98;
            _this.root = new egret.DisplayObjectContainer();
            _this.stage.addChild(_this.root);
            return _this;
        }
        Object.defineProperty(Egret2DRenderer.prototype, "screenAdapter", {
            get: function () {
                return this._screenAdapter;
            },
            set: function (adapter) {
                adapter.$dirty = true;
                this._screenAdapter = adapter;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        Egret2DRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            var context = egret3d.WebGLKit.webgl;
            if (!this.renderer) {
                this.renderer = egret.web.Renderer.getInstance(context);
            }
            var stage = this.stage;
            var displayList = new egret.sys.DisplayList(stage);
            displayList.renderBuffer = new egret.sys.RenderBuffer(undefined, undefined, true);
            stage.$displayList = displayList;
            egret3d.InputManager.touch.addEventListener("touchstart", this._onTouchStart, this);
            egret3d.InputManager.touch.addEventListener("touchend", this._onTouchEnd, this);
            egret3d.InputManager.touch.addEventListener("touchcancel", this._onTouchEnd, this);
            egret3d.InputManager.touch.addEventListener("touchmove", this._onTouchMove, this);
            egret3d.InputManager.mouse.addEventListener("mousedown", this._onTouchStart, this);
            egret3d.InputManager.mouse.addEventListener("mouseup", this._onTouchEnd, this);
            egret3d.InputManager.mouse.addEventListener("mousemove", this._onTouchMove, this);
        };
        /**
         * @inheritDoc
         */
        Egret2DRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            egret3d.InputManager.touch.removeEventListener("touchstart", this._onTouchStart, this);
            egret3d.InputManager.touch.removeEventListener("touchend", this._onTouchEnd, this);
            egret3d.InputManager.touch.removeEventListener("touchcancel", this._onTouchEnd, this);
            egret3d.InputManager.touch.removeEventListener("touchmove", this._onTouchMove, this);
            egret3d.InputManager.mouse.removeEventListener("mousedown", this._onTouchStart, this);
            egret3d.InputManager.mouse.removeEventListener("mouseup", this._onTouchEnd, this);
            egret3d.InputManager.mouse.removeEventListener("mousemove", this._onTouchMove, this);
            // this.stage.removeChild(this.root);
        };
        /**
         * 检查屏幕接触事件是否能够穿透此2D层
         */
        Egret2DRenderer.prototype.checkEventThrough = function (x, y) {
            return !!this._catchedEvent[x + "_" + y];
        };
        Egret2DRenderer.prototype._onTouchStart = function (event) {
            // console.log(event);
            if (this.stage.$onTouchBegin(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                this._catchedEvent[event.x + "_" + event.y] = true;
            }
        };
        Egret2DRenderer.prototype._onTouchMove = function (event) {
            // console.log(event);
            if (this.stage.$onTouchMove(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                this._catchedEvent[event.x + "_" + event.y] = true;
            }
        };
        Egret2DRenderer.prototype._onTouchEnd = function (event) {
            // console.log(event);
            if (this.stage.$onTouchEnd(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                this._catchedEvent[event.x + "_" + event.y] = true;
            }
        };
        /**
         * screen position to ui position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 从屏幕坐标转换到当前2D系统的坐标
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Egret2DRenderer.prototype.screenPosToUIPos = function (pos, out) {
            if (out === void 0) { out = new egret3d.Vector2(); }
            out.x = pos.x / this._scaler;
            out.y = pos.y / this._scaler;
            return out;
        };
        Object.defineProperty(Egret2DRenderer.prototype, "scaler", {
            /**
             * 从屏幕坐标到当前2D系统的坐标的缩放系数
             */
            get: function () {
                return this._scaler;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        Egret2DRenderer.prototype.update = function (delta) {
            var stage2d = this.stage;
            var _a = egret3d.stage.screenViewport, w = _a.w, h = _a.h;
            if (this._stageWidth != w || this._stageHeight != h || this.screenAdapter.$dirty) {
                var result = { w: 0, h: 0, s: 0 };
                this.screenAdapter.calculateScaler(w, h, result);
                this.screenAdapter.$dirty = false;
                // this._scaler = this.root.scaleX = this.root.scaleY = result.s;
                stage2d.$displayList["offsetMatrix"].a = result.s;
                stage2d.$displayList["offsetMatrix"].d = result.s;
                this._scaler = result.s;
                var stageWidth = result.w;
                var stageHeight = result.h;
                stage2d.$stageWidth = stageWidth;
                stage2d.$stageHeight = stageHeight;
                // stage.$displayList.setClipRect(screenWidth, screenHeight);
                stage2d.pushResize(w, h);
                stage2d.dispatchEventWith(egret.Event.RESIZE);
                this._stageWidth = w;
                this._stageHeight = h;
            }
            // clear catched events
            this._catchedEvent = {};
        };
        /**
         *
         */
        Egret2DRenderer.prototype.render = function (context, camera) {
            var gl = egret3d.WebGLKit.webgl;
            this.renderer.beforeRender();
            this.stage.drawToSurface();
            egret3d.WebGLKit.resetState(); // 清除3D渲染器中的标脏
        };
        Egret2DRenderer = __decorate([
            paper.disallowMultipleComponent
        ], Egret2DRenderer);
        return Egret2DRenderer;
    }(paper.BaseRenderer));
    egret3d.Egret2DRenderer = Egret2DRenderer;
    __reflect(Egret2DRenderer.prototype, "egret3d.Egret2DRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Egret2DRendererSystem = (function (_super) {
        __extends(Egret2DRendererSystem, _super);
        function Egret2DRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: egret3d.Egret2DRenderer }
            ];
            return _this;
        }
        Egret2DRendererSystem.prototype.onUpdate = function () {
            var deltaTime = paper.Time.deltaTime;
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                component.update(deltaTime);
            }
        };
        return Egret2DRendererSystem;
    }(paper.BaseSystem));
    egret3d.Egret2DRendererSystem = Egret2DRendererSystem;
    __reflect(Egret2DRendererSystem.prototype, "egret3d.Egret2DRendererSystem");
})(egret3d || (egret3d = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var egret;
(function (egret) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var Renderer = (function () {
            function Renderer(context) {
                this.context = context;
                var egretWebGLRenderContext = this.egretWebGLRenderContext = egret.web.WebGLRenderContext.getInstance(0, 0);
                egretWebGLRenderContext.setContext(context);
                this.drawCmdManager = egretWebGLRenderContext.drawCmdManager;
                this.vao = egretWebGLRenderContext.vao;
                // egretWebGLRenderContext.drawFunc = this.$drawWebGL.bind(this);
                egretWebGLRenderContext.$drawWebGL = this.$drawWebGL.bind(this);
                egret.sys.RenderBuffer = egret.web.WebGLRenderBuffer;
                egret.sys.systemRenderer = new egret.web.WebGLRenderer();
                egret.sys.canvasRenderer = new egret.CanvasRenderer();
                egret.sys.customHitTestBuffer = new egret.web.WebGLRenderBuffer(3, 3);
                egret.sys.canvasHitTestBuffer = new egret.web.CanvasRenderBuffer(3, 3);
                egret.Capabilities['$renderMode'] = "webgl";
                this.vertexBuffer = context.createBuffer();
                this.indexBuffer = context.createBuffer();
                // app.addEventListener("beforeRender", function() {
                //     egret.ticker.update();
                // }, this);
            }
            Renderer.getInstance = function (context) {
                if (!this._instance) {
                    this._instance = new Renderer(context);
                }
                return this._instance;
            };
            Renderer.prototype.beforeRender = function () {
                var gl = this.context;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
                gl.enable(gl.BLEND);
                gl.disable(gl.STENCIL_TEST);
                gl.colorMask(true, true, true, true);
                this.setBlendMode("source-over");
                // 目前只使用0号材质单元，默认开启
                gl.activeTexture(gl.TEXTURE0);
            };
            Renderer.prototype.$drawWebGL = function () {
                if (this.drawCmdManager.drawDataLen == 0) {
                    return;
                }
                this.uploadVerticesArray(this.vao.getVertices());
                // 有mesh，则使用indicesForMesh
                if (this.vao.isMesh()) {
                    this.uploadIndicesArray(this.vao.getMeshIndices());
                }
                var length = this.drawCmdManager.drawDataLen;
                var offset = 0;
                for (var i = 0; i < length; i++) {
                    var data = this.drawCmdManager.drawData[i];
                    if (!data) {
                        continue;
                    }
                    offset = this.drawData(data, offset);
                    // 计算draw call
                    if (data.type == 6 /* ACT_BUFFER */) {
                        this.activatedBuffer = data.buffer;
                        this.egretWebGLRenderContext.activatedBuffer = data.buffer;
                    }
                    if (data.type == 0 /* TEXTURE */ || data.type == 1 /* PUSH_MASK */ || data.type == 2 /* POP_MASK */) {
                        if (this.activatedBuffer && this.activatedBuffer.$computeDrawCall) {
                            this.activatedBuffer.$drawCalls++;
                        }
                    }
                }
                // 切换回默认indices
                if (this.vao.isMesh()) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                // 清空数据
                this.drawCmdManager.clear();
                this.vao.clear();
            };
            /**
             * 执行绘制命令
             */
            Renderer.prototype.drawData = function (data, offset) {
                if (!data) {
                    return;
                }
                var gl = this.context;
                var program;
                var filter = data.filter;
                switch (data.type) {
                    case 0 /* TEXTURE */:
                        if (filter) {
                            if (filter.type === "custom") {
                                program = web.EgretWebGLProgram.getProgram(gl, filter.$vertexSrc, filter.$fragmentSrc, filter.$shaderKey);
                            }
                            else if (filter.type === "colorTransform") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.colorTransform_frag, "colorTransform");
                            }
                            else if (filter.type === "blurX") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "blurY") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "glow") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.glow_frag, "glow");
                            }
                        }
                        else {
                            program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.texture_frag, "texture");
                        }
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data.textureWidth, data.textureHeight);
                        offset += this.drawTextureElements(data, offset);
                        break;
                    case 1 /* PUSH_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data.textureWidth, data.textureHeight);
                        offset += this.drawPushMaskElements(data, offset);
                        break;
                    case 2 /* POP_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data.textureWidth, data.textureHeight);
                        offset += this.drawPopMaskElements(data, offset);
                        break;
                    case 3 /* BLEND */:
                        this.setBlendMode(data.value);
                        break;
                    case 4 /* RESIZE_TARGET */:
                        data.buffer.rootRenderTarget.resize(data.width, data.height);
                        this.onResize(data.width, data.height);
                        break;
                    case 5 /* CLEAR_COLOR */:
                        if (this.activatedBuffer) {
                            var target = this.activatedBuffer.rootRenderTarget;
                            if (target.width != 0 || target.height != 0) {
                                target.clear(true);
                            }
                        }
                        break;
                    case 6 /* ACT_BUFFER */:
                        this.activateBuffer(data.buffer, data.width, data.height);
                        break;
                    case 7 /* ENABLE_SCISSOR */:
                        var buffer = this.activatedBuffer;
                        if (buffer) {
                            if (buffer.rootRenderTarget) {
                                buffer.rootRenderTarget.enabledStencil();
                            }
                            buffer.enableScissor(data.x, data.y, data.width, data.height);
                        }
                        break;
                    case 8 /* DISABLE_SCISSOR */:
                        buffer = this.activatedBuffer;
                        if (buffer) {
                            buffer.disableScissor();
                        }
                        break;
                    default:
                        break;
                }
                return offset;
            };
            Renderer.prototype.activeProgram = function (gl, program) {
                // if (program != this.currentProgram) {
                gl.useProgram(program.id);
                // 目前所有attribute buffer的绑定方法都是一致的
                var attribute = program.attributes;
                for (var key in attribute) {
                    if (key === "aVertexPosition") {
                        gl.vertexAttribPointer(attribute["aVertexPosition"].location, 2, gl.FLOAT, false, 4 * 4, 0);
                        gl.enableVertexAttribArray(attribute["aVertexPosition"].location);
                    }
                    else if (key === "aTextureCoord") {
                        gl.vertexAttribPointer(attribute["aTextureCoord"].location, 2, gl.UNSIGNED_SHORT, true, 4 * 4, 2 * 4);
                        gl.enableVertexAttribArray(attribute["aTextureCoord"].location);
                    }
                    else if (key === "aColor") {
                        gl.vertexAttribPointer(attribute["aColor"].location, 1, gl.FLOAT, false, 4 * 4, 3 * 4);
                        gl.enableVertexAttribArray(attribute["aColor"].location);
                    }
                }
                this.currentProgram = program;
                // }
            };
            Renderer.prototype.syncUniforms = function (program, filter, textureWidth, textureHeight) {
                var uniforms = program.uniforms;
                for (var key in uniforms) {
                    if (key === "projectionVector") {
                        uniforms[key].setValue({ x: this.projectionX, y: this.projectionY });
                    }
                    else if (key === "uTextureSize") {
                        uniforms[key].setValue({ x: textureWidth, y: textureHeight });
                    }
                    else if (key === "uSampler") {
                    }
                    else {
                        var value = filter.$uniforms[key];
                        if (value !== undefined) {
                            uniforms[key].setValue(value);
                        }
                        else {
                            // egret.warn("filter custom: uniform " + key + " not defined!");
                        }
                    }
                }
            };
            /**
             * 画texture
             **/
            Renderer.prototype.drawTextureElements = function (data, offset) {
                var gl = this.context;
                gl.bindTexture(gl.TEXTURE_2D, data.texture);
                var size = data.count * 3;
                gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                return size;
            };
            /**
             * 启用RenderBuffer
             */
            Renderer.prototype.activateBuffer = function (buffer, width, height) {
                buffer.rootRenderTarget.activate();
                if (!this.bindIndices) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                buffer.restoreStencil();
                buffer.restoreScissor();
                this.onResize(width, height);
            };
            Renderer.prototype.onResize = function (width, height) {
                this.projectionX = width / 2;
                this.projectionY = -height / 2;
                if (this.context) {
                    this.context.viewport(0, 0, width, height);
                }
            };
            /**
             * 上传顶点数据
             */
            Renderer.prototype.uploadVerticesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ARRAY_BUFFER, array, gl.STREAM_DRAW);
            };
            /**
             * 上传索引数据
             */
            Renderer.prototype.uploadIndicesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);
                this.bindIndices = true;
            };
            /**
             * 画push mask
             **/
            Renderer.prototype.drawPushMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this.activatedBuffer;
                if (buffer) {
                    if (buffer.rootRenderTarget) {
                        buffer.rootRenderTarget.enabledStencil();
                    }
                    if (buffer.stencilHandleCount == 0) {
                        buffer.enableStencil();
                        gl.clear(gl.STENCIL_BUFFER_BIT); // clear
                    }
                    var level = buffer.stencilHandleCount;
                    buffer.stencilHandleCount++;
                    gl.colorMask(false, false, false, false);
                    gl.stencilFunc(gl.EQUAL, level, 0xFF);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                    // gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                    gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                    gl.colorMask(true, true, true, true);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                }
                return size;
            };
            /**
             * 画pop mask
             **/
            Renderer.prototype.drawPopMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this.activatedBuffer;
                if (buffer) {
                    buffer.stencilHandleCount--;
                    if (buffer.stencilHandleCount == 0) {
                        buffer.disableStencil(); // skip this draw
                    }
                    else {
                        var level = buffer.stencilHandleCount;
                        gl.colorMask(false, false, false, false);
                        gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                        // gl.bindTexture(gl.TEXTURE_2D, null);
                        gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                        gl.stencilFunc(gl.EQUAL, level, 0xFF);
                        gl.colorMask(true, true, true, true);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                    }
                }
                return size;
            };
            /**
             * 设置混色
             */
            Renderer.prototype.setBlendMode = function (value) {
                var gl = this.context;
                var blendModeWebGL = Renderer.blendModesForGL[value];
                if (blendModeWebGL) {
                    gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
                }
            };
            Renderer.initBlendMode = function () {
                Renderer.blendModesForGL = {};
                Renderer.blendModesForGL["source-over"] = [1, 771];
                Renderer.blendModesForGL["lighter"] = [1, 1];
                Renderer.blendModesForGL["lighter-in"] = [770, 771];
                Renderer.blendModesForGL["destination-out"] = [0, 771];
                Renderer.blendModesForGL["destination-in"] = [0, 770];
            };
            Renderer.blendModesForGL = null;
            return Renderer;
        }());
        web.Renderer = Renderer;
        __reflect(Renderer.prototype, "egret.web.Renderer");
        Renderer.initBlendMode();
    })(web = egret.web || (egret.web = {}));
})(egret || (egret = {}));
var egret3d;
(function (egret3d) {
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 恒定像素的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ConstantAdapter = (function () {
        function ConstantAdapter() {
            this.$dirty = true;
            this._scaleFactor = 1;
        }
        Object.defineProperty(ConstantAdapter.prototype, "scaleFactor", {
            /**
             * scaleFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置缩放值
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._scaleFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        ConstantAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler = this._scaleFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ConstantAdapter;
    }());
    egret3d.ConstantAdapter = ConstantAdapter;
    __reflect(ConstantAdapter.prototype, "egret3d.ConstantAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 拉伸扩展的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ExpandAdapter = (function () {
        function ExpandAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ExpandAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ExpandAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasHeight / this._resolution.y;
            }
            else {
                scaler = canvasWidth / this._resolution.x;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ExpandAdapter;
    }());
    egret3d.ExpandAdapter = ExpandAdapter;
    __reflect(ExpandAdapter.prototype, "egret3d.ExpandAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ShrinkAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 缩放的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ShrinkAdapter = (function () {
        function ShrinkAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ShrinkAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ShrinkAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasWidth / this._resolution.x;
            }
            else {
                scaler = canvasHeight / this._resolution.y;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ShrinkAdapter;
    }());
    egret3d.ShrinkAdapter = ShrinkAdapter;
    __reflect(ShrinkAdapter.prototype, "egret3d.ShrinkAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * MatchWidthOrHeightAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 适应宽高适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var MatchWidthOrHeightAdapter = (function () {
        function MatchWidthOrHeightAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
            this._matchFactor = 0; // width : height
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MatchWidthOrHeightAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        Object.defineProperty(MatchWidthOrHeightAdapter.prototype, "matchFactor", {
            /**
             * matchFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置匹配系数，0-1之间，越小越倾向以宽度适配，越大越倾向以高度适配。
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._matchFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        MatchWidthOrHeightAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler1 = canvasWidth / this._resolution.x;
            var scaler2 = canvasHeight / this._resolution.y;
            var scaler = scaler1 + (scaler2 - scaler1) * this._matchFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return MatchWidthOrHeightAdapter;
    }());
    egret3d.MatchWidthOrHeightAdapter = MatchWidthOrHeightAdapter;
    __reflect(MatchWidthOrHeightAdapter.prototype, "egret3d.MatchWidthOrHeightAdapter", ["egret3d.IScreenAdapter"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var MissingComponent = (function (_super) {
        __extends(MissingComponent, _super);
        function MissingComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        __decorate([
            paper.serializedField
        ], MissingComponent.prototype, "missingObject", void 0);
        return MissingComponent;
    }(paper.BaseComponent));
    paper.MissingComponent = MissingComponent;
    __reflect(MissingComponent.prototype, "paper.MissingComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DirectLight = (function (_super) {
        __extends(DirectLight, _super);
        function DirectLight() {
            var _this = _super.call(this) || this;
            _this.type = 1 /* Direction */;
            _this.renderTarget = new egret3d.GlRenderTarget(egret3d.WebGLKit.webgl, 1024, 1024, true); // TODO
            return _this;
        }
        DirectLight.prototype.update = function (camera, faceIndex) {
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowSize;
            camera.fov = Math.PI * 0.25; //
            camera.gameObject.transform.getWorldMatrix().copy(this.gameObject.transform.getWorldMatrix()); //
            _super.prototype.update.call(this, camera, faceIndex);
        };
        return DirectLight;
    }(egret3d.BaseLight));
    egret3d.DirectLight = DirectLight;
    __reflect(DirectLight.prototype, "egret3d.DirectLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _targets = [
        new egret3d.Vector3(-1, 0, 0), new egret3d.Vector3(1, 0, 0), new egret3d.Vector3(0, 1, 0),
        new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, 0, 1), new egret3d.Vector3(0, 0, -1)
    ];
    var _ups = [
        new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, 0, 1),
        new egret3d.Vector3(0, 0, -1), new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, -1, 0)
    ];
    /**
     *
     */
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        function PointLight() {
            var _this = _super.call(this) || this;
            _this.type = 2 /* Point */;
            _this.renderTarget = new egret3d.GlRenderTargetCube(egret3d.WebGLKit.webgl, 1024, 1024, true); // TODO
            return _this;
        }
        PointLight.prototype.update = function (camera, faceIndex) {
            var position = this.gameObject.transform.getPosition();
            egret3d.helpVector3A.set(position.x + _targets[faceIndex].x, position.y + _targets[faceIndex].y, position.z + _targets[faceIndex].z);
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowSize;
            camera.fov = Math.PI * 0.5;
            camera.gameObject.transform.setPosition(position); // TODO support copy matrix.
            camera.gameObject.transform.setRotation(this.gameObject.transform.getRotation());
            camera.gameObject.transform.lookAt(egret3d.helpVector3A, _ups[faceIndex]);
            _super.prototype.update.call(this, camera, faceIndex);
        };
        return PointLight;
    }(egret3d.BaseLight));
    egret3d.PointLight = PointLight;
    __reflect(PointLight.prototype, "egret3d.PointLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var SpotLight = (function (_super) {
        __extends(SpotLight, _super);
        function SpotLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 3 /* Spot */;
            return _this;
        }
        SpotLight.prototype.update = function (camera, faceIndex) {
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowSize;
            camera.fov = this.angle; //
            camera.gameObject.transform.getWorldMatrix().copy(this.gameObject.transform.getWorldMatrix()); //
            _super.prototype.update.call(this, camera, faceIndex);
        };
        return SpotLight;
    }(egret3d.BaseLight));
    egret3d.SpotLight = SpotLight;
    __reflect(SpotLight.prototype, "egret3d.SpotLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Light系统
     */
    var LightSystem = (function (_super) {
        __extends(LightSystem, _super);
        function LightSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: [egret3d.DirectLight, egret3d.SpotLight, egret3d.PointLight] }
            ];
            _this._lightCamera = _this._globalGameObject.getComponent(egret3d.Camera) || _this._globalGameObject.addComponent(egret3d.Camera);
            _this._drawCalls = _this._globalGameObject.getComponent(egret3d.DrawCalls) || _this._globalGameObject.addComponent(egret3d.DrawCalls);
            return _this;
        }
        LightSystem.prototype.onUpdate = function () {
            var camera = this._lightCamera;
            var drawCalls = this._drawCalls.drawCalls;
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var light = _a[_i];
                if (!light.castShadows) {
                    continue;
                    ;
                }
                var faceCount = 1;
                if (light.type === 2 /* Point */) {
                    faceCount = 6;
                }
                else if (light.type === 1 /* Direction */) {
                }
                else if (light.type === 3 /* Spot */) {
                }
                for (var i = 0; i < faceCount; ++i) {
                    light.renderTarget.activeCubeFace = i; // TODO 创建接口。
                    light.update(camera, i);
                    camera._targetAndViewport(light.renderTarget, false);
                    // render shadow
                    var context = camera.context;
                    if (light.type === 2 /* Point */) {
                        context.drawtype = "_distance_package";
                    }
                    else {
                        context.drawtype = "_depth_package";
                    }
                    context.updateCamera(camera, light.matrix);
                    context.updateLightDepth(light);
                    this._drawCalls.sortAfterFrustumCulling(camera); // TODO
                    for (var _b = 0, drawCalls_1 = drawCalls; _b < drawCalls_1.length; _b++) {
                        var drawCall = drawCalls_1[_b];
                        if (!drawCall.renderer.castShadows) {
                            continue;
                        }
                        var gameObject = drawCall.renderer.gameObject;
                        context.drawCall = drawCall;
                        context.updateModel(drawCall.matrix || gameObject.transform.getWorldMatrix());
                        //
                        var drawType = "base";
                        if (drawCall.boneData) {
                            context.updateBones(drawCall.boneData);
                            drawType = "skin";
                        }
                        egret3d.WebGLKit.draw(context, drawType);
                    }
                }
                egret3d.GlRenderTarget.useNull(egret3d.WebGLKit.webgl);
            }
        };
        return LightSystem;
    }(paper.BaseSystem));
    egret3d.LightSystem = LightSystem;
    __reflect(LightSystem.prototype, "egret3d.LightSystem");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 组件实体系统的主入口
     */
    var Application = (function () {
        function Application() {
        }
        Application._update = function () {
            paper.Time.update();
            if (this._isRunning) {
                requestAnimationFrame(this._bindUpdate);
            }
            this.systemManager.update();
        };
        Application.init = function (_a) {
            var _b = _a === void 0 ? {} : _a, _c = _b.isEditor, isEditor = _c === void 0 ? false : _c, _d = _b.isPlaying, isPlaying = _d === void 0 ? true : _d;
            var systemClasses = [
                paper.StartSystem,
                // egret3d.ammo.PhysicsSystem, // TODO 分离
                paper.UpdateSystem,
                egret3d.AnimationSystem,
                paper.LaterUpdateSystem,
                egret3d.TrailRendererSystem,
                egret3d.MeshRendererSystem,
                egret3d.SkinnedMeshRendererSystem,
                egret3d.particle.ParticleSystem,
                egret3d.Egret2DRendererSystem,
                egret3d.LightSystem,
                egret3d.CameraSystem,
                paper.EndSystem,
                paper.DestroySystem,
            ];
            var level = 0;
            for (var _i = 0, systemClasses_1 = systemClasses; _i < systemClasses_1.length; _i++) {
                var systemClass = systemClasses_1[_i];
                this.systemManager.register(systemClass, level++);
            }
            paper.Time.initialize();
            this._isEditor = isEditor;
            this._isPlaying = isPlaying;
            this.resume();
        };
        /**
         *
         */
        Application.pause = function () {
            this._isRunning = false;
        };
        Application.resume = function () {
            if (this._isRunning) {
                return;
            }
            this._isRunning = true;
            if (!this._bindUpdate) {
                this._bindUpdate = this._update.bind(this);
            }
            this._update();
        };
        Object.defineProperty(Application, "isEditor", {
            get: function () {
                return this._isEditor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Application, "isFocused", {
            get: function () {
                return this._isFocused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Application, "isPlaying", {
            get: function () {
                return this._isPlaying;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Application, "isRunning", {
            get: function () {
                return this._isRunning;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Application.callLater = function (callback) {
            this.systemManager.getSystem(paper.LaterUpdateSystem).callLater(callback);
        };
        /**
         * 系统管理器
         */
        Application.systemManager = paper.SystemManager.getInstance();
        /**
         * 场景管理器
         */
        Application.sceneManager = paper.SceneManager.getInstance();
        Application._isEditor = false;
        Application._isFocused = false;
        Application._isPlaying = false;
        Application._isRunning = false;
        Application._bindUpdate = null;
        return Application;
    }());
    paper.Application = Application;
    __reflect(Application.prototype, "paper.Application");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * mesh的渲染组件
     */
    var MeshRenderer = (function (_super) {
        __extends(MeshRenderer, _super);
        /**
         *
         */
        function MeshRenderer() {
            var _this = _super.call(this) || this;
            _this._materials = [];
            // default
            var material = new egret3d.Material();
            material.setShader(egret3d.DefaultShaders.DIFFUSE);
            _this._materials.push(material);
            return _this;
        }
        MeshRenderer.prototype.serialize = function () {
            var target = _super.prototype.serialize.call(this);
            target._receiveShadows = this._receiveShadows;
            target._castShadows = this._castShadows;
            target._lightmapIndex = this._lightmapIndex;
            target._lightmapScaleOffset = this._lightmapScaleOffset;
            target._materials = [];
            for (var _i = 0, _a = this._materials; _i < _a.length; _i++) {
                var material = _a[_i];
                target._materials.push(paper.serializeAsset(material));
            }
            return target;
        };
        MeshRenderer.prototype.deserialize = function (element) {
            _super.prototype.deserialize.call(this, element);
            this._receiveShadows = element._receiveShadows || false;
            this._castShadows = element._castShadows || false;
            this._lightmapIndex = element._lightmapIndex;
            if (element._materials) {
                this._materials.length = 0;
                for (var i = 0, l = element._materials.length; i < l; i++) {
                    this._materials.push(paper.getDeserializedObject(element._materials[i]));
                }
            }
            if (element._lightmapScaleOffset) {
                this._lightmapScaleOffset[0] = element._lightmapScaleOffset[0];
                this._lightmapScaleOffset[1] = element._lightmapScaleOffset[1];
                this._lightmapScaleOffset[2] = element._lightmapScaleOffset[2];
                this._lightmapScaleOffset[3] = element._lightmapScaleOffset[3];
            }
        };
        MeshRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this._materials.length = 0;
        };
        Object.defineProperty(MeshRenderer.prototype, "materials", {
            /**
             * material list
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 材质数组
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._materials;
            },
            set: function (value) {
                if (value === this._materials) {
                    return;
                }
                this._materials.length = 0;
                for (var _i = 0, value_4 = value; _i < value_4.length; _i++) {
                    var material = value_4[_i];
                    this._materials.push(material);
                }
                paper.EventPool.dispatchEvent("materials" /* Materials */, this);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], MeshRenderer.prototype, "_materials", void 0);
        __decorate([
            paper.editor.property(paper.editor.EditType.MATERIAL_ARRAY)
        ], MeshRenderer.prototype, "materials", null);
        MeshRenderer = __decorate([
            paper.requireComponent(egret3d.MeshFilter),
            paper.disallowMultipleComponent
        ], MeshRenderer);
        return MeshRenderer;
    }(paper.BaseRenderer));
    egret3d.MeshRenderer = MeshRenderer;
    __reflect(MeshRenderer.prototype, "egret3d.MeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var MeshRendererSystem = (function (_super) {
        __extends(MeshRendererSystem, _super);
        function MeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: egret3d.MeshFilter,
                    listeners: [
                        { type: "mesh" /* Mesh */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } }
                    ]
                },
                {
                    componentClass: egret3d.MeshRenderer,
                    listeners: [
                        { type: "materials" /* Materials */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } }
                    ]
                },
            ];
            _this._drawCalls = _this._globalGameObject.getComponent(egret3d.DrawCalls) || _this._globalGameObject.addComponent(egret3d.DrawCalls);
            return _this;
        }
        MeshRendererSystem.prototype._updateDrawCalls = function (gameObject) {
            if (!this._enabled || !this._hasGameObject(gameObject)) {
                return;
            }
            var filter = this._getComponent(gameObject, 0);
            var renderer = gameObject.renderer;
            if (!filter.mesh || renderer.materials.length === 0) {
                return;
            }
            this._drawCalls.removeDrawCalls(renderer);
            //
            this._drawCalls.renderers.push(renderer);
            //
            var subMeshIndex = 0;
            for (var _i = 0, _a = filter.mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var drawCall = {
                    renderer: renderer,
                    subMeshIndex: subMeshIndex++,
                    mesh: filter.mesh,
                    material: renderer.materials[primitive.material || 0],
                    frustumTest: false,
                    zdist: -1,
                    disable: false,
                };
                this._drawCalls.drawCalls.push(drawCall);
            }
        };
        MeshRendererSystem.prototype.onEnable = function () {
            for (var i = 0, l = this._components.length; i < l; i += this._interestComponentCount) {
                this._updateDrawCalls(this._components[i].gameObject);
            }
        };
        MeshRendererSystem.prototype.onAddGameObject = function (gameObject) {
            this._updateDrawCalls(gameObject);
        };
        MeshRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            if (!this._enabled) {
                return;
            }
            this._drawCalls.removeDrawCalls(gameObject.renderer);
        };
        MeshRendererSystem.prototype.onDisable = function () {
            for (var i = 0, l = this._components.length; i < l; i += this._interestComponentCount) {
                var renderer = this._components[i + 1];
                this._drawCalls.removeDrawCalls(renderer);
            }
        };
        return MeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.MeshRendererSystem = MeshRendererSystem;
    __reflect(MeshRendererSystem.prototype, "egret3d.MeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpVec3_3 = new egret3d.Vector3();
    var helpVec3_4 = new egret3d.Vector3();
    var helpVec3_5 = new egret3d.Vector3();
    var helpVec3_6 = new egret3d.Vector3();
    var helpVec3_7 = new egret3d.Vector3();
    // const helpVec3_8: Vector3 = new Vector3();
    var helpMat4_1 = new egret3d.Matrix();
    var helpMat4_2 = new egret3d.Matrix();
    var helpMat4_3 = new egret3d.Matrix();
    var helpMat4_4 = new egret3d.Matrix();
    var helpMat4_5 = new egret3d.Matrix();
    var helpMat4_6 = new egret3d.Matrix();
    /**
     * Skinned Mesh Renderer Component
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 蒙皮网格的渲染组件
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var SkinnedMeshRenderer = (function (_super) {
        __extends(SkinnedMeshRenderer, _super);
        function SkinnedMeshRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._materials = [];
            _this._mesh = null;
            _this._bones = [];
            _this.center = new egret3d.Vector3();
            _this.size = new egret3d.Vector3();
            /**
             *
             */
            _this._boneDirty = true;
            _this._maxBoneCount = 0;
            /**
             *
             */
            _this._retargetBoneNames = null;
            _this._efficient = true; // 是否高效模式
            return _this;
        }
        Object.defineProperty(SkinnedMeshRenderer.prototype, "mesh", {
            /**
             * mesh instance
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * mesh实例
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._mesh;
            },
            set: function (mesh) {
                if (this._mesh === mesh) {
                    return;
                }
                if (this._mesh) {
                    this._mesh.dispose();
                }
                this._mesh = mesh;
                paper.EventPool.dispatchEvent("mesh" /* Mesh */, this);
            },
            enumerable: true,
            configurable: true
        });
        SkinnedMeshRenderer.prototype._getMatByIndex = function (index, out) {
            var mesh = this._mesh;
            if (!mesh) {
                return null;
            }
            var blendIndices = egret3d.helpVector4E;
            mesh.getAttribute(index, "JOINTS_0" /* JOINTS_0 */, 0, blendIndices);
            if (blendIndices.x >= this._maxBoneCount || blendIndices.y >= this._maxBoneCount || blendIndices.z >= this._maxBoneCount || blendIndices.w >= this._maxBoneCount) {
                return null;
            }
            var blendWeights = egret3d.helpVector4F;
            mesh.getAttribute(index, "WEIGHTS_0" /* WEIGHTS_0 */, 0, blendWeights);
            if (this._efficient) {
                var vec40r = egret3d.helpVector4A;
                var vec30p = egret3d.helpVector3A;
                vec40r.x = this._skeletonMatrixData[8 * blendIndices.x + 0]; // TODO
                vec40r.y = this._skeletonMatrixData[8 * blendIndices.x + 1];
                vec40r.z = this._skeletonMatrixData[8 * blendIndices.x + 2];
                vec40r.w = this._skeletonMatrixData[8 * blendIndices.x + 3];
                vec30p.x = this._skeletonMatrixData[8 * blendIndices.x + 4];
                vec30p.y = this._skeletonMatrixData[8 * blendIndices.x + 5];
                vec30p.z = this._skeletonMatrixData[8 * blendIndices.x + 6];
                var vec41r = egret3d.helpVector4B;
                var vec31p = egret3d.helpVector3B;
                vec41r.x = this._skeletonMatrixData[8 * blendIndices.y + 0];
                vec41r.y = this._skeletonMatrixData[8 * blendIndices.y + 1];
                vec41r.z = this._skeletonMatrixData[8 * blendIndices.y + 2];
                vec41r.w = this._skeletonMatrixData[8 * blendIndices.y + 3];
                vec31p.x = this._skeletonMatrixData[8 * blendIndices.y + 4];
                vec31p.y = this._skeletonMatrixData[8 * blendIndices.y + 5];
                vec31p.z = this._skeletonMatrixData[8 * blendIndices.y + 6];
                var vec42r = egret3d.helpVector4C;
                var vec32p = egret3d.helpVector3C;
                vec42r.x = this._skeletonMatrixData[8 * blendIndices.z + 0];
                vec42r.y = this._skeletonMatrixData[8 * blendIndices.z + 1];
                vec42r.z = this._skeletonMatrixData[8 * blendIndices.z + 2];
                vec42r.w = this._skeletonMatrixData[8 * blendIndices.z + 3];
                vec32p.x = this._skeletonMatrixData[8 * blendIndices.z + 4];
                vec32p.y = this._skeletonMatrixData[8 * blendIndices.z + 5];
                vec32p.z = this._skeletonMatrixData[8 * blendIndices.z + 6];
                var vec43r = egret3d.helpVector4D;
                var vec33p = egret3d.helpVector3D;
                vec43r.x = this._skeletonMatrixData[8 * blendIndices.w + 0];
                vec43r.y = this._skeletonMatrixData[8 * blendIndices.w + 1];
                vec43r.z = this._skeletonMatrixData[8 * blendIndices.w + 2];
                vec43r.w = this._skeletonMatrixData[8 * blendIndices.w + 3];
                vec33p.x = this._skeletonMatrixData[8 * blendIndices.w + 4];
                vec33p.y = this._skeletonMatrixData[8 * blendIndices.w + 5];
                vec33p.z = this._skeletonMatrixData[8 * blendIndices.w + 6];
                var mat0 = egret3d.helpMatrixA;
                var mat1 = egret3d.helpMatrixB;
                var mat2 = egret3d.helpMatrixC;
                var mat3 = egret3d.helpMatrixD;
                egret3d.Matrix.fromRTS(vec30p, egret3d.Vector3.ONE, vec40r, mat0);
                egret3d.Matrix.fromRTS(vec31p, egret3d.Vector3.ONE, vec41r, mat1);
                egret3d.Matrix.fromRTS(vec32p, egret3d.Vector3.ONE, vec42r, mat2);
                egret3d.Matrix.fromRTS(vec33p, egret3d.Vector3.ONE, vec43r, mat3);
                egret3d.Matrix.scale(blendWeights.x, mat0);
                egret3d.Matrix.scale(blendWeights.y, mat1);
                egret3d.Matrix.scale(blendWeights.z, mat2);
                egret3d.Matrix.scale(blendWeights.w, mat3);
                egret3d.Matrix.add(mat0, mat1, out);
                egret3d.Matrix.add(out, mat2, out);
                egret3d.Matrix.add(out, mat3, out);
            }
            else {
                // TODO
                // const mat0 = helpMatrixA;
                // const mat1 = helpMatrixB;
                // const mat2 = helpMatrixC;
                // const mat3 = helpMatrixD;
                // mat0.rawData = this._skeletonMatrixData.slice(16 * blendIndices.x, 16 * blendIndices.x + 16);
                // mat1.rawData = this._skeletonMatrixData.slice(16 * blendIndices.y, 16 * blendIndices.y + 16);
                // mat2.rawData = this._skeletonMatrixData.slice(16 * blendIndices.z, 16 * blendIndices.z + 16);
                // mat3.rawData = this._skeletonMatrixData.slice(16 * blendIndices.w, 16 * blendIndices.w + 16);
                // egret3d.Matrix.scale(blendWeights.x, mat0);
                // egret3d.Matrix.scale(blendWeights.y, mat1);
                // egret3d.Matrix.scale(blendWeights.z, mat2);
                // egret3d.Matrix.scale(blendWeights.w, mat3);
                // egret3d.Matrix.add(mat0, mat1, out);
                // egret3d.Matrix.add(out, mat2, out);
                // egret3d.Matrix.add(out, mat3, out);
            }
            return out;
        };
        /**
         * @inheritDoc
         */
        SkinnedMeshRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.materials = this._materials;
            this.mesh = this._mesh;
            this.bones = this._bones;
            var shaderType = 0 /* SQT */;
            if (this._materials.length > 0) {
                var materialPasses = this._materials[0].getShader().passes["skin"];
                if (!materialPasses || materialPasses.length === 0) {
                    shaderType = 1 /* Matrix */;
                }
            }
            // TODO _bonePoses 应该是动态长度
            switch (shaderType) {
                case 1 /* Matrix */:
                    this._maxBoneCount = 24;
                    this._skeletonMatrixData = new Float32Array(16 * this._maxBoneCount);
                    break;
                case 0 /* SQT */:
                    this._maxBoneCount = 55;
                    this._skeletonMatrixData = new Float32Array(8 * this._maxBoneCount);
                    for (var i = 0; i < this._maxBoneCount; ++i) {
                        var iA = i * 8;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 1.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 1.0;
                    }
                    break;
            }
            // TODO 如果layer发生改变，需要重新刷新在renderList中的层级。 可以依赖 event
            // if (this.materials != null && this.materials.length > 0) {
            //     let _mat = this.materials[0];
            //     if (_mat) {
            //         this.layer = _mat.getLayer();
            //         if (!this.issetq) {
            //             this._queue = _mat.getQueue();
            //         }
            //     }
            // }
        };
        /**
         * @inheritDoc
         */
        SkinnedMeshRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                this._mesh.dispose();
            }
            this._bones.length = 0;
            this._mesh = null;
        };
        /**
         * @inheritDoc
         */
        SkinnedMeshRenderer.prototype.serialize = function () {
            var target = _super.prototype.serialize.call(this);
            target.center = [this.center.x, this.center.y, this.center.z];
            target.size = [this.size.x, this.size.y, this.size.z];
            target.rootBone = null;
            target._bones = [];
            target._mesh = this._mesh ? this._mesh.serialize() : null;
            target._materials = [];
            if (this.rootBone) {
                target.rootBone = { uuid: this.rootBone.uuid };
            }
            var materials = this._materials;
            target._materials.length = materials.length;
            for (var i = 0, l = materials.length; i < l; i++) {
                var material = materials[i];
                target._materials[i] = paper.serializeAsset(material);
            }
            var bones = this._bones;
            target._bones.length = bones.length;
            for (var i = 0, l = bones.length; i < l; i++) {
                var bone = bones[i];
                target._bones[i] = { uuid: bone.uuid };
            }
            return target;
        };
        /**
         * @inheritDoc
         */
        SkinnedMeshRenderer.prototype.deserialize = function (element) {
            _super.prototype.deserialize.call(this, element);
            this.center.deserialize(element.center);
            this.size.deserialize(element.size);
            if (element._mesh) {
                this._mesh = new egret3d.Mesh(); //
                this._mesh.deserialize(element._mesh);
            }
            if (element.rootBone) {
                this.rootBone = paper.getDeserializedObject(element.rootBone);
            }
            this._materials.length = 0;
            if (element._materials) {
                for (var i = 0, l = element._materials.length; i < l; i++) {
                    this._materials.push(paper.getDeserializedObject(element._materials[i]));
                }
            }
            this._bones.length = 0;
            if (element._bones) {
                for (var i = 0, l = element._bones.length; i < l; i++) {
                    this._bones.push(paper.getDeserializedObject(element._bones[i]));
                }
            }
        };
        /**
         * ray intersects
         * @param ray ray
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 射线检测
         * @param ray 射线
         * @version paper 1.0
         * @platform Web
         * @language
         */
        SkinnedMeshRenderer.prototype.intersects = function (ray) {
            var mesh = this._mesh;
            if (!mesh) {
                return null;
            }
            var mvpmat = this.gameObject.transform.getWorldMatrix();
            var pickinfo = null;
            // let data = this.mesh.data;
            var subMeshIndex = 0;
            for (var _i = 0, _a = mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var mat0 = helpMat4_1;
                var mat1 = helpMat4_2;
                var mat2 = helpMat4_3;
                var mat00 = helpMat4_4;
                var mat11 = helpMat4_5;
                var mat22 = helpMat4_6;
                var indices = mesh.getIndices(subMeshIndex);
                if (indices) {
                    var t0 = helpVec3_1;
                    var t1 = helpVec3_2;
                    var t2 = helpVec3_3;
                    var vertices = mesh.getVertices(subMeshIndex);
                    for (var i = 0; i < indices.length; i += 3) {
                        // TODO
                        var verindex0 = indices[i];
                        var verindex1 = indices[i + 1];
                        var verindex2 = indices[i + 2];
                        var p0 = helpVec3_4;
                        var p1 = helpVec3_5;
                        var p2 = helpVec3_6;
                        var index = indices[i] * 3;
                        egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p0);
                        index = indices[i + 1] * 3;
                        egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p1);
                        index = indices[i + 2] * 3;
                        egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p2);
                        this._getMatByIndex(verindex0, mat0);
                        this._getMatByIndex(verindex1, mat1);
                        this._getMatByIndex(verindex2, mat2);
                        if (mat0 === null || mat1 === null || mat2 === null)
                            continue;
                        egret3d.Matrix.multiply(mvpmat, mat0, mat00);
                        egret3d.Matrix.multiply(mvpmat, mat1, mat11);
                        egret3d.Matrix.multiply(mvpmat, mat2, mat22);
                        egret3d.Matrix.transformVector3(p0, mat00, t0);
                        egret3d.Matrix.transformVector3(p1, mat11, t1);
                        egret3d.Matrix.transformVector3(p2, mat22, t2);
                        var result = ray.intersectsTriangle(t0, t1, t2);
                        if (result) {
                            if (result.distance < 0)
                                continue;
                            if (!pickinfo || pickinfo.distance > result.distance) {
                                pickinfo = result;
                                pickinfo.triangleIndex = i / 3;
                                pickinfo.subMeshIndex = subMeshIndex;
                                var tdir = helpVec3_7;
                                egret3d.Vector3.copy(ray.direction, tdir);
                                egret3d.Vector3.scale(tdir, result.distance);
                                egret3d.Vector3.add(ray.origin, tdir, pickinfo.position);
                            }
                        }
                    }
                }
                subMeshIndex++;
            }
            return pickinfo;
        };
        Object.defineProperty(SkinnedMeshRenderer.prototype, "materials", {
            /**
             * material list
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 材质数组
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._materials;
            },
            set: function (value) {
                if (value !== this._materials) {
                    for (var _i = 0, value_5 = value; _i < value_5.length; _i++) {
                        var material = value_5[_i];
                        this._materials.push(material);
                    }
                }
                paper.EventPool.dispatchEvent("materials" /* Materials */, this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "bones", {
            /**
             * 骨骼列表
             *
             */
            get: function () {
                return this._bones;
            },
            set: function (value) {
                if (value !== this._bones) {
                    this._bones.length = 0;
                    for (var _i = 0, value_6 = value; _i < value_6.length; _i++) {
                        var bone = value_6[_i];
                        this._bones.push(bone);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "boneBuffer", {
            /**
             *
             */
            get: function () {
                return this.cacheData || this._skeletonMatrixData;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        SkinnedMeshRenderer.dataCaches = [];
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "_materials", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "_mesh", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "_bones", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "rootBone", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "center", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "size", void 0);
        SkinnedMeshRenderer = __decorate([
            paper.disallowMultipleComponent
        ], SkinnedMeshRenderer);
        return SkinnedMeshRenderer;
    }(paper.BaseRenderer));
    egret3d.SkinnedMeshRenderer = SkinnedMeshRenderer;
    __reflect(SkinnedMeshRenderer.prototype, "egret3d.SkinnedMeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpVec3_3 = new egret3d.Vector3();
    var helpVec3_4 = new egret3d.Vector3();
    var _attributes = [
        "POSITION" /* POSITION */,
        "COLOR_0" /* COLOR_0 */,
        "TEXCOORD_0" /* TEXCOORD_0 */,
    ];
    /**
     * Trail Renderer Component
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 拖尾渲染组件
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var TrailRenderer = (function (_super) {
        __extends(TrailRenderer, _super);
        /**
         *
         */
        function TrailRenderer() {
            var _this = _super.call(this) || this;
            /**
             * extend direction
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 拖尾延伸方向。
             * true为单方向延伸，false为双向延伸
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.extenedOneSide = true;
            _this._vertexCount = 24;
            /**
             * material color
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 材质颜色
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.color = new egret3d.Color(1, 1, 1, 1);
            /**
             * set trail width
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置拖尾宽度
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.width = 1.0;
            /**
             * set trail speed（0 - 1）
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置拖尾速度，调节拖尾长短（0-1）
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.speed = 0.5;
            /**
             * look at camera
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 拖尾是否朝向相机
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.lookAtCamera = false;
            /**
             *
             */
            _this.$active = false;
            _this._reInit = false;
            _this._material = new egret3d.Material();
            _this._material.setShader(egret3d.DefaultShaders.DIFFUSE);
            return _this;
        }
        Object.defineProperty(TrailRenderer.prototype, "material", {
            /**
             * trail material
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 拖尾的材质
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._material;
            },
            set: function (material) {
                this._material = material;
                paper.EventPool.dispatchEvent("material" /* Meterial */, this);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        TrailRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this._buildMesh(this._vertexCount);
        };
        /**
         * @inheritDoc
         */
        TrailRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                this._mesh.dispose();
            }
            this._mesh = null;
        };
        /**
         *
         */
        TrailRenderer.prototype.update = function (delta) {
            if (!this.$active)
                return;
            if (this._reInit) {
                this._buildData(this._vertexCount);
                this._reInit = false;
            }
            var camera = egret3d.Camera.main;
            var targetPosition = this.gameObject.transform.getPosition();
            // set first stick's up direction
            if (this.lookAtCamera) {
                if (camera) {
                    var cameraPosition = egret3d.Vector3.copy(camera.gameObject.transform.getPosition(), helpVec3_1);
                    var cameraDirection = egret3d.Vector3.subtract(cameraPosition, this._sticks[0].location, helpVec3_2);
                    egret3d.Vector3.normalize(cameraDirection);
                    var direction = egret3d.Vector3.subtract(targetPosition, this._sticks[0].location, helpVec3_3);
                    egret3d.Vector3.normalize(direction);
                    egret3d.Vector3.cross(cameraDirection, direction, this._sticks[0].up);
                    egret3d.Vector3.scale(this._sticks[0].up, this.width);
                }
            }
            else {
                this.gameObject.transform.getUp(this._sticks[0].up);
                egret3d.Vector3.scale(this._sticks[0].up, this.width);
            }
            // set first stick's position
            egret3d.Vector3.copy(targetPosition, this._sticks[0].location);
            // lerp set other sticks' position
            var length = this._sticks.length;
            for (var i = 1; i < length; i++) {
                egret3d.Vector3.lerp(this._sticks[i].location, this._sticks[i - 1].location, this.speed, this._sticks[i].location);
            }
            // set other sticks's updir
            if (this.lookAtCamera) {
                if (camera) {
                    var cameraPosition = egret3d.Vector3.copy(camera.gameObject.transform.getPosition(), helpVec3_1);
                    for (var i = 1; i < length; i++) {
                        var cameraDirection = egret3d.Vector3.subtract(cameraPosition, this._sticks[i].location, helpVec3_1);
                        egret3d.Vector3.normalize(cameraDirection);
                        var moveDirection = egret3d.Vector3.subtract(this._sticks[i - 1].location, this._sticks[i].location, helpVec3_2);
                        egret3d.Vector3.normalize(moveDirection);
                        egret3d.Vector3.cross(cameraDirection, moveDirection, this._sticks[i].up);
                        egret3d.Vector3.scale(this._sticks[i].up, this.width);
                    }
                }
            }
            else {
                for (var i = 1; i < length; i++) {
                    egret3d.Vector3.lerp(this._sticks[i].up, this._sticks[i - 1].up, this.speed, this._sticks[i].up);
                }
            }
            this._updateTrailData();
        };
        TrailRenderer.prototype._buildMesh = function (vertexcount) {
            this._mesh = new egret3d.Mesh(vertexcount, (vertexcount / 2 - 1) * 6, _attributes, 2 /* Dynamic */);
        };
        TrailRenderer.prototype._buildData = function (vertexCount) {
            var length = vertexCount / 2;
            // create sticks
            this._sticks = [];
            var position = this.gameObject.transform.getPosition();
            var up = new egret3d.Vector3();
            this.gameObject.transform.getUp(up);
            egret3d.Vector3.scale(up, this.width);
            for (var i = 0; i < length; i++) {
                var stick = new TrailStick();
                egret3d.Vector3.copy(position, stick.location);
                egret3d.Vector3.copy(up, stick.up);
                this._sticks.push(stick);
            }
            for (var i = 0; i < length; i++) {
                var iD = i * 2;
                var u = i / (length - 1);
                this._mesh.setAttribute(iD, "POSITION" /* POSITION */, 0, 0, 0, 0);
                this._mesh.setAttribute(iD, "COLOR_0" /* COLOR_0 */, 0, this.color.r, this.color.g, this.color.b, this.color.a);
                this._mesh.setAttribute(iD, "TEXCOORD_0" /* TEXCOORD_0 */, 0, u, 0);
                this._mesh.setAttribute(iD + 1, "POSITION" /* POSITION */, 0, 0, 0, 0);
                this._mesh.setAttribute(iD + 1, "COLOR_0" /* COLOR_0 */, 0, this.color.r, this.color.g, this.color.b, this.color.a);
                this._mesh.setAttribute(iD + 1, "TEXCOORD_0" /* TEXCOORD_0 */, 0, u, 1);
            }
            var indices = this._mesh.getIndices();
            for (var k = 0; k < length - 1; k++) {
                var iD = k * 6;
                var a = k * 2;
                var b = (k + 1) * 2;
                var c = k * 2 + 1;
                var d = (k + 1) * 2 + 1;
                indices[iD + 0] = a;
                indices[iD + 1] = b;
                indices[iD + 2] = c;
                indices[iD + 3] = c;
                indices[iD + 4] = b;
                indices[iD + 5] = d;
            }
            this._mesh.uploadSubVertexBuffer(_attributes);
            this._mesh.uploadSubIndexBuffer();
        };
        TrailRenderer.prototype._updateTrailData = function () {
            var length = this._vertexCount / 2;
            var pos, up;
            if (this.extenedOneSide) {
                for (var i = 0; i < length; i++) {
                    var iD = i * 2;
                    pos = this._sticks[i].location;
                    up = this._sticks[i].up;
                    this._mesh.setAttribute(iD, "POSITION" /* POSITION */, 0, pos.x, pos.y, pos.z);
                    this._mesh.setAttribute(iD + 1, "POSITION" /* POSITION */, 0, pos.x + up.x, pos.y + up.y, pos.z + up.z);
                }
            }
            else {
                for (var i = 0; i < length; i++) {
                    var iD = i * 2;
                    pos = this._sticks[i].location;
                    up = this._sticks[i].up;
                    this._mesh.setAttribute(iD, "POSITION" /* POSITION */, 0, pos.x, pos.y, pos.z);
                    this._mesh.setAttribute(iD + 1, "POSITION" /* POSITION */, 0, pos.x + up.x, pos.y + up.y, pos.z + up.z);
                }
            }
            this._mesh.uploadSubVertexBuffer("POSITION" /* POSITION */);
        };
        __decorate([
            paper.serializedField
        ], TrailRenderer.prototype, "extenedOneSide", void 0);
        __decorate([
            paper.serializedField
        ], TrailRenderer.prototype, "_material", void 0);
        __decorate([
            paper.serializedField
        ], TrailRenderer.prototype, "color", void 0);
        __decorate([
            paper.serializedField
        ], TrailRenderer.prototype, "width", void 0);
        __decorate([
            paper.serializedField
        ], TrailRenderer.prototype, "speed", void 0);
        __decorate([
            paper.serializedField
        ], TrailRenderer.prototype, "lookAtCamera", void 0);
        TrailRenderer = __decorate([
            paper.disallowMultipleComponent
        ], TrailRenderer);
        return TrailRenderer;
    }(paper.BaseRenderer));
    egret3d.TrailRenderer = TrailRenderer;
    __reflect(TrailRenderer.prototype, "egret3d.TrailRenderer");
    /**
     * stick
     */
    var TrailStick = (function () {
        function TrailStick() {
            this.location = new egret3d.Vector3(0, 0, 0);
            this.up = new egret3d.Vector3(0, 1, 0);
        }
        return TrailStick;
    }());
    __reflect(TrailStick.prototype, "TrailStick");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * TrailRender系统
     */
    var TrailRendererSystem = (function (_super) {
        __extends(TrailRendererSystem, _super);
        function TrailRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: egret3d.TrailRenderer,
                    listeners: [
                        { type: "materials" /* Materials */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } }
                    ]
                }
            ];
            _this._matrix = new egret3d.Matrix();
            _this._drawCalls = _this._globalGameObject.getComponent(egret3d.DrawCalls) || _this._globalGameObject.addComponent(egret3d.DrawCalls);
            return _this;
        }
        TrailRendererSystem.prototype._updateDrawCalls = function (gameObject) {
            if (!this._enabled || !this._hasGameObject(gameObject)) {
                return;
            }
            var renderer = gameObject.renderer;
            if (!renderer.material) {
                return;
            }
            this._drawCalls.renderers.push(renderer);
            //
            var subMeshIndex = 0;
            for (var _i = 0, _a = renderer._mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var drawCall = {
                    renderer: renderer,
                    matrix: this._matrix,
                    subMeshIndex: subMeshIndex++,
                    mesh: renderer._mesh,
                    material: renderer.material,
                    frustumTest: false,
                    zdist: -1,
                    disable: false,
                };
                this._drawCalls.drawCalls.push(drawCall);
            }
        };
        TrailRendererSystem.prototype.onEnable = function () {
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var renderer = _a[_i];
                this._updateDrawCalls(renderer.gameObject);
            }
        };
        TrailRendererSystem.prototype.onAddGameObject = function (gameObject) {
            this._updateDrawCalls(gameObject);
        };
        TrailRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            if (!this._enabled) {
                return;
            }
            this._drawCalls.removeDrawCalls(gameObject.renderer);
        };
        TrailRendererSystem.prototype.onUpdate = function () {
            var deltaTime = paper.Time.deltaTime;
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                component.update(deltaTime);
            }
        };
        TrailRendererSystem.prototype.onDisable = function () {
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var renderer = _a[_i];
                this._drawCalls.removeDrawCalls(renderer);
            }
        };
        return TrailRendererSystem;
    }(paper.BaseSystem));
    egret3d.TrailRendererSystem = TrailRendererSystem;
    __reflect(TrailRendererSystem.prototype, "egret3d.TrailRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * TODO 需要完善
     */
    var SkinnedMeshRendererSystem = (function (_super) {
        __extends(SkinnedMeshRendererSystem, _super);
        function SkinnedMeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: egret3d.SkinnedMeshRenderer,
                    listeners: [
                        { type: "mesh" /* Mesh */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } },
                        { type: "materials" /* Materials */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } },
                    ]
                }
            ];
            _this._drawCalls = _this._globalGameObject.getComponent(egret3d.DrawCalls) || _this._globalGameObject.addComponent(egret3d.DrawCalls);
            return _this;
        }
        SkinnedMeshRendererSystem.prototype._updateDrawCalls = function (gameObject) {
            if (!this._enabled || !this._hasGameObject(gameObject)) {
                return;
            }
            var renderer = gameObject.renderer;
            if (!renderer.mesh || renderer.materials.length === 0) {
                return;
            }
            //
            this._drawCalls.removeDrawCalls(renderer);
            //
            this._drawCalls.renderers.push(renderer);
            //
            var subMeshIndex = 0;
            for (var _i = 0, _a = renderer.mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var drawCall = {
                    renderer: renderer,
                    subMeshIndex: subMeshIndex++,
                    mesh: renderer.mesh,
                    material: renderer.materials[primitive.material || 0],
                    frustumTest: false,
                    zdist: -1,
                    boneData: renderer.boneBuffer,
                    disable: false,
                };
                this._drawCalls.drawCalls.push(drawCall);
            }
        };
        SkinnedMeshRendererSystem.prototype.onEnable = function () {
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var renderer = _a[_i];
                this._updateDrawCalls(renderer.gameObject);
            }
        };
        SkinnedMeshRendererSystem.prototype.onAddGameObject = function (gameObject) {
            this._updateDrawCalls(gameObject);
        };
        SkinnedMeshRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            if (!this._enabled) {
                return;
            }
            this._drawCalls.removeDrawCalls(gameObject.renderer);
        };
        SkinnedMeshRendererSystem.prototype.onUpdate = function () {
            // TODO
        };
        SkinnedMeshRendererSystem.prototype.onDisable = function () {
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var renderer = _a[_i];
                this._drawCalls.removeDrawCalls(renderer);
            }
        };
        return SkinnedMeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.SkinnedMeshRendererSystem = SkinnedMeshRendererSystem;
    __reflect(SkinnedMeshRendererSystem.prototype, "egret3d.SkinnedMeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DrawCalls = (function (_super) {
        __extends(DrawCalls, _super);
        function DrawCalls() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 参与渲染的渲染器列表。
             */
            _this.renderers = [];
            /**
             * 所有的 draw call 列表。
             */
            _this.drawCalls = [];
            return _this;
        }
        // public readonly finalDrawCalls: DrawCall[] = [];//TODO,裁切开启后，放到这里，排序会少算一些
        DrawCalls.prototype._sort = function (a, b) {
            if (a.material.renderQueue === b.material.renderQueue) {
                return b.zdist - a.zdist;
            }
            else {
                return a.material.renderQueue - b.material.renderQueue;
            }
        };
        DrawCalls.prototype.sortAfterFrustumCulling = function (camera) {
            // this.finalDrawCalls.length = 0;
            var cameraPos = camera.gameObject.transform.getPosition();
            //
            for (var _i = 0, _a = this.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                drawCall.disable = (drawCall.frustumTest && !camera.testFrustumCulling(drawCall.renderer.gameObject.transform));
                if (!drawCall.disable) {
                    if (drawCall.material.renderQueue >= egret3d.RenderQueue.Transparent) {
                        //透明物体需要排序
                        var objPos = drawCall.renderer.gameObject.transform.getPosition();
                        drawCall.zdist = objPos.getDistance(cameraPos);
                    }
                    // this.finalDrawCalls.push(drawCall);
                }
            }
            this.drawCalls.sort(this._sort);
            // this.finalDrawCalls.sort(this._sort);
        };
        /**
         *
         */
        DrawCalls.prototype.sort = function () {
            this.drawCalls.sort(this._sort);
        };
        /**
         * 移除指定渲染器的 draw call 列表。
         * @param renderer
         */
        DrawCalls.prototype.removeDrawCalls = function (renderer) {
            var index = this.renderers.indexOf(renderer);
            if (index < 0) {
                return;
            }
            var i = this.drawCalls.length;
            while (i--) {
                if (this.drawCalls[i].renderer === renderer) {
                    this.drawCalls.splice(i, 1);
                }
            }
            this.renderers.splice(index, 1);
        };
        /**
         * 获取指定渲染器的 draw call 列表。
         * @param renderer
         */
        DrawCalls.prototype.getDrawCalls = function (renderer) {
            if (this.renderers.indexOf(renderer) < 0) {
                return null;
            }
            this.drawCalls.filter(function (drawCall) { return drawCall.renderer === renderer; });
        };
        /**
         * 指定渲染器是否生成了 draw call 列表。
         * @param renderer
         */
        DrawCalls.prototype.hasDrawCalls = function (renderer) {
            return this.renderers.indexOf(renderer) >= 0;
        };
        return DrawCalls;
    }(paper.SingletonComponent));
    egret3d.DrawCalls = DrawCalls;
    __reflect(DrawCalls.prototype, "egret3d.DrawCalls");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var BoneBlendLayer = (function () {
        function BoneBlendLayer() {
            this.dirty = 0;
            this.layer = 0;
            this.leftWeight = 0;
            this.layerWeight = 0;
            this.blendWeight = 0;
            this.target = null;
        }
        BoneBlendLayer.prototype.update = function (animationState) {
            var animationLayer = animationState.layer;
            var animationWeight = animationState._globalWeight;
            if (this.dirty > 0) {
                if (this.leftWeight > 0.0) {
                    if (animationState.additive && this.layer !== animationLayer) {
                        if (this.layerWeight >= this.leftWeight) {
                            this.leftWeight = 0.0;
                            return false;
                        }
                        this.layer = animationLayer;
                        this.leftWeight -= this.layerWeight;
                        this.layerWeight = animationWeight * this.leftWeight;
                    }
                    animationWeight *= this.leftWeight;
                    this.dirty++;
                    this.blendWeight = animationWeight;
                    return true;
                }
                return false;
            }
            this.dirty++;
            this.layer = animationLayer;
            this.leftWeight = 1.0;
            this.layerWeight = animationWeight;
            this.blendWeight = animationWeight;
        };
        return BoneBlendLayer;
    }());
    egret3d.BoneBlendLayer = BoneBlendLayer;
    __reflect(BoneBlendLayer.prototype, "egret3d.BoneBlendLayer");
    /**
     *
     */
    var AnimationChannel = (function () {
        function AnimationChannel() {
            this.update = null;
        }
        return AnimationChannel;
    }());
    __reflect(AnimationChannel.prototype, "AnimationChannel");
    /**
     * 动画混合节点。
     */
    var BlendNode = (function () {
        function BlendNode() {
            /**
             * @private
             */
            this.additive = false;
            /**
             * 动画混合模式。（根节点有效）
             */
            this.layer = 0;
            /**
             * 节点权重。
             */
            this.weight = 1.0;
            /**
             * 淡入淡出的时间。
             */
            this.fadeTime = 1.0;
            /**
             * 父节点。
             */
            this.parent = null;
            /**
             * -1: Fade in, 0: Fade complete, 1: Fade out;
             * @internal
             */
            this._fadeState = -1;
            /**
             * -1: Fade start, 0: Fading, 1: Fade complete;
             * @internal
             */
            this._subFadeState = -1;
            /**
             * 累计权重。
             * @internal
             */
            this._globalWeight = 0.0;
            /**
             * 融合进度。
             *
             */
            this._fadeProgress = 0.0;
            /**
             * 全局融合时间标记。
             */
            this._fadeTimeStart = 0.0;
        }
        BlendNode.prototype._onFadeStateChange = function () {
        };
        BlendNode.prototype.update = function (globalTime) {
            var isFadeOut = this._fadeState > 0;
            var localFadeTime = globalTime - this._fadeTimeStart;
            if (this._subFadeState < 0) {
                this._subFadeState = 0;
                this._onFadeStateChange();
            }
            if (localFadeTime >= this.fadeTime) {
                this._subFadeState = 1;
                this._fadeProgress = isFadeOut ? 0.0 : 1.0;
            }
            else if (localFadeTime > 0.0) {
                this._fadeProgress = isFadeOut ? (1.0 - localFadeTime / this.fadeTime) : (localFadeTime / this.fadeTime);
            }
            else {
                this._fadeProgress = isFadeOut ? 1.0 : 0.0;
            }
            if (this._subFadeState > 0) {
                if (!isFadeOut) {
                    this._fadeState = 0;
                    this._onFadeStateChange();
                }
            }
            this._globalWeight = this.weight * this._fadeProgress;
            if (this.parent) {
                this._globalWeight *= this.parent._globalWeight;
            }
        };
        BlendNode.prototype.fadeOut = function (fadeTime) {
            var globalTime = paper.Time.time;
            var localFadeTime = globalTime - this._fadeTimeStart;
            if (this._fadeState > 0) {
                if (fadeTime > this.fadeTime - localFadeTime) {
                    return;
                }
            }
            else {
                this._fadeState = 1;
                this._subFadeState = -1;
                if (fadeTime <= 0.0 || this._fadeProgress <= 0.0) {
                    this._fadeProgress = 0.000001; // Modify fade progress to different value.
                }
            }
            this.fadeTime = this._fadeProgress > 0.000001 ? fadeTime / this._fadeProgress : 0.0;
            this._fadeTimeStart = globalTime - this.fadeTime * (1.0 - this._fadeProgress);
        };
        return BlendNode;
    }());
    egret3d.BlendNode = BlendNode;
    __reflect(BlendNode.prototype, "egret3d.BlendNode");
    /**
     * 动画混合树节点。
     */
    var BlendTree = (function (_super) {
        __extends(BlendTree, _super);
        function BlendTree() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._blendNodes = [];
            return _this;
        }
        return BlendTree;
    }(BlendNode));
    egret3d.BlendTree = BlendTree;
    __reflect(BlendTree.prototype, "egret3d.BlendTree");
    /**
     * 动画状态。
     */
    var AnimationState = (function (_super) {
        __extends(AnimationState, _super);
        function AnimationState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.layer = 0;
            /**
             * 动画总播放次数。
             */
            _this.playTimes = 0;
            /**
             * 动画当前播放次数。
             */
            _this.currentPlayTimes = 0;
            /**
             * 播放速度。
             */
            _this.timeScale = 1.0;
            /**
             * @private
             */
            _this.animationAsset = null;
            /**
             * 播放的动画数据。
             */
            _this.animation = null;
            /**
             * 播放的动画剪辑。
             */
            _this.animationClip = null;
            /**
             * 是否允许播放。
             */
            _this._isPlaying = true;
            /**
             * 播放状态。
             * -1: start, 0: playing, 1: complete;
             */
            _this._playState = -1;
            /**
             * 帧率。
             */
            _this._frameRate = 0;
            /**
             * 起始帧。
             */
            _this._frameStart = 0;
            /**
             * 总帧数。
             */
            _this._frameCount = 0;
            /**
             * 全局播放时间标记。
             */
            _this._playTimeStart = 0.0;
            /**
             * 本地播放时间。
             */
            _this._playTime = 0.0;
            /**
             * 帧插值进度。
             */
            _this._frameProgress = 0.0;
            _this._animationComponent = null;
            // TODO
            _this._channels = [];
            // TODO
            _this._retargetBoneIndices = [];
            _this._delta = [];
            _this._frameBuffer = null;
            _this._frameOffset = -1;
            _this._nextFrameOffset = -1;
            _this._frameOffsets = null;
            return _this;
        }
        AnimationState.prototype._onArriveAtFrame = function () {
        };
        AnimationState.prototype._onUpdateFrame = function () {
            var delta = this._delta;
            var result = this._animationComponent._skinnedMeshRenderer._skeletonMatrixData;
            var boneBlendLayers = this._animationComponent._boneBlendLayers;
            var frameBuffer = this._frameBuffer;
            for (var i = 0, l = this._retargetBoneIndices.length; i < l; ++i) {
                var boneIndex = this._retargetBoneIndices[i];
                if (boneIndex < 0) {
                    continue;
                }
                var poseBoneOffsetA = i * 7;
                var poseBoneOffsetC = boneIndex * 8;
                var frameOffset = this._frameOffset + poseBoneOffsetA;
                var boneBlendNode = boneBlendLayers[boneIndex];
                if (boneBlendNode.update(this)) {
                    for (var j = 0; j < 7; ++j) {
                        result[poseBoneOffsetC + j] = frameBuffer[frameOffset + j];
                    }
                    result[poseBoneOffsetC + 7] = 1.0;
                }
            }
        };
        AnimationState.prototype._onUpdateTranslation = function (channel) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            var transform = channel.component;
            if (this._playTime <= inputBuffer[0]) {
            }
            else if (this._playTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (this._playTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var offset = frameIndex * 3;
            var x = outputBuffer[offset];
            var y = outputBuffer[offset + 1];
            var z = outputBuffer[offset + 2];
            if (isInterpolation) {
                var nextIndex = offset + 3;
                var progress = (this._playTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                transform.setLocalPosition(x + (outputBuffer[nextIndex] - x) * progress, y + (outputBuffer[nextIndex + 1] - y) * progress, z + (outputBuffer[nextIndex + 2] - z) * progress);
            }
            else {
                transform.setLocalPosition(x, y, z);
            }
        };
        AnimationState.prototype._onUpdateRotation = function (channel) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            var transform = channel.component;
            if (this._playTime <= inputBuffer[0]) {
            }
            else if (this._playTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (this._playTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var offset = frameIndex * 4;
            var x = outputBuffer[offset];
            var y = outputBuffer[offset + 1];
            var z = outputBuffer[offset + 2];
            var w = outputBuffer[offset + 3];
            if (isInterpolation) {
                var nextIndex = offset + 4;
                var progress = (this._playTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                transform.setLocalRotation(x + (outputBuffer[nextIndex] - x) * progress, y + (outputBuffer[nextIndex + 1] - y) * progress, z + (outputBuffer[nextIndex + 2] - z) * progress, w + (outputBuffer[nextIndex + 3] - w) * progress);
            }
            else {
                transform.setLocalRotation(x, y, z, w);
            }
        };
        AnimationState.prototype._onUpdateScale = function (channel) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            var transform = channel.component;
            if (this._playTime <= inputBuffer[0]) {
            }
            else if (this._playTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (this._playTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var offset = frameIndex * 3;
            var x = outputBuffer[offset];
            var y = outputBuffer[offset + 1];
            var z = outputBuffer[offset + 2];
            if (isInterpolation) {
                var nextIndex = offset + 3;
                var progress = (this._playTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                transform.setLocalScale(x + (outputBuffer[nextIndex] - x) * progress, y + (outputBuffer[nextIndex + 1] - y) * progress, z + (outputBuffer[nextIndex + 2] - z) * progress);
            }
            else {
                transform.setLocalScale(x, y, z);
            }
        };
        AnimationState.prototype._onUpdateActive = function (channel) {
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            var transform = channel.component;
            if (this._playTime <= inputBuffer[0]) {
            }
            else if (this._playTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (this._playTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var offset = frameIndex * 3;
            transform.gameObject.activeSelf = outputBuffer[offset] !== 0;
        };
        /**
         *
         */
        AnimationState.prototype.initialize = function (animationComponent, animationAsset, animationClip) {
            var globalTime = paper.Time.time;
            var assetConfig = animationAsset.config;
            //
            this.animationAsset = animationAsset;
            this.animationClip = animationClip;
            this.animation = assetConfig.animations[0]; // TODO 动画数据暂不合并。
            //
            var paperAnimation = this.animation.extensions.paper;
            var dataAccessor = this.animationAsset.getAccessor(paperAnimation.data);
            //
            this._frameRate = paperAnimation.frameRate;
            this._frameStart = Math.floor(this.animationClip.position * paperAnimation.frameRate);
            this._frameCount = Math.floor(this.animationClip.duration * paperAnimation.frameRate); // ceil.
            this._fadeTimeStart = globalTime;
            this._playTimeStart = globalTime;
            this._animationComponent = animationComponent;
            //
            var skinnedMeshRenderer = this._animationComponent._skinnedMeshRenderer;
            if (skinnedMeshRenderer) {
                // Retargeting.
                var skeletonRetarget = skinnedMeshRenderer._retargetBoneNames || skinnedMeshRenderer.bones.map(function (bone) { return bone.gameObject.name; });
                var animationRetarget = paperAnimation.retarget ? paperAnimation.retarget.joints : paperAnimation.joints;
                //
                this._delta.length = skeletonRetarget.length * 7;
                this._frameBuffer = this.animationAsset.createTypeArrayFromAccessor(dataAccessor);
                this._frameOffsets = this.animation.extensions.paper.frames;
                for (var _i = 0, animationRetarget_1 = animationRetarget; _i < animationRetarget_1.length; _i++) {
                    var boneName = animationRetarget_1[_i];
                    var index = skeletonRetarget.indexOf(boneName);
                    this._retargetBoneIndices.push(index);
                }
                // if (assetConfig.extensions.paper.skeletons) {
                //     for (const skeleton of assetConfig.extensions.paper.skeletons) {
                //         if (skeleton.name === this.animationAsset.name) {
                //             this._skeleton = skeleton;
                //             if (this._skeleton && !this._skeleton.do) {
                //                 const tPose = this._skeleton.tPose;
                //                 let iA = 0;
                //                 let iB = 0;
                //                 for (let i = 0; i < skeletonRetarget.length; i++) {
                //                     helpQuaternionA.x = tPose[iA++];
                //                     helpQuaternionA.y = tPose[iA++];
                //                     helpQuaternionA.z = tPose[iA++];
                //                     helpQuaternionA.w = tPose[iA++];
                //                     helpVec3A.x = tPose[iA++];
                //                     helpVec3A.y = tPose[iA++];
                //                     helpVec3A.z = tPose[iA++];
                //                     Quaternion.inverse(helpQuaternionA);
                //                     Quaternion.transformVector3(helpQuaternionA, helpVec3A, helpVec3A);
                //                     helpVec3A.x *= -1;
                //                     helpVec3A.y *= -1;
                //                     helpVec3A.z *= -1;
                //                     tPose[iB++] = helpQuaternionA.x;
                //                     tPose[iB++] = helpQuaternionA.y;
                //                     tPose[iB++] = helpQuaternionA.z;
                //                     tPose[iB++] = helpQuaternionA.w;
                //                     tPose[iB++] = helpVec3A.x;
                //                     tPose[iB++] = helpVec3A.y;
                //                     tPose[iB++] = helpVec3A.z;
                //                 }
                //             }
                //         }
                //     }
                // }
            }
            else if (this.animation.channels) {
                var rootGameObject = this._animationComponent.gameObject;
                var transforms = rootGameObject.transform.getAllChildren();
                var gameObjects = {};
                gameObjects[rootGameObject.name] = rootGameObject;
                for (var _a = 0, transforms_1 = transforms; _a < transforms_1.length; _a++) {
                    var gameObject = transforms_1[_a].gameObject;
                    gameObjects[gameObject.name] = gameObject;
                }
                for (var _b = 0, _c = this.animation.channels; _b < _c.length; _b++) {
                    var glTFChannel = _c[_b];
                    var node = this.animationAsset.getNode(glTFChannel.target.node || 0);
                    var gameObject = gameObjects[node.name];
                    if (!gameObject) {
                        continue;
                    }
                    var channel = new AnimationChannel();
                    channel.glTFChannel = glTFChannel;
                    channel.glTFSampler = this.animation.samplers[glTFChannel.sampler];
                    channel.gameObject = gameObject;
                    channel.component = gameObject.transform; // TODO 更多组件
                    channel.inputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.input));
                    channel.outputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.output));
                    switch (channel.glTFChannel.target.path) {
                        case "translation":
                            channel.update = this._onUpdateTranslation.bind(this);
                            break;
                        case "rotation":
                            channel.update = this._onUpdateRotation.bind(this);
                            break;
                        case "scale":
                            channel.update = this._onUpdateScale.bind(this);
                            break;
                        case "weights":
                            // TODO
                            break;
                        case "custom":
                            switch (channel.glTFChannel.extensions.paper.type) {
                                case "paper.GameObject":
                                    switch (channel.glTFChannel.extensions.paper.property) {
                                        case "activeSelf":
                                            channel.update = this._onUpdateActive.bind(this);
                                            break;
                                    }
                                    break;
                            }
                            break;
                        default:
                            console.warn("Unknown animation channel.", channel.glTFChannel.target.path);
                            break;
                    }
                    this._channels.push(channel);
                }
            }
        };
        /**
         *
         */
        AnimationState.prototype.update = function (globalTime) {
            _super.prototype.update.call(this, globalTime);
            var prevPlayTimes = this.currentPlayTimes;
            var prevPlayState = this._playState;
            var timeScale = this.timeScale * this._animationComponent.timeScale;
            var timeScaleR = timeScale === 0.0 ? 0.0 : 1.0 / timeScale;
            var position = this.animationClip.position;
            var duration = this.animationClip.duration;
            var totalTime = this.playTimes * duration;
            var localPlayTime = (globalTime - this._playTimeStart) * timeScaleR;
            var currentTime = 0.0;
            if (this.playTimes > 0 && (timeScale >= 0.0 ? localPlayTime >= totalTime : localPlayTime <= 0.0)) {
                if (this._playState <= 0 && this._isPlaying) {
                    this._playState = 1;
                }
                this.currentPlayTimes = this.playTimes;
                if (localPlayTime >= totalTime) {
                    currentTime = duration + 0.000001; // Precision problem.
                }
                else {
                    currentTime = 0.0;
                }
            }
            else {
                if (this._playState !== 0 && this._isPlaying) {
                    this._playState = 0;
                }
                if (localPlayTime < 0.0) {
                    localPlayTime = -localPlayTime;
                    this.currentPlayTimes = Math.floor(localPlayTime / duration);
                    currentTime = duration - (localPlayTime % duration);
                }
                else {
                    this.currentPlayTimes = Math.floor(localPlayTime / duration);
                    currentTime = localPlayTime % duration;
                }
            }
            currentTime += position;
            this._playTime = currentTime;
            if (this._channels.length > 0) {
                for (var _i = 0, _a = this._channels; _i < _a.length; _i++) {
                    var channel = _a[_i];
                    if (channel.update) {
                        channel.update(channel);
                    }
                }
            }
            else if (this._animationComponent._skinnedMeshRenderer) {
                // Clear frame flag when timeline start or loopComplete.
                if ((prevPlayState < 0 && this._playState !== prevPlayState) ||
                    (this._playState <= 0 && this.currentPlayTimes !== prevPlayTimes)) {
                    this._frameOffset = -1;
                }
                if (this._frameCount > 1) {
                    var frameIndexF = this._playTime * this._frameRate;
                    var frameIndex = Math.min(Math.floor(frameIndexF), this._frameStart + this._frameCount - 1);
                    var frameOffset = this._frameOffsets[frameIndex];
                    if (this._frameOffset !== frameOffset) {
                        this._frameOffset = frameOffset;
                        this._nextFrameOffset = this._frameOffsets[frameIndex + 1];
                        this._onArriveAtFrame();
                    }
                    this._frameProgress = frameIndexF - frameIndex;
                    this._onUpdateFrame();
                }
                else if (this._frameOffset < 0) {
                    this._frameOffset = this._frameOffsets[0];
                    this._nextFrameOffset = -1;
                    this._onArriveAtFrame();
                }
            }
            if (prevPlayState !== this._playState && this._playState === 1) {
                this._animationComponent._dispatchEvent("complete", this);
                var animationNames = this._animationComponent._animationNames;
                if (animationNames.length > 0) {
                    var animationName = animationNames.shift();
                    this._animationComponent.play(animationName);
                }
            }
        };
        AnimationState.prototype.fateOut = function () {
            this._fadeState = 1;
            this._subFadeState = -1;
        };
        return AnimationState;
    }(BlendNode));
    egret3d.AnimationState = AnimationState;
    __reflect(AnimationState.prototype, "egret3d.AnimationState");
    /**
     * 动画组件。
     */
    var Animation = (function (_super) {
        __extends(Animation, _super);
        function Animation() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.autoPlay = false;
            /**
             * 动画速度。
             */
            _this.timeScale = 1.0;
            /**
             * 动画数据列表。
             */
            _this._animations = [];
            /**
             * 骨骼姿势列表。
             * @internal
             */
            _this._boneBlendLayers = [];
            /**
             * 混合节点列表。
             */
            _this._blendNodes = [];
            /**
             * @internal
             */
            _this._animationNames = [];
            /**
             * 最后一个播放的动画状态。
             * 当进行动画混合时，该值通常没有任何意义。
             */
            _this._lastAnimationState = null;
            /**
             * @internal
             */
            _this._skinnedMeshRenderer = null;
            return _this;
        }
        /**
         * @internal
         */
        Animation.prototype._dispatchEvent = function (type, animationState, eventObject) {
            for (var _i = 0, _a = this.gameObject.getComponents(paper.Behaviour, true); _i < _a.length; _i++) {
                var component = _a[_i];
                if (component.onAnimationEvent) {
                    component.onAnimationEvent(type, animationState, eventObject);
                }
            }
        };
        Animation.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            if (!this._skinnedMeshRenderer) {
                this._skinnedMeshRenderer = this.gameObject.getComponentsInChildren(egret3d.SkinnedMeshRenderer)[0];
                if (this._skinnedMeshRenderer) {
                    for (var _i = 0, _a = this._skinnedMeshRenderer.bones; _i < _a.length; _i++) {
                        var bone = _a[_i];
                        var boneBlendLayer = new BoneBlendLayer();
                        this._boneBlendLayers.push(boneBlendLayer);
                    }
                }
            }
        };
        /**
         *
         */
        Animation.prototype.update = function (globalTime) {
            var blendNodes = this._blendNodes;
            var blendNodeCount = blendNodes.length;
            if (blendNodeCount === 1) {
                var blendNode = blendNodes[0];
                if (blendNode._fadeState > 0 && blendNode._subFadeState > 0) {
                    blendNodes.length = 0;
                    if (this._lastAnimationState === blendNode) {
                        this._lastAnimationState = null;
                    }
                }
                else {
                    blendNode.update(globalTime);
                }
                // if (this._lastAnimationState) {
                //     const skeleton = this._lastAnimationState._skeleton;
                //     if (skeleton) {
                //         const result = this._skinnedMeshRenderer._skeletonMatrixData;
                //         const bones = this._skinnedMeshRenderer.bones;
                //         let iA = 0;
                //         let iB = 0;
                //         for (let i = 0, l = this._boneBlendLayers.length; i < l; ++i) {
                //             const boneBlendLayer = this._boneBlendLayers[i];
                //             boneBlendLayer.dirty = false;
                //             if (i < bones.length) {
                //                 const bone = bones[i];
                //                 const dir = helpVec3A;
                //                 const dirtran = helpVec3B;
                //                 helpQuaternionB.x = skeleton.tPose[iA++];
                //                 helpQuaternionB.y = skeleton.tPose[iA++];
                //                 helpQuaternionB.z = skeleton.tPose[iA++];
                //                 helpQuaternionB.w = skeleton.tPose[iA++];
                //                 dir.x = skeleton.tPose[iA++];
                //                 dir.x = skeleton.tPose[iA++];
                //                 dir.y = skeleton.tPose[iA++];
                //                 helpQuaternionA.x = result[iB];
                //                 helpQuaternionA.y = result[iB];
                //                 helpQuaternionA.z = result[iB];
                //                 helpQuaternionA.w = result[iB];
                //                 Quaternion.transformVector3(helpQuaternionA, dir, dirtran);
                //                 dirtran.x += result[iB];
                //                 dirtran.y += result[iB];
                //                 dirtran.z += result[iB];
                //                 iB++;
                //                 Quaternion.multiply(helpQuaternionA, helpQuaternionB, helpQuaternionC);
                //                 const position = helpVec3A;
                //                 const rotation = helpQuaternionA;
                //                 Vector3.add(bone.getPosition(), dirtran, position);
                //                 Quaternion.multiply(helpQuaternionC, bone.getRotation(), rotation);
                //                 bone.setPosition(position);
                //                 bone.setRotation(rotation);
                //             }
                //         }
                //     }
                // }
            }
            else if (blendNodeCount > 1) {
                for (var i = 0, r = 0; i < blendNodeCount; ++i) {
                    var blendNode = blendNodes[i];
                    if (blendNode._fadeState > 0 && blendNode._subFadeState > 0) {
                        r++;
                        if (this._lastAnimationState === blendNode) {
                            this._lastAnimationState = null;
                        }
                    }
                    else {
                        if (r > 0) {
                            blendNodes[i - r] = blendNode;
                        }
                        blendNode.update(globalTime);
                    }
                    if (i === blendNodeCount - 1 && r > 0) {
                        blendNodes.length -= r;
                        if (this._lastAnimationState === null && blendNodes.length > 0) {
                            var blendNode_1 = blendNodes[blendNodes.length - 1];
                            if (blendNode_1 instanceof AnimationState) {
                                this._lastAnimationState = blendNode_1;
                            }
                        }
                    }
                }
            }
            else {
            }
        };
        Animation.prototype.fadeIn = function (animationName, fadeTime, playTimes, layer, additive) {
            if (animationName === void 0) { animationName = null; }
            if (playTimes === void 0) { playTimes = -1; }
            if (layer === void 0) { layer = 0; }
            if (additive === void 0) { additive = false; }
            var animationAsset = null;
            var animationClip = null;
            for (var _i = 0, _a = this._animations; _i < _a.length; _i++) {
                var animation = _a[_i];
                animationAsset = animation;
                if (animationName) {
                    animationClip = animation.getAnimationClip(animationName);
                    if (animationClip !== null) {
                        break;
                    }
                }
                else {
                    animationClip = animation.getAnimationClip("");
                    break;
                }
            }
            if (!animationAsset || !animationClip) {
                return null;
            }
            for (var _b = 0, _c = this._blendNodes; _b < _c.length; _b++) {
                var blendNode = _c[_b];
                if ((!blendNode.parent && blendNode.layer === layer)) {
                    blendNode.fadeOut(fadeTime);
                }
            }
            var animationState = new AnimationState();
            animationState.initialize(this, animationAsset, animationClip);
            animationState.additive = additive;
            animationState.fadeTime = fadeTime;
            animationState.playTimes = playTimes < 0 ? (animationClip.playTimes || 0) : playTimes;
            // TODO sort by layer and blend tree.
            this._blendNodes.push(animationState);
            this._lastAnimationState = animationState;
            return animationState;
        };
        Animation.prototype.play = function (animationNameOrNames, playTimes) {
            if (animationNameOrNames === void 0) { animationNameOrNames = null; }
            if (playTimes === void 0) { playTimes = -1; }
            this._animationNames.length = 0;
            if (Array.isArray(animationNameOrNames)) {
                if (animationNameOrNames.length > 0) {
                    for (var _i = 0, animationNameOrNames_1 = animationNameOrNames; _i < animationNameOrNames_1.length; _i++) {
                        var animationName = animationNameOrNames_1[_i];
                        this._animationNames.push(animationName);
                    }
                    return this.fadeIn(this._animationNames.shift(), 0.0, playTimes);
                }
                return this.fadeIn(null, 0.0, playTimes);
            }
            return this.fadeIn(animationNameOrNames, 0.0, playTimes);
        };
        Object.defineProperty(Animation.prototype, "lastAnimationnName", {
            get: function () {
                return this._lastAnimationState ? this._lastAnimationState.animationClip.name : "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "animations", {
            get: function () {
                return this._animations;
            },
            /**
             * 动画数据列表。
             */
            set: function (animations) {
                for (var i = 0, l = animations.length; i < l; i++) {
                    this._animations[i] = animations[i];
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Animation.prototype, "autoPlay", void 0);
        __decorate([
            paper.serializedField
        ], Animation.prototype, "_animations", void 0);
        Animation = __decorate([
            paper.disallowMultipleComponent
        ], Animation);
        return Animation;
    }(paper.BaseComponent));
    egret3d.Animation = Animation;
    __reflect(Animation.prototype, "egret3d.Animation");
    var AnimationSystem = (function (_super) {
        __extends(AnimationSystem, _super);
        function AnimationSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: Animation
                }
            ];
            return _this;
        }
        AnimationSystem.prototype.onAddGameObject = function (gameObject) {
            var component = this._getComponent(gameObject, 0);
            if (component.autoPlay) {
                component.play();
            }
        };
        AnimationSystem.prototype.onUpdate = function () {
            var globalTime = paper.Time.time;
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                component.update(globalTime);
            }
        };
        return AnimationSystem;
    }(paper.BaseSystem));
    egret3d.AnimationSystem = AnimationSystem;
    __reflect(AnimationSystem.prototype, "egret3d.AnimationSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
        * @internal
        */
        function createBatchMesh(renderer, maxParticleCount) {
            var meshAttributes = [];
            var meshAttributesType = [];
            if (renderer._renderMode === 4 /* Mesh */) {
                var mesh = renderer.mesh;
                var orginIndexBuffer = mesh.getIndices();
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _i = 0, MeshShaderAttributeFormat_1 = particle.MeshShaderAttributeFormat; _i < MeshShaderAttributeFormat_1.length; _i++) {
                    var attribute = MeshShaderAttributeFormat_1[_i];
                    meshAttributes.push(attribute.key);
                    meshAttributesType.push(attribute.type);
                }
                var totalVertexCount = mesh.vertexCount * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = new egret3d.Mesh(totalVertexCount, totalIndexCount, totalIndexCount, meshAttributes, meshAttributesType, 2 /* Dynamic */);
                //
                var index = 0;
                //提前填充
                var orginPostionBuffer = mesh.getAttributes("POSITION" /* POSITION */);
                var orginUVBuffer = mesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                var orginColorBuffer = mesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var positionBuffer = batchMesh.getAttributes("POSITION" /* POSITION */);
                var colorBuffer = batchMesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var vector2Offset = i * 2;
                    var vector3Offset = i * 3;
                    var vector4Offset = i * 4;
                    var orginVertexIndex = i % mesh.vertexCount;
                    positionBuffer[vector3Offset] = orginPostionBuffer[orginVertexIndex * 3];
                    positionBuffer[vector3Offset + 1] = orginPostionBuffer[orginVertexIndex * 3 + 1];
                    positionBuffer[vector3Offset + 2] = orginPostionBuffer[orginVertexIndex * 3 + 2];
                    if (orginUVBuffer) {
                        uvBuffer[vector2Offset] = orginUVBuffer[orginVertexIndex * 2];
                        uvBuffer[vector2Offset + 1] = orginUVBuffer[orginVertexIndex * 2 + 1];
                    }
                    if (orginColorBuffer) {
                        colorBuffer[vector4Offset] = orginColorBuffer[orginVertexIndex * 4];
                        colorBuffer[vector4Offset + 1] = orginColorBuffer[orginVertexIndex * 4 + 1];
                        colorBuffer[vector4Offset + 2] = orginColorBuffer[orginVertexIndex * 4 + 2];
                        colorBuffer[vector4Offset + 3] = orginColorBuffer[orginVertexIndex * 4 + 3];
                    }
                    else {
                        colorBuffer[vector4Offset] = 1;
                        colorBuffer[vector4Offset + 1] = 1;
                        colorBuffer[vector4Offset + 2] = 1;
                        colorBuffer[vector4Offset + 3] = 1;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * mesh.vertexCount;
                    for (var j = 0; j < orginIndexBufferCount; j++) {
                        indexBuffer[index++] = orginIndexBuffer[j] + indexOffset;
                    }
                }
                return batchMesh;
            }
            else {
                var orginIndexBuffer = [0, 2, 1, 0, 3, 2];
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _a = 0, BillboardShaderAttributeFormat_1 = particle.BillboardShaderAttributeFormat; _a < BillboardShaderAttributeFormat_1.length; _a++) {
                    var attribute = BillboardShaderAttributeFormat_1[_a];
                    meshAttributes.push(attribute.key);
                    meshAttributesType.push(attribute.type);
                }
                var vertexStride = 4;
                var totalVertexCount = vertexStride * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = new egret3d.Mesh(totalVertexCount, totalIndexCount, totalIndexCount, meshAttributes, meshAttributesType, 2 /* Dynamic */);
                var cornerBuffer = batchMesh.getAttributes("CORNER" /* CORNER */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var orginVertexIndex = i % vertexStride;
                    var vector2Offset = i * 2;
                    switch (orginVertexIndex) {
                        case 0:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 1:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 2:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                        case 3:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * 6;
                    var firstVertex = i * vertexStride;
                    var secondVertex = firstVertex + 2;
                    indexBuffer[indexOffset + 0] = firstVertex;
                    indexBuffer[indexOffset + 1] = secondVertex;
                    indexBuffer[indexOffset + 2] = firstVertex + 1;
                    indexBuffer[indexOffset + 3] = firstVertex;
                    indexBuffer[indexOffset + 4] = firstVertex + 3;
                    indexBuffer[indexOffset + 5] = secondVertex;
                }
                return batchMesh;
            }
        }
        particle.createBatchMesh = createBatchMesh;
        /**
         * @internal
         */
        function generatePositionAndDirection(position, direction, shape) {
            if (!shape.enable) {
                position.x = position.y = position.z = 0;
                direction.x = direction.y = 0;
                direction.z = 1.0;
                return;
            }
            //
            switch (shape.shapeType) {
                case 4 /* Cone */:
                case 7 /* ConeShell */:
                    {
                        _generateConeParticlePosition(shape, position, direction);
                    }
                    break;
                case 8 /* ConeVolume */:
                case 9 /* ConeVolumeShell */:
                    {
                        _generateConeVolumeParticlePosition(shape, position, direction);
                    }
                    break;
                case 5 /* Box */:
                    {
                        _generateBoxParticlePosition(shape, position, direction);
                    }
                    break;
                case 0 /* Sphere */:
                case 1 /* SphereShell */:
                    {
                        _generateSphereParticlePosition(shape, position, direction);
                    }
                    break;
                case 10 /* Circle */:
                    {
                        _generateCircleParticlePosition(shape, position, direction);
                    }
                    break;
                default:
                    {
                        position.x = position.y = position.z = 0;
                        direction.x = direction.y = 0;
                        direction.z = 1;
                    }
            }
        }
        particle.generatePositionAndDirection = generatePositionAndDirection;
        function _randomPostionCircle(out) {
            var angle = Math.random() * Math.PI * 2;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideCircle(out) {
            _randomPostionCircle(out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionArcCircle(arc, out) {
            var angle = Math.random() * arc;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideArcCircle(arc, out) {
            _randomPositionArcCircle(arc, out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionSphere(out) {
            var ranZ = Math.random() * 2 - 1.0;
            var angle = Math.random() * Math.PI * 2;
            var range = Math.sqrt(1.0 - ranZ * ranZ);
            out.x = Math.cos(angle) * range;
            out.y = Math.sin(angle) * range;
            out.z = ranZ;
        }
        function _randomPositionInsideSphere(out) {
            _randomPositionSphere(out);
            var range = Math.pow(Math.random(), 1.0 / 3.0);
            out.x = out.x * range;
            out.y = out.y * range;
            out.z = out.z * range;
        }
        function _generateConeParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType == 4 /* Cone */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = temp.z * shape.radius;
            var angle = shape.angle * Math.PI / 180.0;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            if (shape.randomDirection) {
                _randomPositionInsideCircle(direction);
                direction.x = direction.x * sinValue;
                direction.y = direction.y * sinValue;
                direction.z = cosValue;
            }
            else {
                direction.x = temp.x * sinValue;
                direction.y = temp.y * sinValue;
                direction.z = cosValue;
            }
        }
        function _generateConeVolumeParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType == 8 /* ConeVolume */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            var angle = shape.angle * Math.PI / 180.0;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            direction.x = temp.x * sinValue;
            direction.y = temp.y * sinValue;
            direction.z = cosValue;
            direction = egret3d.Vector3.normalize(direction);
            var len = Math.random() * shape.length;
            direction.x = direction.x * len;
            direction.y = direction.y * len;
            direction.z = direction.z * len;
            position.x += direction.x;
            position.y += direction.y;
            position.z += direction.z;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
        }
        function _generateBoxParticlePosition(shape, position, direction) {
            position.x = shape.box.x * (Math.random() - 0.5);
            position.y = shape.box.y * (Math.random() - 0.5);
            position.z = shape.box.z * (Math.random() - 0.5);
            if (shape.randomDirection) {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
            else {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
        }
        function _generateSphereParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (!shape.spherizeDirection) {
                if (shape.shapeType == 0 /* Sphere */) {
                    _randomPositionInsideSphere(position);
                }
                else {
                    _randomPositionSphere(position);
                }
            }
            position.x = position.x * shape.radius;
            position.y = position.y * shape.radius;
            position.z = position.z * shape.radius;
            if (shape.randomDirection || shape.spherizeDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
        function _generateCircleParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType == 10 /* Circle */) {
                _randomPositionInsideArcCircle(shape.radiusSpread, temp);
            }
            else {
                _randomPositionArcCircle(shape.radiusSpread, temp);
            }
            position.x = -temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    paper.serializeClassMap = {
        0: "paper.Scene",
        1: "paper.GameObject",
        2: "egret3d.AniPlayer",
        3: "egret3d.BoxCollider",
        4: "egret3d.Camera",
        5: "egret3d.MeshFilter",
        6: "egret3d.MeshRenderer",
        7: "egret3d.particle.ParticleComponent",
        8: "egret3d.particle.ParticleRenderer",
        9: "egret3d.SkinnedMeshRenderer",
        10: "egret3d.SphereCollider",
        11: "egret3d.Transform",
        12: "egret3d.Shader",
        13: "egret3d.Mesh",
        14: "egret3d.Material",
        15: "egret3d.AnimationClip",
        16: "egret3d.TPoseInfo",
        17: "egret3d.PoseBoneMatrix",
        18: "egret3d.Texture",
        19: "egret3d.Texture",
        20: "egret3d.Vector2",
        21: "egret3d.Vector3",
        22: "egret3d.Vector4",
        23: "egret3d.Quaternion",
        24: "egret3d.Color",
        25: "egret3d.Gradient",
        26: "egret3d.Curve",
        27: "egret3d.Keyframe",
        28: "egret3d.Rect",
        29: "egret3d.MainModule",
        30: "egret3d.EmissionModule",
        31: "egret3d.ShapeModule",
        32: "egret3d.VelocityOverLifetimeModule",
        33: "egret3d.RotationOverLifetimeModule",
        34: "egret3d.ColorOverLifetimeModule",
        35: "egret3d.SizeOverLifetimeModule",
        36: "egret3d.MinMaxCurve",
        37: "egret3d.MinMaxGradient",
        38: "egret3d.alphaKey",
        39: "egret3d.colorKey",
        40: "egret3d.Animation",
        41: "egret3d.GLTFAsset",
        //
        "egret3d.Light": "egret3d.DirectLight",
    };
    function findClassCode(name) {
        for (var key in paper.serializeClassMap) {
            if (paper.serializeClassMap[key] === name) {
                return key;
            }
        }
        return "";
    }
    paper.findClassCode = findClassCode;
    function findClassCodeFrom(target) {
        var proto = target.__proto__;
        var classTypeOrigin = proto.__class__;
        var classType = paper.findClassCode(classTypeOrigin);
        return classType;
    }
    paper.findClassCodeFrom = findClassCodeFrom;
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        //
        var positionHelper = new egret3d.Vector3();
        var velocityHelper = new egret3d.Vector3();
        var startSizeHelper = new egret3d.Vector3();
        var startColorHelper = new egret3d.Color();
        var startRotationHelper = new egret3d.Vector3();
        var uvHelper = new egret3d.Vector4(1.0, 1.0, 0.0, 0.0);
        var helpVec2 = new egret3d.Vector2();
        var helpVec3 = new egret3d.Vector3();
        var helpVec4 = new egret3d.Vector4();
        var GRAVITY = new egret3d.Vector3(0, -9.81, 0); //TODO没有物理系统，暂时先放到这里
        /**
         * @internal
         */
        var ParticleBatcher = (function () {
            function ParticleBatcher() {
                this._dirty = false;
                this._time = 0.0;
                this._emittsionTime = 0;
                this._frameRateTime = 0;
                //最新存活位置
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                //最后存活位置
                this._lastAliveCursor = 0;
                //原始顶点数量
                this._vertexStride = 0;
                //当前爆发的索引
                this._burstIndex = 0;
                //最终重力
                this._finalGravity = new egret3d.Vector3();
            }
            /**
            * 计算粒子爆发数量
            * @param startTime
            * @param endTime
            */
            ParticleBatcher.prototype._getBurstCount = function (startTime, endTime) {
                var totalEmitCount = 0;
                var bursts = this._comp.emission.bursts;
                for (var l = bursts.length; this._burstIndex < l; this._burstIndex++) {
                    var burst = bursts[this._burstIndex];
                    if (burst.time >= startTime && burst.time < endTime) {
                        totalEmitCount += egret3d.numberLerp(burst.minCount, burst.maxCount, Math.random());
                    }
                    else {
                        break;
                    }
                }
                return totalEmitCount;
            };
            /**
             * 判断粒子是否已经过期
             * @param particleIndex
             */
            ParticleBatcher.prototype._isParticleExpired = function (particleIndex) {
                var startTimeOffset = particleIndex * this._vertexStride * 2;
                return this._time - this._startTimeBuffer[startTimeOffset + 1] + 0.0001 > this._startTimeBuffer[startTimeOffset];
            };
            /**
             *
             * @param time 批量增加粒子
             * @param startCursor
             * @param endCursor
             */
            ParticleBatcher.prototype._addParticles = function (time, startCursor, count) {
                var comp = this._comp;
                var main = comp.main;
                var velocityModule = comp.velocityOverLifetime;
                var colorModule = comp.colorOverLifetime;
                var sizeModule = comp.sizeOverLifetime;
                var rotationModule = comp.rotationOverLifetime;
                var textureSheetModule = comp.textureSheetAnimation;
                var isVelocityRandom = velocityModule.enable && (velocityModule._mode === 3 /* TwoConstants */ || velocityModule._mode === 2 /* TwoCurves */);
                var isColorRandom = colorModule.enable && colorModule._color.mode === 3 /* TwoGradients */;
                var isSizeRandom = sizeModule.enable && (sizeModule._size.mode === 3 /* TwoConstants */ || sizeModule._size.mode === 2 /* TwoCurves */);
                var isRotationRandom = rotationModule.enable && (rotationModule._x.mode === 3 /* TwoConstants */ || rotationModule._x.mode === 2 /* TwoCurves */);
                var isTextureRandom = textureSheetModule.enable && (textureSheetModule._startFrame.mode === 3 /* TwoConstants */ || textureSheetModule._startFrame.mode === 2 /* TwoCurves */);
                var needRandom0 = isColorRandom || isSizeRandom || isRotationRandom || isTextureRandom;
                var worldPosition = this._worldPostionCache;
                var worldRotation = this._worldRotationCache;
                var isWorldSpace = main._simulationSpace === 1 /* World */;
                var startPositionBuffer = this._startPositionBuffer;
                var startVelocityBuffer = this._startVelocityBuffer;
                var startColorBuffer = this._startColorBuffer;
                var startSizeBuffer = this._startSizeBuffer;
                var startRotationBuffer = this._startRotationBuffer;
                var startTimeBuffer = this._startTimeBuffer;
                var random0Buffer = this._random0Buffer;
                var random1Buffer = this._random1Buffer;
                var worldPostionBuffer = this._worldPostionBuffer;
                var worldRoationBuffer = this._worldRoationBuffer;
                var age = Math.min(this._emittsionTime / main.duration, 1.0);
                var vertexStride = this._vertexStride;
                var addCount = 0, startIndex = 0, endIndex = 0;
                var lifetime = 0.0;
                var startSpeed = 0.0;
                var randomVelocityX = 0.0, randomVelocityY = 0.0, randomVelocityZ = 0.0;
                var randomColor = 0.0, randomSize = 0.0, randomRotation = 0.0, randomTextureAnimation = 0.0;
                var vector2Offset = 0, vector3Offset = 0, vector4Offset = 0;
                while (addCount !== count) {
                    //发射粒子要根据粒子发射器的形状发射
                    comp.shape.generatePositionAndDirection(positionHelper, velocityHelper);
                    main.startColor.evaluate(age, startColorHelper);
                    lifetime = main.startLifetime.evaluate(age);
                    startSpeed = main.startSpeed.evaluate(age);
                    velocityHelper.x *= startSpeed;
                    velocityHelper.y *= startSpeed;
                    velocityHelper.z *= startSpeed;
                    startSizeHelper.x = main.startSizeX.evaluate(age);
                    startSizeHelper.y = main.startSizeY.evaluate(age);
                    startSizeHelper.z = main.startSizeZ.evaluate(age);
                    startRotationHelper.x = main.startRotationX.evaluate(age);
                    startRotationHelper.y = main.startRotationY.evaluate(age);
                    startRotationHelper.z = main.startRotationZ.evaluate(age);
                    randomVelocityX = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityY = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityZ = isVelocityRandom ? Math.random() : 0.0;
                    randomColor = isColorRandom ? Math.random() : 0.0;
                    randomSize = isSizeRandom ? Math.random() : 0.0;
                    randomRotation = isRotationRandom ? Math.random() : 0.0;
                    randomTextureAnimation = isTextureRandom ? Math.random() : 0.0;
                    for (startIndex = startCursor * vertexStride, endIndex = startIndex + vertexStride; startIndex < endIndex; startIndex++) {
                        vector2Offset = startIndex * 2;
                        vector3Offset = startIndex * 3;
                        vector4Offset = startIndex * 4;
                        //
                        startPositionBuffer[vector3Offset] = positionHelper.x;
                        startPositionBuffer[vector3Offset + 1] = positionHelper.y;
                        startPositionBuffer[vector3Offset + 2] = positionHelper.z;
                        startVelocityBuffer[vector3Offset] = velocityHelper.x;
                        startVelocityBuffer[vector3Offset + 1] = velocityHelper.y;
                        startVelocityBuffer[vector3Offset + 2] = velocityHelper.z;
                        startColorBuffer[vector4Offset] = startColorHelper.r;
                        startColorBuffer[vector4Offset + 1] = startColorHelper.g;
                        startColorBuffer[vector4Offset + 2] = startColorHelper.b;
                        startColorBuffer[vector4Offset + 3] = startColorHelper.a;
                        startSizeBuffer[vector3Offset] = startSizeHelper.x;
                        startSizeBuffer[vector3Offset + 1] = startSizeHelper.y;
                        startSizeBuffer[vector3Offset + 2] = startSizeHelper.z;
                        startRotationBuffer[vector3Offset] = startRotationHelper.x;
                        startRotationBuffer[vector3Offset + 1] = startRotationHelper.y;
                        startRotationBuffer[vector3Offset + 2] = startRotationHelper.z;
                        startTimeBuffer[vector2Offset] = lifetime;
                        startTimeBuffer[vector2Offset + 1] = time;
                        //
                        if (needRandom0) {
                            random0Buffer[vector4Offset] = randomColor;
                            random0Buffer[vector4Offset + 1] = randomSize;
                            random0Buffer[vector4Offset + 2] = randomRotation;
                            random0Buffer[vector4Offset + 3] = randomTextureAnimation;
                        }
                        if (isVelocityRandom) {
                            random1Buffer[vector4Offset] = randomVelocityX;
                            random1Buffer[vector4Offset + 1] = randomVelocityY;
                            random1Buffer[vector4Offset + 2] = randomVelocityZ;
                            random1Buffer[vector4Offset + 3] = 0;
                        }
                        if (isWorldSpace) {
                            worldPostionBuffer[vector3Offset] = worldPosition.x;
                            worldPostionBuffer[vector3Offset + 1] = worldPosition.y;
                            worldPostionBuffer[vector3Offset + 2] = worldPosition.z;
                            worldRoationBuffer[vector4Offset] = worldRotation.x;
                            worldRoationBuffer[vector4Offset + 1] = worldRotation.y;
                            worldRoationBuffer[vector4Offset + 2] = worldRotation.z;
                            worldRoationBuffer[vector4Offset + 3] = worldRotation.w;
                        }
                    }
                    ;
                    startCursor++;
                    if (startCursor >= main._maxParticles) {
                        startCursor = 0;
                    }
                    addCount++;
                }
                //TODO理论上应该是每帧更新，不过现在没有物理系统，先放到这里
                var gravityModifier = main.gravityModifier.constant;
                this._finalGravity.x = GRAVITY.x * gravityModifier;
                this._finalGravity.y = GRAVITY.y * gravityModifier;
                this._finalGravity.z = GRAVITY.z * gravityModifier;
            };
            ParticleBatcher.prototype._tryEmit = function (time) {
                var maxParticles = this._comp.main._maxParticles;
                var nextCursor = this._firstAliveCursor + 1 > maxParticles ? 0 : this._firstAliveCursor + 1;
                if (nextCursor >= maxParticles) {
                    nextCursor = 0;
                }
                if (!this._isParticleExpired(nextCursor)) {
                    return false;
                }
                //
                this._firstAliveCursor = nextCursor;
                this._dirty = true;
                return true;
            };
            ParticleBatcher.prototype.clean = function () {
                this._time = 0.0;
                this._dirty = false;
                this._emittsionTime = 0.0;
                this._frameRateTime = 0.0;
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                this._lastAliveCursor = 0;
                this._vertexStride = 0;
                this._vertexAttributes = null;
                this._burstIndex = 0;
                this._startPositionBuffer = null;
                this._startVelocityBuffer = null;
                this._startColorBuffer = null;
                this._startSizeBuffer = null;
                this._startRotationBuffer = null;
                this._startTimeBuffer = null;
                this._random0Buffer = null;
                this._random1Buffer = null;
                this._worldPostionBuffer = null;
                this._worldRoationBuffer = null;
                this._worldPostionCache = null;
                this._worldRotationCache = null;
                this._comp = null;
                this._renderer = null;
            };
            ParticleBatcher.prototype.resetTime = function () {
                this._burstIndex = 0;
                this._emittsionTime = 0;
            };
            ParticleBatcher.prototype.init = function (comp, renderer) {
                this._comp = comp;
                this._renderer = renderer;
                var mesh = particle.createBatchMesh(renderer, comp.main._maxParticles);
                this._vertexStride = renderer._renderMode === 4 /* Mesh */ ? renderer.mesh.vertexCount : 4;
                this._startPositionBuffer = mesh.getAttributes("START_POSITION" /* START_POSITION */);
                this._startVelocityBuffer = mesh.getAttributes("START_VELOCITY" /* START_VELOCITY */);
                this._startColorBuffer = mesh.getAttributes("START_COLOR" /* START_COLOR */);
                this._startSizeBuffer = mesh.getAttributes("START_SIZE" /* START_SIZE */);
                this._startRotationBuffer = mesh.getAttributes("START_ROTATION" /* START_ROTATION */);
                this._startTimeBuffer = mesh.getAttributes("TIME" /* TIME */);
                this._random0Buffer = mesh.getAttributes("RANDOM0" /* RANDOM0 */);
                this._random1Buffer = mesh.getAttributes("RANDOM1" /* RANDOM1 */);
                this._worldPostionBuffer = mesh.getAttributes("WORLD_POSITION" /* WORLD_POSITION */);
                this._worldRoationBuffer = mesh.getAttributes("WORLD_ROTATION" /* WORLD_ROTATION */);
                var primitive = mesh.glTFMesh.primitives[0];
                this._vertexAttributes = [];
                for (var k in primitive.attributes) {
                    this._vertexAttributes.push(k);
                }
                renderer.batchMesh = mesh;
                //粒子系统不能用共享材质
                renderer.batchMaterial = renderer.materials[0].clone();
                mesh.uploadSubIndexBuffer();
            };
            ParticleBatcher.prototype.update = function (elapsedTime) {
                if (this._comp.isPaused) {
                    return;
                }
                //
                this._time += elapsedTime;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                while (this._lastAliveCursor != this._firstAliveCursor) {
                    if (!this._isParticleExpired(this._lastAliveCursor)) {
                        break;
                    }
                    this._lastAliveCursor++;
                    if (this._lastAliveCursor >= mainModule._maxParticles) {
                        this._lastAliveCursor = 0;
                    }
                }
                var transform = comp.gameObject.transform;
                this._worldPostionCache = transform.getPosition();
                this._worldRotationCache = transform.getRotation();
                //检测是否已经过了Delay时间，否则不能发射
                if (comp._isPlaying && this._time >= mainModule.startDelay.constant && comp.emission.enable) {
                    this._updateEmission(elapsedTime);
                }
                this._updateRender();
            };
            ParticleBatcher.prototype._updateEmission = function (elapsedTime) {
                var comp = this._comp;
                var mainModule = comp.main;
                //根据时间判断
                var lastEmittsionTime = this._emittsionTime;
                this._emittsionTime += elapsedTime;
                var isOver = this._emittsionTime > mainModule.duration;
                if (!isOver) {
                    //由爆发触发的粒子发射
                    var totalEmitCount = 0;
                    if (comp.emission.bursts.length > 0) {
                        var readyEmitCount = 0;
                        readyEmitCount += this._getBurstCount(lastEmittsionTime, this._emittsionTime);
                        readyEmitCount = Math.min(mainModule._maxParticles - this.aliveParticleCount, readyEmitCount);
                        //
                        for (var i = 0; i < readyEmitCount; i++) {
                            if (this._tryEmit(this._time)) {
                                totalEmitCount++;
                            }
                        }
                    }
                    //由时间触发的粒子发射,不支持曲线
                    var rateOverTime = comp.emission.rateOverTime.constant;
                    if (rateOverTime > 0) {
                        var minEmissionTime = 1 / rateOverTime;
                        this._frameRateTime += elapsedTime;
                        while (this._frameRateTime > minEmissionTime) {
                            if (!this._tryEmit(this._time)) {
                                break;
                            }
                            totalEmitCount++;
                            this._frameRateTime -= minEmissionTime;
                        }
                    }
                    if (totalEmitCount > 0) {
                        this._addParticles(this._time, this._lastFrameFirstCursor, totalEmitCount);
                    }
                }
                else {
                    //一个生命周期结束
                    if (mainModule.loop) {
                        //直接置零，对时间敏感的可能有问题
                        this._emittsionTime = 0;
                        this._burstIndex = 0;
                    }
                    else {
                        //自己停止，不要影响子粒子播放状态
                        comp.stop(false);
                    }
                }
            };
            ParticleBatcher.prototype._updateRender = function () {
                var renderer = this._renderer;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                if (this._dirty) {
                    //为了性能，不能提交整个buffer，只提交改变的buffer
                    var bufferOffset = this._lastFrameFirstCursor * this._vertexStride;
                    if (this._firstAliveCursor > this._lastFrameFirstCursor) {
                        var bufferCount = (this._firstAliveCursor - this._lastFrameFirstCursor) * this._vertexStride;
                        renderer.batchMesh.uploadVertexSubData(this._vertexAttributes, bufferOffset, bufferCount);
                    }
                    else {
                        var addCount = mainModule._maxParticles - this._lastFrameFirstCursor;
                        //先更新尾部的，再更新头部的
                        renderer.batchMesh.uploadVertexSubData(this._vertexAttributes, bufferOffset, addCount * this._vertexStride);
                        renderer.batchMesh.uploadVertexSubData(this._vertexAttributes, 0, this._firstAliveCursor * this._vertexStride);
                    }
                    this._lastFrameFirstCursor = this._firstAliveCursor;
                    this._dirty = false;
                }
                var transform = comp.gameObject.transform;
                if (mainModule._simulationSpace === 0 /* Local */) {
                    renderer._setVector3("u_worldPosition" /* WORLD_POSITION */, this._worldPostionCache);
                    renderer._setVector4("u_worldRotation" /* WORLD_ROTATION */, this._worldRotationCache);
                }
                //
                switch (mainModule._scaleMode) {
                    case 1 /* Local */:
                        {
                            var scale = transform.getLocalScale();
                            renderer._setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            renderer._setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                    case 2 /* Shape */:
                        {
                            var scale = transform.getScale();
                            renderer._setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            renderer._setVector3("u_sizeScale" /* SIZE_SCALE */, egret3d.Vector3.ONE);
                        }
                        break;
                    case 0 /* Hierarchy */:
                        {
                            var scale = transform.getScale();
                            renderer._setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            renderer._setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                }
                renderer._setFloat("u_currentTime" /* CURRENTTIME */, this._time);
                renderer._setVector3("u_gravity" /* GRAVIT */, this._finalGravity);
            };
            Object.defineProperty(ParticleBatcher.prototype, "aliveParticleCount", {
                get: function () {
                    if (this._firstAliveCursor >= this._lastAliveCursor) {
                        return this._firstAliveCursor - this._lastAliveCursor;
                    }
                    else {
                        return this._comp.main._maxParticles - this._lastAliveCursor + this._firstAliveCursor;
                    }
                },
                enumerable: true,
                configurable: true
            });
            return ParticleBatcher;
        }());
        particle.ParticleBatcher = ParticleBatcher;
        __reflect(ParticleBatcher.prototype, "egret3d.particle.ParticleBatcher");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var ParticleComponent = (function (_super) {
            __extends(ParticleComponent, _super);
            function ParticleComponent() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                //主模块
                _this.main = new particle.MainModule(_this);
                //发射模块
                _this.emission = new particle.EmissionModule(_this);
                //发射形状模块
                _this.shape = new particle.ShapeModule(_this);
                //速率变换模块
                _this.velocityOverLifetime = new particle.VelocityOverLifetimeModule(_this);
                //旋转变换模块
                _this.rotationOverLifetime = new particle.RotationOverLifetimeModule(_this);
                //尺寸变化模块
                _this.sizeOverLifetime = new particle.SizeOverLifetimeModule(_this);
                //颜色变化模块
                _this.colorOverLifetime = new particle.ColorOverLifetimeModule(_this);
                //序列帧变化模块
                _this.textureSheetAnimation = new particle.TextureSheetAnimationModule(_this);
                /**
                 * @internal
                 */
                _this._isPlaying = false;
                /**
                 * @internal
                 */
                _this._isPaused = false;
                _this._batcher = new particle.ParticleBatcher();
                return _this;
            }
            /**
             * @internal
             */
            ParticleComponent.prototype._clean = function () {
                //
                this._batcher.clean();
                this._isPlaying = false;
                this._isPaused = false;
            };
            ParticleComponent.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.main.deserialize(element.main);
                this.emission.deserialize(element.emission);
                if (element.shape) {
                    this.shape.deserialize(element.shape);
                }
                if (element.velocityOverLifetime) {
                    this.velocityOverLifetime.deserialize(element.velocityOverLifetime);
                }
                if (element.rotationOverLifetime) {
                    this.rotationOverLifetime.deserialize(element.rotationOverLifetime);
                }
                if (element.sizeOverLifetime) {
                    this.sizeOverLifetime.deserialize(element.sizeOverLifetime);
                }
                if (element.colorOverLifetime) {
                    this.colorOverLifetime.deserialize(element.colorOverLifetime);
                }
                if (element.textureSheetAnimation) {
                    this.textureSheetAnimation.deserialize(element.textureSheetAnimation);
                }
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                this._clean();
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.initialize = function () {
                _super.prototype.initialize.call(this);
                this._clean();
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.initBatcher = function () {
                this._clean();
                this._batcher.init(this, this.gameObject.getComponent(particle.ParticleRenderer));
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.update = function (elapsedTime) {
                this._batcher.update(elapsedTime);
            };
            ParticleComponent.prototype.play = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (this._isPaused) {
                    this._isPaused = false;
                }
                else {
                    this._isPlaying = true;
                    this._isPaused = false;
                    this._batcher.resetTime();
                }
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                        var child = children_1[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.play(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.pause = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPaused = true;
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
                        var child = children_2[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.pause(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.stop = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPlaying = false;
                this._batcher.resetTime();
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_3 = children; _i < children_3.length; _i++) {
                        var child = children_3[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.clear = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_4 = children; _i < children_4.length; _i++) {
                        var child = children_4[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            Object.defineProperty(ParticleComponent.prototype, "loop", {
                get: function () {
                    return this.main.loop;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPlaying", {
                get: function () {
                    return this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPaused", {
                get: function () {
                    return this._isPaused;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isAlive", {
                get: function () {
                    return this._batcher.aliveParticleCount > 0 || this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "main", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "emission", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "shape", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "velocityOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "rotationOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "sizeOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "colorOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "textureSheetAnimation", void 0);
            return ParticleComponent;
        }(paper.BaseComponent));
        particle.ParticleComponent = ParticleComponent;
        __reflect(ParticleComponent.prototype, "egret3d.particle.ParticleComponent");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var StartSystem = (function (_super) {
        __extends(StartSystem, _super);
        function StartSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: paper.Behaviour,
                    isExtends: true
                }
            ];
            return _this;
        }
        StartSystem.prototype._onAddComponent = function (component) {
            if (this._components.indexOf(component) < 0) {
                this._components.push(component);
                return;
            }
            var gameObject = component.gameObject;
            console.debug("StartSystem add behaviour error.", gameObject.name, gameObject.uuid, egret.getQualifiedClassName(component));
        };
        StartSystem.prototype._onRemoveComponent = function (component) {
            var index = this._components.indexOf(component);
            if (index >= 0) {
                this._components[index] = null;
                return;
            }
            var gameObject = component.gameObject;
            console.debug("StartSystem remove behaviour error.", gameObject.name, gameObject.uuid, egret.getQualifiedClassName(component));
        };
        StartSystem.prototype.onUpdate = function () {
            //
            egret3d.Performance.startCounter("all" /* All */);
            egret3d.stage.update();
            // Update behaviours.
            if (this._isEditorUpdate()) {
                if (this._components.length > 0) {
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (!component) {
                            continue;
                        }
                        if (!component._isReseted) {
                            component._isReseted = true;
                            component.onReset && component.onReset();
                        }
                        if (paper._executeInEditModeComponents.indexOf(component.constructor) < 0) {
                            continue;
                        }
                        component.onEnable && component.onEnable();
                        if (!component._isStarted && component.isActiveAndEnabled) {
                            component._isStarted = true;
                            component.onStart && component.onStart();
                        }
                    }
                    this._components.length = 0;
                }
            }
            else if (this._components.length > 0) {
                for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                    var component = _c[_b];
                    if (!component) {
                        continue;
                    }
                    component.onEnable && component.onEnable();
                    if (!component._isStarted && component.isActiveAndEnabled) {
                        component._isStarted = true;
                        component.onStart && component.onStart();
                    }
                }
                this._components.length = 0;
            }
        };
        return StartSystem;
    }(paper.BaseSystem));
    paper.StartSystem = StartSystem;
    __reflect(StartSystem.prototype, "paper.StartSystem");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         *
         */
        var ParticleSystem = (function (_super) {
            __extends(ParticleSystem, _super);
            function ParticleSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._globalTimer = 0.0;
                _this._interests = [
                    {
                        componentClass: particle.ParticleComponent,
                        listeners: [
                            { type: "rotation3DChanged" /* StartRotation3DChanged */, listener: function (comp) { _this._onMainUpdate(comp, "rotation3DChanged" /* StartRotation3DChanged */); } },
                            { type: "simulationSpace" /* SimulationSpaceChanged */, listener: function (comp) { _this._onMainUpdate(comp, "simulationSpace" /* SimulationSpaceChanged */); } },
                            { type: "scaleMode" /* ScaleModeChanged */, listener: function (comp) { _this._onMainUpdate(comp, "scaleMode" /* ScaleModeChanged */); } },
                            { type: "velocityChanged" /* VelocityChanged */, listener: _this._onVelocityOverLifetime },
                            { type: "colorChanged" /* ColorChanged */, listener: _this._onColorOverLifetime },
                            { type: "sizeChanged" /* SizeChanged */, listener: _this._onSizeOverLifetime },
                            { type: "rotationChanged" /* RotationChanged */, listener: _this._onRotationOverLifetime },
                            { type: "textureSheetChanged" /* TextureSheetChanged */, listener: _this._onTextureSheetAnimation },
                        ]
                    },
                    {
                        componentClass: particle.ParticleRenderer,
                        listeners: [
                            { type: "mesh" /* Mesh */, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            { type: "materials" /* Materials */, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            { type: "lengthScale" /* LengthScaleChanged */, listener: function (comp) { _this._onRenderUpdate(comp, "lengthScale" /* LengthScaleChanged */); } },
                            { type: "velocityScale" /* VelocityScaleChanged */, listener: function (comp) { _this._onRenderUpdate(comp, "velocityScale" /* VelocityScaleChanged */); } },
                            { type: "renderMode" /* RenderMode */, listener: function (comp) { _this._onRenderUpdate(comp, "renderMode" /* RenderMode */); } },
                        ]
                    }
                ];
                _this._drawCalls = _this._globalGameObject.getComponent(egret3d.DrawCalls) || _this._globalGameObject.addComponent(egret3d.DrawCalls);
                return _this;
            }
            /**
            * Buffer改变的时候，有可能是初始化，也有可能是mesh改变，此时全部刷一下
            */
            ParticleSystem.prototype._onUpdateBatchMesh = function (comp) {
                var renderer = this._getComponent(comp.gameObject, 1);
                comp.initBatcher();
                //
                this._onRenderUpdate(renderer, "renderMode" /* RenderMode */);
                this._onRenderUpdate(renderer, "lengthScale" /* LengthScaleChanged */);
                this._onRenderUpdate(renderer, "velocityScale" /* VelocityScaleChanged */);
                //
                this._onMainUpdate(comp, "rotation3DChanged" /* StartRotation3DChanged */);
                this._onMainUpdate(comp, "simulationSpace" /* SimulationSpaceChanged */);
                this._onMainUpdate(comp, "scaleMode" /* ScaleModeChanged */);
                this._onShapeChanged(comp);
                this._onVelocityOverLifetime(comp);
                this._onColorOverLifetime(comp);
                this._onSizeOverLifetime(comp);
                this._onRotationOverLifetime(comp);
                this._onTextureSheetAnimation(comp);
            };
            ParticleSystem.prototype._onRenderUpdate = function (render, type) {
                switch (type) {
                    case "renderMode" /* RenderMode */: {
                        this._onRenderMode(render);
                        break;
                    }
                    case "lengthScale" /* LengthScaleChanged */: {
                        render._setFloat("u_lengthScale" /* LENGTH_SCALE */, render.lengthScale);
                        break;
                    }
                    case "velocityScale" /* VelocityScaleChanged */: {
                        render._setFloat("u_speeaScale" /* SPEED_SCALE */, render.velocityScale);
                        break;
                    }
                }
            };
            /**
             *
             * @param render 渲染模式改变
             */
            ParticleSystem.prototype._onRenderMode = function (render) {
                render._removeShaderDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                render._removeShaderDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                render._removeShaderDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                render._removeShaderDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                render._removeShaderDefine("RENDERMESH" /* RENDERMESH */);
                var mode = render.renderMode;
                switch (mode) {
                    case 0 /* Billboard */: {
                        render._addShaderDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                        break;
                    }
                    case 1 /* Stretch */: {
                        render._addShaderDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                        break;
                    }
                    case 2 /* HorizontalBillboard */: {
                        render._addShaderDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                        break;
                    }
                    case 3 /* VerticalBillboard */: {
                        render._addShaderDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                        break;
                    }
                    case 4 /* Mesh */: {
                        render._addShaderDefine("RENDERMESH" /* RENDERMESH */);
                        break;
                    }
                    default: {
                        throw "_onRenderMode:invalid renderMode";
                    }
                }
            };
            ParticleSystem.prototype._onMainUpdate = function (component, type) {
                var renderer = this._getComponent(component.gameObject, 1);
                var mainModule = component.main;
                switch (type) {
                    case "rotation3DChanged" /* StartRotation3DChanged */: {
                        renderer._setBoolean("u_startRotation3D" /* START_ROTATION3D */, mainModule._startRotation3D);
                        break;
                    }
                    case "simulationSpace" /* SimulationSpaceChanged */: {
                        renderer._setInt("u_simulationSpace" /* SIMULATION_SPACE */, mainModule._simulationSpace);
                        break;
                    }
                    case "scaleMode" /* ScaleModeChanged */: {
                        renderer._setInt("u_scalingMode" /* SCALING_MODE */, mainModule._scaleMode);
                        break;
                    }
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onShapeChanged = function (comp) {
                var renderer = this._getComponent(comp.gameObject, 1);
                renderer._removeShaderDefine("SHAPE" /* SHAPE */);
                if (comp.shape.enable) {
                    renderer._addShaderDefine("SHAPE" /* SHAPE */);
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onVelocityOverLifetime = function (comp) {
                var renderer = this._getComponent(comp.gameObject, 1);
                renderer._removeShaderDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                renderer._removeShaderDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                renderer._removeShaderDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                renderer._removeShaderDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                var velocityModule = comp.velocityOverLifetime;
                if (velocityModule.enable) {
                    var mode = velocityModule._mode;
                    switch (mode) {
                        case 0 /* Constant */: {
                            renderer._addShaderDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                            //
                            var vec3 = new egret3d.Vector3(velocityModule._x.evaluate(), velocityModule._y.evaluate(), velocityModule._z.evaluate());
                            renderer._setVector3("u_velocityConst" /* VELOCITY_CONST */, vec3);
                            break;
                        }
                        case 1 /* Curve */: {
                            renderer._addShaderDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                            //
                            renderer._setVector2v("u_velocityCurveX" /* VELOCITY_CURVE_X */, velocityModule._x.curve.floatValues);
                            renderer._setVector2v("u_velocityCurveY" /* VELOCITY_CURVE_Y */, velocityModule._y.curve.floatValues);
                            renderer._setVector2v("u_velocityCurveZ" /* VELOCITY_CURVE_Z */, velocityModule._z.curve.floatValues);
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            renderer._addShaderDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                            //
                            var minVec3 = new egret3d.Vector3(velocityModule._x.constantMin, velocityModule._y.constantMin, velocityModule._z.constantMin);
                            var maxVec3 = new egret3d.Vector3(velocityModule._x.constantMax, velocityModule._y.constantMax, velocityModule._z.constantMax);
                            renderer._setVector3("u_velocityConst" /* VELOCITY_CONST */, minVec3);
                            renderer._setVector3("u_velocityConstMax" /* VELOCITY_CONST_MAX */, maxVec3);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            renderer._addShaderDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                            //
                            renderer._setVector2v("u_velocityCurveX" /* VELOCITY_CURVE_X */, velocityModule._x.curveMin.floatValues);
                            renderer._setVector2v("u_velocityCurveY" /* VELOCITY_CURVE_Y */, velocityModule._y.curveMin.floatValues);
                            renderer._setVector2v("u_velocityCurveZ" /* VELOCITY_CURVE_Z */, velocityModule._z.curveMin.floatValues);
                            renderer._setVector2v("u_velocityCurveMaxX" /* VELOCITY_CURVE_MAX_X */, velocityModule._x.curveMax.floatValues);
                            renderer._setVector2v("u_velocityCurveMaxY" /* VELOCITY_CURVE_MAX_Y */, velocityModule._y.curveMax.floatValues);
                            renderer._setVector2v("u_velocityCurveMaxZ" /* VELOCITY_CURVE_MAX_Z */, velocityModule._z.curveMax.floatValues);
                            break;
                        }
                    }
                    renderer._setInt("u_spaceType" /* SPACE_TYPE */, velocityModule._space);
                }
            };
            /**
             * 更新颜色模块
             * @param component
             */
            ParticleSystem.prototype._onColorOverLifetime = function (comp) {
                var renderer = this._getComponent(comp.gameObject, 1);
                renderer._removeShaderDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                renderer._removeShaderDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                var colorModule = comp.colorOverLifetime;
                if (colorModule.enable) {
                    var color = colorModule._color;
                    switch (color.mode) {
                        case 1 /* Gradient */: {
                            renderer._addShaderDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                            //
                            renderer._setVector2v("u_alphaGradient" /* ALPHAS_GRADIENT */, color.gradient.alphaValues);
                            renderer._setVector4v("u_colorGradient" /* COLOR_GRADIENT */, color.gradient.colorValues);
                            break;
                        }
                        case 3 /* TwoGradients */: {
                            renderer._addShaderDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                            //
                            renderer._setVector2v("u_alphaGradient" /* ALPHAS_GRADIENT */, color.gradientMin.alphaValues);
                            renderer._setVector2v("u_alphaGradientMax" /* ALPHA_GRADIENT_MAX */, color.gradientMax.alphaValues);
                            renderer._setVector4v("u_colorGradient" /* COLOR_GRADIENT */, color.gradientMin.colorValues);
                            renderer._setVector4v("u_colorGradientMax" /* COLOR_GRADIENT_MAX */, color.gradientMax.colorValues);
                            break;
                        }
                    }
                }
            };
            /**
             * 更新大小模块
             * @param component
             */
            ParticleSystem.prototype._onSizeOverLifetime = function (comp) {
                var renderer = this._getComponent(comp.gameObject, 1);
                renderer._removeShaderDefine("SIZECURVE" /* SIZECURVE */);
                renderer._removeShaderDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                renderer._removeShaderDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                renderer._removeShaderDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                var sizeModule = comp.sizeOverLifetime;
                if (sizeModule.enable) {
                    var separateAxes = sizeModule._separateAxes;
                    var mode = sizeModule._x.mode;
                    switch (mode) {
                        case 1 /* Curve */: {
                            if (separateAxes) {
                                renderer._addShaderDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                                //
                                renderer._setVector2v("u_sizeCurveX" /* SIZE_CURVE_X */, sizeModule._x.curve.floatValues);
                                renderer._setVector2v("u_sizeCurveY" /* SIZE_CURVE_Y */, sizeModule._y.curve.floatValues);
                                renderer._setVector2v("u_sizeCurveZ" /* SIZE_CURVE_Z */, sizeModule._z.curve.floatValues);
                            }
                            else {
                                renderer._addShaderDefine("SIZECURVE" /* SIZECURVE */);
                                //
                                renderer._setVector2v("u_sizeCurve" /* SIZE_CURVE */, sizeModule._size.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            if (separateAxes) {
                                renderer._addShaderDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                                //
                                renderer._setVector2v("u_sizeCurveX" /* SIZE_CURVE_X */, sizeModule._x.curveMin.floatValues);
                                renderer._setVector2v("u_sizeCurveY" /* SIZE_CURVE_Y */, sizeModule._y.curveMin.floatValues);
                                renderer._setVector2v("u_sizeCurveZ" /* SIZE_CURVE_Z */, sizeModule._z.curveMin.floatValues);
                                renderer._setVector2v("u_sizeCurveMaxX" /* SIZE_CURVE_MAX_X */, sizeModule._x.curveMax.floatValues);
                                renderer._setVector2v("u_sizeCurveMaxY" /* SIZE_CURVE_MAX_Y */, sizeModule._y.curveMax.floatValues);
                                renderer._setVector2v("u_sizeCurveMaxZ" /* SIZE_CURVE_MAX_Z */, sizeModule._z.curveMax.floatValues);
                            }
                            else {
                                renderer._addShaderDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                                //
                                renderer._setVector2v("u_sizeCurve" /* SIZE_CURVE */, sizeModule._size.curveMin.floatValues);
                                renderer._setVector2v("u_sizeCurveMax" /* SIZE_CURVE_MAX */, sizeModule._size.curveMax.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            /**
             * 更新旋转模块
             * @param comp
             */
            ParticleSystem.prototype._onRotationOverLifetime = function (comp) {
                var renderer = this._getComponent(comp.gameObject, 1);
                renderer._removeShaderDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                renderer._removeShaderDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                renderer._removeShaderDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                renderer._removeShaderDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                renderer._removeShaderDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                renderer._removeShaderDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                var rotationModule = comp.rotationOverLifetime;
                if (rotationModule.enable) {
                    var mode = comp.rotationOverLifetime._x.mode;
                    var separateAxes = rotationModule._separateAxes;
                    if (separateAxes) {
                        renderer._addShaderDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                    }
                    else {
                        renderer._addShaderDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                    }
                    switch (mode) {
                        case 0 /* Constant */: {
                            renderer._addShaderDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                            //
                            if (separateAxes) {
                                renderer._setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule._x.constant, rotationModule._y.constant, rotationModule._z.constant));
                            }
                            else {
                                renderer._setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule._z.constant);
                            }
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            renderer._addShaderDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                            //
                            if (separateAxes) {
                                renderer._setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule._x.constantMin, rotationModule._y.constantMin, rotationModule._z.constantMin));
                                renderer._setVector3("u_rotationConstMaxSeprarate" /* ROTATION_CONST_MAX_SEPRARATE */, new egret3d.Vector3(rotationModule._x.constantMax, rotationModule._y.constantMax, rotationModule._z.constantMax));
                            }
                            else {
                                renderer._setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule._z.constantMin);
                                renderer._setFloat("u_rotationConstMax" /* ROTATION_CONST_MAX */, rotationModule._z.constantMax);
                            }
                            break;
                        }
                        case 1 /* Curve */: {
                            renderer._addShaderDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                            //
                            if (separateAxes) {
                                renderer._setVector2v("u_rotationCurveX" /* ROTATE_CURVE_X */, rotationModule._x.curve.floatValues);
                                renderer._setVector2v("u_rotationCurveY" /* ROTATE_CURVE_y */, rotationModule._y.curve.floatValues);
                                renderer._setVector2v("u_rotationCurveZ" /* ROTATE_CURVE_Z */, rotationModule._z.curve.floatValues);
                            }
                            else {
                                renderer._setVector2v("u_rotationCurve" /* ROTATION_CURVE */, rotationModule._z.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            renderer._addShaderDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                            //
                            if (separateAxes) {
                                renderer._setVector2v("u_rotationCurveX" /* ROTATE_CURVE_X */, rotationModule._x.curveMin.floatValues);
                                renderer._setVector2v("u_rotationCurveY" /* ROTATE_CURVE_y */, rotationModule._y.curveMin.floatValues);
                                renderer._setVector2v("u_rotationCurveZ" /* ROTATE_CURVE_Z */, rotationModule._z.curveMin.floatValues);
                                renderer._setVector2v("u_rotationCurveMaxX" /* ROTATION_CURVE_MAX_X */, rotationModule._x.curveMax.floatValues);
                                renderer._setVector2v("u_rotationCurveMaxY" /* ROTATION_CURVE_MAX_Y */, rotationModule._y.curveMax.floatValues);
                                renderer._setVector2v("u_rotationCurveMaxZ" /* ROTATION_CURVE_MAX_Z */, rotationModule._z.curveMax.floatValues);
                            }
                            else {
                                renderer._setVector2v("u_rotationCurve" /* ROTATION_CURVE */, rotationModule._z.curveMin.floatValues);
                                renderer._setVector2v("u_rotationCurveMax" /* ROTATION_CURVE_MAX */, rotationModule._z.curveMin.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            ParticleSystem.prototype._onTextureSheetAnimation = function (comp) {
                var renderer = this._getComponent(comp.gameObject, 1);
                renderer._removeShaderDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                renderer._removeShaderDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                var module = comp.textureSheetAnimation;
                if (module.enable) {
                    var type = module._frameOverTime.mode;
                    switch (type) {
                        case 1 /* Curve */: {
                            renderer._addShaderDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                            //
                            renderer._setVector2v("u_uvCurve" /* UV_CURVE */, module._frameOverTime.curve.floatValues);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            renderer._addShaderDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                            //
                            renderer._setVector2v("u_uvCurve" /* UV_CURVE */, module._frameOverTime.curveMin.floatValues);
                            renderer._setVector2v("u_uvCurveMax" /* UV_CURVE_MAX */, module._frameOverTime.curveMax.floatValues);
                            break;
                        }
                    }
                    if (type === 1 /* Curve */ || type === 2 /* TwoCurves */) {
                        renderer._setFloat("u_cycles" /* CYCLES */, module._cycleCount);
                        renderer._setVector4v("u_subUV" /* SUB_UV */, module.floatValues);
                    }
                }
            };
            ParticleSystem.prototype._updateDrawCalls = function (gameObject) {
                if (!this._enabled || !this._hasGameObject(gameObject)) {
                    return;
                }
                var component = this._getComponent(gameObject, 0);
                var renderer = this._getComponent(gameObject, 1);
                //
                this._onUpdateBatchMesh(component);
                if (!renderer.batchMesh || !renderer.batchMaterial) {
                    return;
                }
                //
                this._drawCalls.removeDrawCalls(renderer);
                //
                this._drawCalls.renderers.push(renderer);
                //
                var subMeshIndex = 0;
                var primitives = renderer.batchMesh.glTFMesh.primitives;
                if (primitives.length !== 1) {
                    console.error("ParticleSystem : materials.length != 1");
                }
                if (renderer._renderMode === 5 /* None */) {
                    console.error("ParticleSystem : error renderMode");
                }
                for (var _i = 0, primitives_1 = primitives; _i < primitives_1.length; _i++) {
                    var primitive = primitives_1[_i];
                    var drawCall = {
                        renderer: renderer,
                        subMeshIndex: subMeshIndex++,
                        mesh: renderer.batchMesh,
                        material: renderer.batchMaterial,
                        frustumTest: false,
                        zdist: -1,
                        disable: false,
                    };
                    this._drawCalls.drawCalls.push(drawCall);
                }
            };
            ParticleSystem.prototype.onEnable = function () {
                for (var i = 0, l = this._components.length; i < l; i += this._interestComponentCount) {
                    this._updateDrawCalls(this._components[i].gameObject);
                }
            };
            ParticleSystem.prototype.onAddGameObject = function (gameObject) {
                this._updateDrawCalls(gameObject);
                var component = this._getComponent(gameObject, 0);
                if (component.main.playOnAwake) {
                    component.play();
                }
            };
            ParticleSystem.prototype.onRemoveGameObject = function (gameObject) {
                if (!this._enabled) {
                    return;
                }
                this._drawCalls.removeDrawCalls(gameObject.renderer);
                // component.stop();
            };
            ParticleSystem.prototype.onUpdate = function () {
                if (this._globalTimer !== this._globalTimer) {
                    this._globalTimer = paper.Time.time;
                }
                var elapsedTime = paper.Time.time - this._globalTimer;
                for (var i = 0, l = this._components.length; i < l; i += 2) {
                    var particleComp = this._components[i];
                    particleComp.update(elapsedTime);
                }
                this._globalTimer = paper.Time.time;
            };
            ParticleSystem.prototype.onDisable = function () {
                for (var i = 0, l = this._components.length; i < l; i += this._interestComponentCount) {
                    var renderer = this._components[i + 1];
                    this._drawCalls.removeDrawCalls(renderer);
                }
            };
            return ParticleSystem;
        }(paper.BaseSystem));
        particle.ParticleSystem = ParticleSystem;
        __reflect(ParticleSystem.prototype, "egret3d.particle.ParticleSystem");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Audio = (function (_super) {
        __extends(Audio, _super);
        function Audio() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Audio;
    }(paper.BaseComponent));
    egret3d.Audio = Audio;
    __reflect(Audio.prototype, "egret3d.Audio");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var WEBGL_UNIFORM_TYPE;
    (function (WEBGL_UNIFORM_TYPE) {
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["INT_VEC2"] = 35667] = "INT_VEC2";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["INT_VEC3"] = 35668] = "INT_VEC3";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["INT_VEC4"] = 35669] = "INT_VEC4";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["BOOL"] = 35670] = "BOOL";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["BYTE"] = 65535] = "BYTE";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["SHORT"] = 5122] = "SHORT";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["INT"] = 5124] = "INT";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
        WEBGL_UNIFORM_TYPE[WEBGL_UNIFORM_TYPE["FLOAT"] = 5126] = "FLOAT";
    })(WEBGL_UNIFORM_TYPE = egret3d.WEBGL_UNIFORM_TYPE || (egret3d.WEBGL_UNIFORM_TYPE = {}));
    var WebGLUniform = (function () {
        function WebGLUniform(gl, program, uniformData) {
            this.gl = gl;
            this.name = uniformData.name;
            this.type = uniformData.type;
            this.size = uniformData.size;
            this.location = gl.getUniformLocation(program, this.name);
        }
        return WebGLUniform;
    }());
    egret3d.WebGLUniform = WebGLUniform;
    __reflect(WebGLUniform.prototype, "egret3d.WebGLUniform");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * WebGL窗口信息
     */
    var Stage3D = (function () {
        function Stage3D() {
            this.screenViewport = { x: 0, y: 0, w: 0, h: 0 };
            this.absolutePosition = { x: 0, y: 0, w: 0, h: 0 };
            this._resizeDirty = true;
        }
        /**
         * @internal
         */
        Stage3D.prototype.init = function (canvas, options) {
            var _this = this;
            this._canvas = canvas;
            window.addEventListener("resize", function () { return _this._resizeDirty = true; }, false);
            this.isLandscape = options.contentWidth > options.contentHeight;
            this.contentWidth = options.contentWidth;
            this.contentHeight = options.contentHeight;
        };
        Stage3D.prototype.update = function () {
            if (this._resizeDirty) {
                this._resize();
                this._resizeDirty = false;
            }
        };
        Stage3D.prototype._resize = function () {
            var displayWidth = window.innerWidth;
            var displayHeight = window.innerHeight;
            var absolutePosition = this.absolutePosition;
            absolutePosition.w = displayWidth;
            absolutePosition.h = displayHeight;
            // 计算视口区域
            var screenViewport = this.screenViewport;
            var shouldRotate = (this.isLandscape && window.innerHeight > window.innerWidth)
                || (!this.isLandscape && window.innerWidth > window.innerHeight);
            if (shouldRotate) {
                screenViewport.w = this.contentWidth;
                var screenH = Math.ceil(screenViewport.w / displayHeight * displayWidth);
                screenViewport.h = screenH;
            }
            else {
                screenViewport.w = this.contentWidth;
                var screenH = Math.ceil(screenViewport.w / displayWidth * displayHeight);
                screenViewport.h = screenH;
            }
            var canvas = this._canvas;
            canvas.width = screenViewport.w;
            canvas.height = screenViewport.h;
            // 设置canvas.style
            var x = absolutePosition.x, y = absolutePosition.y, w = absolutePosition.w, h = absolutePosition.h;
            canvas.style.top = y + "px";
            canvas.style.position = "absolute";
            canvas.style[egret.web.getPrefixStyleName("transformOrigin")] = "0% 0% 0px";
            if (shouldRotate) {
                canvas.style.width = h + "px";
                canvas.style.height = w + "px";
                canvas.style.left = window.innerWidth + "px";
                var transform = "matrix(0,1,-1,0,0,0)";
                canvas.style[egret.web.getPrefixStyleName("transform")] = transform;
            }
            else {
                canvas.style.width = w + "px";
                canvas.style.height = h + "px";
                canvas.style.left = x + "px";
                canvas.style[egret.web.getPrefixStyleName("transform")] = null;
            }
            // 更新触摸信息
            var touchScaleX;
            var touchScaleY;
            if (shouldRotate) {
                touchScaleX = egret3d.stage.screenViewport.w / h;
                touchScaleY = egret3d.stage.screenViewport.h / w;
            }
            else {
                touchScaleX = egret3d.stage.screenViewport.w / w;
                touchScaleY = egret3d.stage.screenViewport.h / h;
            }
            egret3d.InputManager.touch.updateOffsetAndScale(x, y, touchScaleX, touchScaleY, shouldRotate);
            egret3d.InputManager.mouse.updateOffsetAndScale(x, y, touchScaleX, touchScaleY, shouldRotate);
        };
        return Stage3D;
    }());
    egret3d.Stage3D = Stage3D;
    __reflect(Stage3D.prototype, "egret3d.Stage3D");
    egret3d.stage = new Stage3D();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var UpdateSystem = (function (_super) {
        __extends(UpdateSystem, _super);
        function UpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: paper.Behaviour,
                    isExtends: true
                }
            ];
            return _this;
        }
        UpdateSystem.prototype._onAddComponent = function (component) {
            if (this._components.indexOf(component) < 0) {
                this._components.push(component);
                return;
            }
            var gameObject = component.gameObject;
            console.debug("UpdateSystem add behaviour error.", gameObject.name, gameObject.uuid, egret.getQualifiedClassName(component));
        };
        UpdateSystem.prototype._onRemoveComponent = function (component) {
            var index = this._components.indexOf(component);
            if (index >= 0) {
                this._components[index] = null;
                return;
            }
            var gameObject = component.gameObject;
            console.debug("UpdateSystem remove behaviour error.", gameObject.name, gameObject.uuid, egret.getQualifiedClassName(component));
        };
        UpdateSystem.prototype.onUpdate = function () {
            var index = 0;
            var removeCount = 0;
            var deltaTime = paper.Time.deltaTime;
            var components = this._components;
            if (this._isEditorUpdate()) {
                for (var _i = 0, components_3 = components; _i < components_3.length; _i++) {
                    var component = components_3[_i];
                    if (component) {
                        if (component._isStarted && paper._executeInEditModeComponents.indexOf(component.constructor) >= 0) {
                            component.onUpdate && component.onUpdate(deltaTime);
                        }
                        if (removeCount > 0) {
                            components[index - removeCount] = component;
                            components[index] = null;
                        }
                    }
                    else {
                        removeCount++;
                    }
                    index++;
                }
            }
            else {
                for (var _a = 0, components_4 = components; _a < components_4.length; _a++) {
                    var component = components_4[_a];
                    if (component) {
                        if (component._isStarted) {
                            component.onUpdate && component.onUpdate(deltaTime);
                        }
                        if (removeCount > 0) {
                            components[index - removeCount] = component;
                            components[index] = null;
                        }
                    }
                    else {
                        removeCount++;
                    }
                    index++;
                }
            }
            if (removeCount > 0) {
                components.length -= removeCount;
            }
        };
        return UpdateSystem;
    }(paper.BaseSystem));
    paper.UpdateSystem = UpdateSystem;
    __reflect(UpdateSystem.prototype, "paper.UpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var LaterUpdateSystem = (function (_super) {
        __extends(LaterUpdateSystem, _super);
        function LaterUpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [{ componentClass: paper.Behaviour, isExtends: true }];
            _this._laterCalls = [];
            return _this;
        }
        LaterUpdateSystem.prototype.onUpdate = function () {
            // Update behaviours.
            var deltaTime = paper.Time.deltaTime;
            var components = paper.Application.systemManager.getSystem(paper.UpdateSystem).components;
            if (this._isEditorUpdate()) {
                for (var _i = 0, components_5 = components; _i < components_5.length; _i++) {
                    var component = components_5[_i];
                    if (component && component._isStarted && paper._executeInEditModeComponents.indexOf(component.constructor) >= 0) {
                        component.onLateUpdate && component.onLateUpdate(deltaTime);
                    }
                }
            }
            else {
                for (var _a = 0, components_6 = components; _a < components_6.length; _a++) {
                    var component = components_6[_a];
                    if (component && component._isStarted) {
                        component.onLateUpdate && component.onLateUpdate(deltaTime);
                    }
                }
            }
            //
            egret.ticker.update(); // TODO 帧频
            //
            if (this._laterCalls.length > 0) {
                for (var _b = 0, _c = this._laterCalls; _b < _c.length; _b++) {
                    var callback = _c[_b];
                    callback();
                }
                this._laterCalls.length = 0;
            }
        };
        /**
         *
         */
        LaterUpdateSystem.prototype.callLater = function (callback) {
            this._laterCalls.push(callback);
        };
        return LaterUpdateSystem;
    }(paper.BaseSystem));
    paper.LaterUpdateSystem = LaterUpdateSystem;
    __reflect(LaterUpdateSystem.prototype, "paper.LaterUpdateSystem");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * uniform类型枚举
     */
    var UniformTypeEnum;
    (function (UniformTypeEnum) {
        UniformTypeEnum[UniformTypeEnum["Texture"] = 0] = "Texture";
        UniformTypeEnum[UniformTypeEnum["Int"] = 1] = "Int";
        UniformTypeEnum[UniformTypeEnum["Boolean"] = 2] = "Boolean";
        UniformTypeEnum[UniformTypeEnum["Float"] = 3] = "Float";
        UniformTypeEnum[UniformTypeEnum["Floatv"] = 4] = "Floatv";
        UniformTypeEnum[UniformTypeEnum["Float2"] = 5] = "Float2";
        UniformTypeEnum[UniformTypeEnum["Float2v"] = 6] = "Float2v";
        UniformTypeEnum[UniformTypeEnum["Float3"] = 7] = "Float3";
        UniformTypeEnum[UniformTypeEnum["Float3v"] = 8] = "Float3v";
        UniformTypeEnum[UniformTypeEnum["Float4"] = 9] = "Float4";
        UniformTypeEnum[UniformTypeEnum["Float4v"] = 10] = "Float4v";
        UniformTypeEnum[UniformTypeEnum["Float4x4"] = 11] = "Float4x4";
        UniformTypeEnum[UniformTypeEnum["Float4x4v"] = 12] = "Float4x4v";
    })(UniformTypeEnum = egret3d.UniformTypeEnum || (egret3d.UniformTypeEnum = {}));
    var ShowFaceStateEnum;
    (function (ShowFaceStateEnum) {
        ShowFaceStateEnum[ShowFaceStateEnum["ALL"] = 0] = "ALL";
        ShowFaceStateEnum[ShowFaceStateEnum["CCW"] = 1] = "CCW";
        ShowFaceStateEnum[ShowFaceStateEnum["CW"] = 2] = "CW";
    })(ShowFaceStateEnum = egret3d.ShowFaceStateEnum || (egret3d.ShowFaceStateEnum = {}));
    var DrawModeEnum;
    (function (DrawModeEnum) {
        DrawModeEnum[DrawModeEnum["VboTri"] = 0] = "VboTri";
        DrawModeEnum[DrawModeEnum["VboLine"] = 1] = "VboLine";
        DrawModeEnum[DrawModeEnum["EboTri"] = 2] = "EboTri";
        DrawModeEnum[DrawModeEnum["EboLine"] = 3] = "EboLine";
    })(DrawModeEnum = egret3d.DrawModeEnum || (egret3d.DrawModeEnum = {}));
    var BlendModeEnum;
    (function (BlendModeEnum) {
        BlendModeEnum[BlendModeEnum["Close"] = 0] = "Close";
        BlendModeEnum[BlendModeEnum["Blend"] = 1] = "Blend";
        BlendModeEnum[BlendModeEnum["Blend_PreMultiply"] = 2] = "Blend_PreMultiply";
        BlendModeEnum[BlendModeEnum["Add"] = 3] = "Add";
        BlendModeEnum[BlendModeEnum["Add_PreMultiply"] = 4] = "Add_PreMultiply";
    })(BlendModeEnum = egret3d.BlendModeEnum || (egret3d.BlendModeEnum = {}));
    var DrawPass = (function () {
        function DrawPass(vShaderInfo, fShaderInfo) {
            this.state_showface = ShowFaceStateEnum.CCW;
            this.state_zwrite = false;
            this.state_ztest = false;
            this.state_ztest_method = egret3d.WebGLKit.LEQUAL;
            this.state_blend = false;
            this.state_blendEquation = 0;
            this.state_blendSrcRGB = 0;
            this.state_blendDestRGB = 0;
            this.state_blendSrcAlpha = 0;
            this.state_blendDestALpha = 0;
            this.vShaderInfo = vShaderInfo;
            this.fShaderInfo = fShaderInfo;
        }
        DrawPass.prototype.setAlphaBlend = function (mode) {
            if (mode === BlendModeEnum.Add) {
                this.state_blend = true;
                this.state_blendEquation = egret3d.WebGLKit.FUNC_ADD;
                this.state_blendSrcRGB = egret3d.WebGLKit.SRC_ALPHA;
                this.state_blendDestRGB = egret3d.WebGLKit.ONE;
                this.state_blendSrcAlpha = egret3d.WebGLKit.SRC_ALPHA;
                this.state_blendDestALpha = egret3d.WebGLKit.ONE;
            }
            else if (mode === BlendModeEnum.Add_PreMultiply) {
                this.state_blend = true;
                this.state_blendEquation = egret3d.WebGLKit.FUNC_ADD;
                this.state_blendSrcRGB = egret3d.WebGLKit.ONE;
                this.state_blendDestRGB = egret3d.WebGLKit.ONE;
                this.state_blendSrcAlpha = egret3d.WebGLKit.ONE;
                this.state_blendDestALpha = egret3d.WebGLKit.ONE;
            }
            else if (mode === BlendModeEnum.Blend) {
                this.state_blend = true;
                this.state_blendEquation = egret3d.WebGLKit.FUNC_ADD;
                this.state_blendSrcRGB = egret3d.WebGLKit.SRC_ALPHA;
                this.state_blendDestRGB = egret3d.WebGLKit.ONE_MINUS_SRC_ALPHA;
                this.state_blendSrcAlpha = egret3d.WebGLKit.ONE;
                this.state_blendDestALpha = egret3d.WebGLKit.ONE_MINUS_SRC_ALPHA;
            }
            else if (mode === BlendModeEnum.Blend_PreMultiply) {
                this.state_blend = true;
                this.state_blendEquation = egret3d.WebGLKit.FUNC_ADD;
                this.state_blendSrcRGB = egret3d.WebGLKit.ONE;
                this.state_blendDestRGB = egret3d.WebGLKit.ONE_MINUS_SRC_ALPHA;
                this.state_blendSrcAlpha = egret3d.WebGLKit.ONE;
                this.state_blendDestALpha = egret3d.WebGLKit.ONE_MINUS_SRC_ALPHA;
            }
            else if (mode === BlendModeEnum.Close) {
                this.state_blend = false;
            }
        };
        return DrawPass;
    }());
    egret3d.DrawPass = DrawPass;
    __reflect(DrawPass.prototype, "egret3d.DrawPass");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * shader asset
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 着色器资源。
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Shader = (function (_super) {
        __extends(Shader, _super);
        function Shader() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 渲染队列
             */
            _this.renderQueue = egret3d.RenderQueue.Geometry;
            _this.passes = {};
            /**
             *
             */
            _this.defaultValue = {};
            return _this;
        }
        /**
         *
         */
        Shader.registerVertShader = function (name, src) {
            var info = {
                name: name,
                src: src
            };
            this._vertShaderInfoMap[name] = info;
            return info;
        };
        /**
         *
         */
        Shader.registerFragShader = function (name, src) {
            var info = {
                name: name,
                src: src
            };
            this._fragShaderInfoMap[name] = info;
            return info;
        };
        /**
         * TODO 应补全接口和枚举。
         *
         */
        Shader.prototype.$parse = function (json) {
            this._parseProperties(json.properties);
            if (json.layer) {
                var layer = json.layer;
                if (layer === "transparent") {
                    this.renderQueue = egret3d.RenderQueue.Transparent;
                }
                else if (layer === "overlay") {
                    this.renderQueue = egret3d.RenderQueue.Overlay;
                }
                else if (layer === "common") {
                    this.renderQueue = egret3d.RenderQueue.Geometry;
                }
            }
            // if (json.queue) {
            //     this.queue = json.queue;
            // }
            var passes = json.passes;
            for (var k in passes) {
                var pass = passes[k];
                if (k === "base" || k === "lightmap" || k === "skin" || k === "quad") {
                }
                else if (k.indexOf("base_") === 0 || k.indexOf("lightmap_") === 0 || k.indexOf("skin_") === 0) {
                }
                else {
                    continue;
                }
                this.passes[k] = [];
                for (var i = 0; i < pass.length; i++) {
                    this.passes[k].push(this._parsePass(pass[i]));
                }
            }
            if (!this.passes["base"]) {
                throw new Error("do not have base pass group.");
            }
        };
        Shader.prototype._parseProperties = function (properties) {
            for (var k in properties) {
                var property = properties[k];
                var words = property.match(egret3d.RegexpUtil.floatRegexp);
                if (!words)
                    words = property.match(egret3d.RegexpUtil.rangeRegexp);
                if (!words)
                    words = property.match(egret3d.RegexpUtil.vectorRegexp);
                if (!words)
                    words = property.match(egret3d.RegexpUtil.textureRegexp);
                if (!words) {
                    console.error("Asset (" + this.url + ") property error! info:\n" + property);
                    return;
                }
                if (words.length >= 4) {
                    var key = words[1];
                    // let showName = words[2];
                    var type = words[3].toLowerCase();
                    switch (type) {
                        case "float":
                            this.defaultValue[key] = { type: type, value: parseFloat(words[4]) };
                            break;
                        case "range":
                            this.defaultValue[key] = { type: type, min: parseFloat(words[4]), max: parseFloat(words[5]), value: parseFloat(words[6]) };
                            break;
                        case "vector":
                        case "color":
                            var _vector = new egret3d.Vector4(parseFloat(words[4]), parseFloat(words[5]), parseFloat(words[6]), parseFloat(words[7]));
                            this.defaultValue[key] = { type: type, value: _vector };
                            break;
                        case "texture":
                            this.defaultValue[key] = { type: type, value: paper.Asset.find(words[4]) };
                            break;
                        default:
                            console.log("Asset (" + this.url + ") property error! unknown type : " + type);
                            break;
                    }
                }
            }
        };
        /**
         * TODO 应补全接口和枚举。
         */
        Shader.prototype._parsePass = function (json) {
            var vs = Shader._vertShaderInfoMap[json["vs"]];
            var fs = Shader._fragShaderInfoMap[json["fs"]];
            if (!vs) {
                console.error("vertex shader " + json["vs"] + " not found!");
            }
            if (!fs) {
                console.error("fragment shader " + json["fs"] + " not found!");
            }
            var blendmode = egret3d.BlendModeEnum.Close;
            var pass = new egret3d.DrawPass(vs, fs);
            pass.state_ztest = true;
            switch (json["showface"]) {
                case "cw":
                    pass.state_showface = egret3d.ShowFaceStateEnum.CW;
                    break;
                case "ccw":
                    pass.state_showface = egret3d.ShowFaceStateEnum.CCW;
                    break;
                default:
                    pass.state_showface = egret3d.ShowFaceStateEnum.ALL;
                    break;
            }
            switch (json["zwrite"]) {
                case "off":
                    pass.state_zwrite = false;
                    break;
                case "on":
                default:
                    pass.state_zwrite = true;
                    break;
            }
            switch (json["ztest"]) {
                case "greater":
                    pass.state_ztest_method = egret3d.WebGLKit.GREATER;
                    break;
                case "gequal":
                    pass.state_ztest_method = egret3d.WebGLKit.GEQUAL;
                    break;
                case "less":
                    pass.state_ztest_method = egret3d.WebGLKit.LESS;
                    break;
                case "equal":
                    pass.state_ztest_method = egret3d.WebGLKit.EQUAL;
                    break;
                case "notequal":
                    pass.state_ztest_method = egret3d.WebGLKit.NOTEQUAL;
                    break;
                case "always":
                case "off":
                    pass.state_ztest = false;
                    break;
                case "never":
                    pass.state_ztest_method = egret3d.WebGLKit.NEVER;
                    break;
                case "lequal":
                default:
                    pass.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                    break;
            }
            switch (json["blendmode"]) {
                case "add":
                    blendmode = egret3d.BlendModeEnum.Add;
                    break;
                case "addpremult":
                    blendmode = egret3d.BlendModeEnum.Add_PreMultiply;
                    break;
                case "blend":
                    blendmode = egret3d.BlendModeEnum.Blend;
                    break;
                case "blendpremult":
                    blendmode = egret3d.BlendModeEnum.Blend_PreMultiply;
                    break;
            }
            pass.setAlphaBlend(blendmode);
            if (this.renderQueue === egret3d.RenderQueue.Overlay) {
                pass.state_ztest = true;
                pass.state_zwrite = true;
                pass.state_ztest_method = egret3d.WebGLKit.ALWAYS;
            }
            return pass;
        };
        /**
         * @inheritDoc
         */
        Shader.prototype.dispose = function () {
            for (var k in this.passes) {
                delete this.passes[k];
            }
            for (var k in this.defaultValue) {
                delete this.defaultValue[k];
            }
        };
        /**
         * @inheritDoc
         */
        Shader.prototype.caclByteLength = function () {
            return 0;
        };
        Shader._vertShaderInfoMap = {};
        Shader._fragShaderInfoMap = {};
        return Shader;
    }(paper.Asset));
    egret3d.Shader = Shader;
    __reflect(Shader.prototype, "egret3d.Shader");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = new egret3d.Vector3();
    var _helpVector3B = new egret3d.Vector3();
    var _helpVector3C = new egret3d.Vector3();
    var _helpVector3D = new egret3d.Vector3();
    var _helpVector3E = new egret3d.Vector3();
    var _helpVector3F = new egret3d.Vector3();
    var _helpVector3G = new egret3d.Vector3();
    var _helpVector3H = new egret3d.Vector3();
    var _helpVectors = [
        _helpVector3A,
        _helpVector3B,
        _helpVector3C,
        _helpVector3D,
        _helpVector3E,
        _helpVector3F,
        _helpVector3G,
        _helpVector3H,
    ];
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpVec3_3 = new egret3d.Vector3();
    var helpVec3_4 = new egret3d.Vector3();
    var helpVec3_5 = new egret3d.Vector3();
    var boxIndices = [
        0, 1, 2, 3,
        4, 5, 6, 7,
        1, 3, 5, 7,
        0, 2, 4, 6,
        6, 2, 7, 3,
        0, 4, 1, 5
    ];
    /**
     * 射线
     */
    var Ray = (function () {
        /**
         * 构建一条射线
         * @param origin 射线起点
         * @param dir 射线方向
         */
        function Ray(origin, direction) {
            this.origin = egret3d.Vector3.copy(origin, new egret3d.Vector3());
            this.direction = egret3d.Vector3.copy(direction, new egret3d.Vector3());
        }
        /**
         * 与aabb碰撞相交检测
         */
        Ray.prototype.intersectAABB = function (aabb) {
            return this.intersectBoxMinMax(aabb.minimum, aabb.maximum);
        };
        /**
         * 与transform表示的plane碰撞相交检测，主要用于2d检测
         * @param transform transform实例
         */
        Ray.prototype.intersectPlaneTransform = function (transform) {
            var pickinfo = null;
            var panelpoint = transform.getPosition();
            var forward = helpVec3_1;
            transform.getForward(forward);
            var hitposition = this.intersectPlane(panelpoint, forward);
            if (hitposition) {
                pickinfo = new PickInfo();
                pickinfo.hitposition = hitposition;
                pickinfo.distance = egret3d.Vector3.getDistance(pickinfo.hitposition, this.origin);
            }
            return pickinfo;
        };
        Ray.prototype.intersectPlane = function (planePoint, planeNormal) {
            var vp1 = planeNormal.x;
            var vp2 = planeNormal.y;
            var vp3 = planeNormal.z;
            var n1 = planePoint.x;
            var n2 = planePoint.y;
            var n3 = planePoint.z;
            var v1 = this.direction.x;
            var v2 = this.direction.y;
            var v3 = this.direction.z;
            var m1 = this.origin.x;
            var m2 = this.origin.y;
            var m3 = this.origin.z;
            var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
            if (vpt === 0) {
                return null;
            }
            else {
                var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                return new egret3d.Vector3(m1 + v1 * t, m2 + v2 * t, m3 + v3 * t);
            }
        };
        /**
         * 与最大最小点表示的box相交检测
         * @param minimum 最小点
         * @param maximum 最大点
         * @version paper 1.0
         */
        Ray.prototype.intersectBoxMinMax = function (minimum, maximum) {
            var d = 0.0;
            var maxValue = Number.MAX_VALUE;
            var inv;
            var min;
            var max;
            var temp;
            if (Math.abs(this.direction.x) < 0.0000001) {
                if (this.origin.x < minimum.x || this.origin.x > maximum.x) {
                    return false;
                }
            }
            else {
                inv = 1.0 / this.direction.x;
                min = (minimum.x - this.origin.x) * inv;
                max = (maximum.x - this.origin.x) * inv;
                if (max === -Infinity) {
                    max = Infinity;
                }
                if (min > max) {
                    temp = min;
                    min = max;
                    max = temp;
                }
                d = Math.max(min, d);
                maxValue = Math.min(max, maxValue);
                if (d > maxValue) {
                    return false;
                }
            }
            if (Math.abs(this.direction.y) < 0.0000001) {
                if (this.origin.y < minimum.y || this.origin.y > maximum.y) {
                    return false;
                }
            }
            else {
                inv = 1.0 / this.direction.y;
                min = (minimum.y - this.origin.y) * inv;
                max = (maximum.y - this.origin.y) * inv;
                if (max === -Infinity) {
                    max = Infinity;
                }
                if (min > max) {
                    temp = min;
                    min = max;
                    max = temp;
                }
                d = Math.max(min, d);
                maxValue = Math.min(max, maxValue);
                if (d > maxValue) {
                    return false;
                }
            }
            if (Math.abs(this.direction.z) < 0.0000001) {
                if (this.origin.z < minimum.z || this.origin.z > maximum.z) {
                    return false;
                }
            }
            else {
                inv = 1.0 / this.direction.z;
                min = (minimum.z - this.origin.z) * inv;
                max = (maximum.z - this.origin.z) * inv;
                if (max === -Infinity) {
                    max = Infinity;
                }
                if (min > max) {
                    temp = min;
                    min = max;
                    max = temp;
                }
                d = Math.max(min, d);
                maxValue = Math.min(max, maxValue);
                if (d > maxValue) {
                    return false;
                }
            }
            return true;
        };
        /**
         * 与球相交检测
         */
        Ray.prototype.intersectsSphere = function (center, radius) {
            var center_ori = helpVec3_1;
            egret3d.Vector3.subtract(center, this.origin, center_ori);
            var raydist = egret3d.Vector3.dot(this.direction, center_ori);
            if (raydist < 0)
                return false; // 到圆心的向量在方向向量上的投影为负，夹角不在-90与90之间
            var orilen2 = egret3d.Vector3.getSqrLength(center_ori);
            var rad2 = radius * radius;
            if (orilen2 < rad2)
                return true; // 射线起点在球里
            var d = rad2 - (orilen2 - raydist * raydist);
            if (d < 0)
                return false;
            return true;
        };
        /**
         * 与三角形相交检测
         */
        Ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2) {
            var _edge1 = helpVec3_1;
            var _edge2 = helpVec3_2;
            var _pvec = helpVec3_3;
            var _tvec = helpVec3_4;
            var _qvec = helpVec3_5;
            egret3d.Vector3.subtract(vertex1, vertex0, _edge1);
            egret3d.Vector3.subtract(vertex2, vertex0, _edge2);
            egret3d.Vector3.cross(this.direction, _edge2, _pvec);
            var det = egret3d.Vector3.dot(_edge1, _pvec);
            if (det === 0) {
                return null;
            }
            var invdet = 1 / det;
            egret3d.Vector3.subtract(this.origin, vertex0, _tvec);
            var bu = egret3d.Vector3.dot(_tvec, _pvec) * invdet;
            if (bu < 0 || bu > 1.0) {
                return null;
            }
            egret3d.Vector3.cross(_tvec, _edge1, _qvec);
            var bv = egret3d.Vector3.dot(this.direction, _qvec) * invdet;
            if (bv < 0 || bu + bv > 1.0) {
                return null;
            }
            var pickInfo = new PickInfo();
            pickInfo.distance = egret3d.Vector3.dot(_edge2, _qvec) * invdet;
            pickInfo.textureCoordA.x = bu;
            pickInfo.textureCoordA.y = bv;
            return pickInfo;
        };
        /**
         * 获取射线拾取到的最近物体。
         */
        Ray.raycast = function (ray, isPickMesh, maxDistance, layerMask) {
            if (isPickMesh === void 0) { isPickMesh = false; }
            if (maxDistance === void 0) { maxDistance = Number.MAX_VALUE; }
            if (layerMask === void 0) { layerMask = 2 /* Default */ | 4 /* UI */; }
            return this._doPick(ray, maxDistance, layerMask, false, isPickMesh);
        };
        /**
         * 获取射线路径上的所有物体。
         */
        Ray.raycastAll = function (ray, isPickMesh, maxDistance, layerMask) {
            if (isPickMesh === void 0) { isPickMesh = false; }
            if (maxDistance === void 0) { maxDistance = Number.MAX_VALUE; }
            if (layerMask === void 0) { layerMask = 2 /* Default */ | 4 /* UI */; }
            return this._doPick(ray, maxDistance, layerMask, true, isPickMesh);
        };
        Ray._doPick = function (ray, maxDistance, layerMask, pickAll, isPickMesh) {
            if (maxDistance === void 0) { maxDistance = Number.MAX_VALUE; }
            if (pickAll === void 0) { pickAll = false; }
            if (isPickMesh === void 0) { isPickMesh = false; }
            var pickedList = [];
            for (var _i = 0, _a = paper.Application.sceneManager.activeScene.getRootGameObjects(); _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.layer & layerMask) {
                    if (isPickMesh) {
                        this._pickMesh(ray, gameObject.transform, pickedList);
                    }
                    else {
                        this._pickCollider(ray, gameObject.transform, pickedList);
                    }
                }
            }
            if (pickedList.length === 0) {
                return null;
            }
            if (pickAll) {
                return pickedList;
            }
            var index = 0;
            for (var i = 1; i < pickedList.length; i++) {
                if (pickedList[i].distance < pickedList[index].distance) {
                    index = i;
                }
            }
            return pickedList[index];
        };
        Ray._pickMesh = function (ray, transform, pickInfos) {
            if (transform.gameObject.activeInHierarchy) {
                var meshFilter = transform.gameObject.getComponent(egret3d.MeshFilter);
                if (meshFilter) {
                    var mesh = meshFilter.mesh;
                    if (mesh) {
                        var pickinfo = mesh.intersects(ray, transform.getWorldMatrix());
                        if (pickinfo) {
                            pickInfos.push(pickinfo);
                            pickinfo.transform = transform;
                        }
                    }
                }
                else {
                    var skinmesh = transform.gameObject.getComponent(egret3d.SkinnedMeshRenderer);
                    if (skinmesh) {
                        var pickinfo = skinmesh.intersects(ray);
                        if (pickinfo) {
                            pickInfos.push(pickinfo);
                            pickinfo.transform = transform;
                        }
                    }
                }
            }
            for (var _i = 0, _a = transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                this._pickMesh(ray, child, pickInfos);
            }
        };
        Ray._pickCollider = function (ray, transform, pickInfos) {
            if (transform.gameObject.activeInHierarchy) {
                // const pickInfo = ray.intersectCollider(transform);
                // if (pickInfo) {
                //     pickInfos.push(pickInfo);
                //     pickInfo.transform = transform;
                // }
            }
            for (var _i = 0, _a = transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                this._pickCollider(ray, child, pickInfos);
            }
        };
        return Ray;
    }());
    egret3d.Ray = Ray;
    __reflect(Ray.prototype, "egret3d.Ray");
    /**
     * 场景拣选信息
     */
    var PickInfo = (function () {
        function PickInfo() {
            this.subMeshIndex = -1;
            this.triangleIndex = -1;
            this.distance = 0.0;
            this.position = new egret3d.Vector3();
            this.textureCoordA = new egret3d.Vector2();
            this.textureCoordB = new egret3d.Vector2();
            this.transform = null;
        }
        return PickInfo;
    }());
    egret3d.PickInfo = PickInfo;
    __reflect(PickInfo.prototype, "egret3d.PickInfo");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderLib;
    (function (ShaderLib) {
        ShaderLib.alphaBlend_frag = "\nuniform sampler2D _MainTex;\nuniform vec4 _TintColor;\nvarying highp vec2 xlv_TEXCOORD0;\n\nvoid main()\n{   \n gl_FragColor=texture2D(_MainTex,xlv_TEXCOORD0)*_TintColor*2.0;\n    gl_FragColor.a = clamp(gl_FragColor.a, 0.0, 1.0);\n}";
        ShaderLib.alphaCut_frag = "\nuniform sampler2D _MainTex;\nuniform lowp float _AlphaCut;\nvarying highp vec2 xlv_TEXCOORD0;\n\nvoid main()\n{   \n lowp vec4 outColor=texture2D(_MainTex,xlv_TEXCOORD0);\n    if(outColor.a < _AlphaCut)\n        discard;\n    gl_FragColor = outColor;\n}";
        ShaderLib.boneeff_vert = "attribute vec4 _glesVertex;   \nattribute vec4 _glesBlendIndex4;\nattribute vec4 _glesBlendWeight4;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp vec4 glstate_vec4_bones[110];\nuniform highp vec4 _MainTex_ST; \nvarying highp vec2 xlv_TEXCOORD0;\nmat4 buildMat4(int index)\n{\n vec4 quat = glstate_vec4_bones[index * 2 + 0];\n vec4 translation = glstate_vec4_bones[index * 2 + 1];\n float xy2 = 2.0 * quat.x * quat.y;\n float xz2 = 2.0 * quat.x * quat.z;\n float xw2 = 2.0 * quat.x * quat.w;\n float yz2 = 2.0 * quat.y * quat.z;\n float yw2 = 2.0 * quat.y * quat.w;\n float zw2 = 2.0 * quat.z * quat.w;\n float xx = quat.x * quat.x;\n float yy = quat.y * quat.y;\n float zz = quat.z * quat.z;\n float ww = quat.w * quat.w;\n mat4 matrix = mat4(\n xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,\n xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,\n xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,\n translation.x, translation.y, translation.z, 1);\n return matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,highp vec4 blendIndex,highp vec4 blendWeight)\n{\n int i = int(blendIndex.x);  \n    int i2 =int(blendIndex.y);\n int i3 =int(blendIndex.z);\n int i4 =int(blendIndex.w);\n \n    mat4 mat = buildMat4(i)*blendWeight.x \n    + buildMat4(i2)*blendWeight.y \n    + buildMat4(i3)*blendWeight.z \n    + buildMat4(i4)*blendWeight.w;\n return mat* srcVertex;\n}\n\n\nvoid main()\n{                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = calcVertex(_glesVertex,_glesBlendIndex4,_glesBlendWeight4).xyz;  \n    \n    gl_Position = glstate_matrix_mvp *  tmpvar_1;\n\n xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;  \n}";
        ShaderLib.bonelambert_vert = "attribute vec4 _glesVertex;   \nattribute vec3 _glesNormal; \nattribute vec4 _glesBlendIndex4;\nattribute vec4 _glesBlendWeight4;             \nattribute vec4 _glesMultiTexCoord0;    \n\nuniform mat4 glstate_matrix_mvp;      \nuniform mat4 glstate_matrix_model;\n\nuniform highp vec4 glstate_vec4_bones[110];\nuniform highp vec4 _MainTex_ST; \n\n#include <shadowMap_pars_vert>\n\nvarying vec3 xlv_POS;\nvarying vec3 xlv_NORMAL;                \nvarying vec2 xlv_TEXCOORD0;\n\n#include <transpose>\n#include <inverse>\n\nmat4 buildMat4(int index)\n{\n vec4 quat = glstate_vec4_bones[index * 2 + 0];\n vec4 translation = glstate_vec4_bones[index * 2 + 1];\n float xy2 = 2.0 * quat.x * quat.y;\n float xz2 = 2.0 * quat.x * quat.z;\n float xw2 = 2.0 * quat.x * quat.w;\n float yz2 = 2.0 * quat.y * quat.z;\n float yw2 = 2.0 * quat.y * quat.w;\n float zw2 = 2.0 * quat.z * quat.w;\n float xx = quat.x * quat.x;\n float yy = quat.y * quat.y;\n float zz = quat.z * quat.z;\n float ww = quat.w * quat.w;\n mat4 matrix = mat4(\n xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,\n xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,\n xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,\n translation.x, translation.y, translation.z, 1);\n return matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,highp vec4 blendIndex,highp vec4 blendWeight)\n{\n int i = int(blendIndex.x);  \n    int i2 =int(blendIndex.y);\n int i3 =int(blendIndex.z);\n int i4 =int(blendIndex.w);\n \n    mat4 mat = buildMat4(i)*blendWeight.x \n    + buildMat4(i2)*blendWeight.y \n    + buildMat4(i3)*blendWeight.z \n    + buildMat4(i4)*blendWeight.w;\n return mat* srcVertex;\n}\n\nvoid main() {   \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = calcVertex(_glesVertex,_glesBlendIndex4,_glesBlendWeight4).xyz;                            \n\n    vec3 normal = (transpose(inverse(glstate_matrix_model)) * vec4(_glesNormal, 1.0)).xyz;\n    xlv_NORMAL = normal;\n    #ifdef FLIP_SIDED\n     xlv_NORMAL = - xlv_NORMAL;\n    #endif\n\n    vec3 worldpos = (glstate_matrix_model * tmpvar_1).xyz;\n    xlv_POS = worldpos; \n\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n\n    #include <shadowMap_vert>\n     \n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
        ShaderLib.bone_vert = "attribute vec4 _glesVertex;   \nattribute vec4 _glesBlendIndex4;\nattribute vec4 _glesBlendWeight4;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_bones[24];\nuniform highp vec4 _MainTex_ST; \nvarying highp vec2 xlv_TEXCOORD0;\nvoid main()                                     \n{                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = _glesVertex.xyz;  \n \n    int i = int(_glesBlendIndex4.x);  \n    int i2 =int(_glesBlendIndex4.y);\n int i3 =int(_glesBlendIndex4.z);\n int i4 =int(_glesBlendIndex4.w);\n \n    mat4 mat = glstate_matrix_bones[i]*_glesBlendWeight4.x \n    + glstate_matrix_bones[i2]*_glesBlendWeight4.y \n    + glstate_matrix_bones[i3]*_glesBlendWeight4.z \n    + glstate_matrix_bones[i4]*_glesBlendWeight4.w;\n    \n    gl_Position = (glstate_matrix_mvp * mat)* tmpvar_1;\n\n xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n}";
        ShaderLib.code2_frag = "void main() {\n    gl_FragData[0] = vec4(1.0, 1.0, 1.0, 1.0);\n}";
        ShaderLib.code_frag = "uniform sampler2D _MainTex;                                                 \nvarying lowp vec4 xlv_COLOR;                                                 \nvarying highp vec2 xlv_TEXCOORD0;   \nvoid main() {\n    lowp vec4 col_1;    \n    mediump vec4 prev_2;\n    lowp vec4 tmpvar_3;\n    tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\n    prev_2 = tmpvar_3;\n    mediump vec4 tmpvar_4;\n    tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);\n    col_1 = tmpvar_4;\n    col_1.x =xlv_TEXCOORD0.x;\n    col_1.y =xlv_TEXCOORD0.y;\n    gl_FragData[0] = col_1;\n}";
        ShaderLib.code_vert = "attribute vec4 _glesVertex;\nattribute vec4 _glesColor;             \nattribute vec4 _glesMultiTexCoord0;    \nuniform highp mat4 glstate_matrix_mvp; \nvarying lowp vec4 xlv_COLOR;           \nvarying highp vec2 xlv_TEXCOORD0;      \nvoid main() {                                          \n    highp vec4 tmpvar_1;                   \n    tmpvar_1.w = 1.0;                      \n    tmpvar_1.xyz = _glesVertex.xyz;        \n    xlv_COLOR = _glesColor;                \n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
        ShaderLib.depthpackage_frag = "#include <packing>\n\nvoid main() {\n gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n}";
        ShaderLib.depthpackage_vert = "attribute vec3 _glesVertex;\n\nuniform mat4 glstate_matrix_mvp;\n\nvoid main() { \n    gl_Position = glstate_matrix_mvp * vec4(_glesVertex, 1.0);\n}";
        ShaderLib.diffuselightmap_frag = "uniform sampler2D _MainTex;\nuniform sampler2D _LightmapTex;\nuniform lowp float _LightmapIntensity;\nuniform lowp float _AlphaCut;\nvarying highp vec2 xlv_TEXCOORD0;\nvarying highp vec2 xlv_TEXCOORD1;\nlowp vec3 decode_hdr(lowp vec4 data, lowp float intensity)\n{\n    highp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * intensity;\n}\nvoid main() \n{\n    lowp vec4 outColor = texture2D(_MainTex, xlv_TEXCOORD0);\n    if(outColor.a < _AlphaCut)\n        discard;\n    lowp vec4 lightmap = texture2D(_LightmapTex, xlv_TEXCOORD1);\n    outColor.xyz *= decode_hdr(lightmap, _LightmapIntensity);\n    gl_FragData[0] = outColor;\n}";
        ShaderLib.diffuselightmap_vert = "attribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\nattribute vec4 _glesMultiTexCoord1;\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp vec4 glstate_lightmapOffset;\nuniform lowp float glstate_lightmapUV;\nuniform highp vec4 _MainTex_ST; \nvarying highp vec2 xlv_TEXCOORD0;\nvarying highp vec2 xlv_TEXCOORD1;\nvoid main()\n{\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;  \n\n    highp vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    if(glstate_lightmapUV == 0.0)\n    {\n        beforelightUV = _glesMultiTexCoord0.xy;\n    }\n    highp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    highp float v = 1.0 - ((1.0 - beforelightUV.y) * glstate_lightmapOffset.y + glstate_lightmapOffset.w);\n    xlv_TEXCOORD1 = vec2(u,v);\n\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
        ShaderLib.diffuse_frag = "uniform sampler2D _MainTex;\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main() {\n    lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);\n    gl_FragData[0] = tmpvar_3;\n}";
        ShaderLib.diffuse_vert = "attribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp vec4 _MainTex_ST;  \nvarying highp vec2 xlv_TEXCOORD0;\n\nvoid main() {\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;  \n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
        ShaderLib.distancepackage_frag = "#include <packing>\n\nvarying vec3 xlv_POS;\nuniform vec4 glstate_referencePosition;\nuniform float glstate_nearDistance;\nuniform float glstate_farDistance;\n\nvoid main() {\n    float dist = length( xlv_POS - glstate_referencePosition.xyz );\n dist = ( dist - glstate_nearDistance ) / ( glstate_farDistance - glstate_nearDistance );\n dist = saturate( dist ); // clamp to [ 0, 1 ]\n\n gl_FragColor = packDepthToRGBA( dist );\n}";
        ShaderLib.distancepackage_vert = "attribute vec3 _glesVertex;\n\nuniform mat4 glstate_matrix_mvp;\nuniform mat4 glstate_matrix_model;\n\nvarying vec3 xlv_POS;\n\nvoid main() {   \n    xlv_POS = (glstate_matrix_model * vec4(_glesVertex, 1.0)).xyz;\n    gl_Position = glstate_matrix_mvp * vec4(_glesVertex, 1.0);\n}";
        ShaderLib.lambert_frag = "// #extension GL_OES_standard_derivatives : enable\n\nuniform sampler2D _MainTex;\nuniform vec4 _Color;         \n\n#include <bsdfs>\n#include <light_pars_frag>\n#include <shadowMap_pars_frag>\n\nvarying vec3 xlv_POS;\nvarying vec3 xlv_NORMAL;                \nvarying vec2 xlv_TEXCOORD0;\n\n#ifdef USE_NORMAL_MAP\n    #include <tbn>\n    #include <tsn>\n    uniform sampler2D _NormalTex;\n#endif\n\n#include <bumpMap_pars_frag>\n\nvoid main() {\n    vec4 outColor = vec4(0., 0., 0., 1.);\n\n    vec4 diffuseColor = _Color * texture2D(_MainTex, xlv_TEXCOORD0);\n\n    #include <normal_frag>\n    #include <light_frag>\n    \n    outColor.a = diffuseColor.a;\n\n    gl_FragColor = outColor;\n}";
        ShaderLib.lambert_vert = "attribute vec3 _glesVertex;   \nattribute vec3 _glesNormal;               \nattribute vec4 _glesMultiTexCoord0;    \n\nuniform mat4 glstate_matrix_mvp;      \nuniform mat4 glstate_matrix_model;\n\n#include <shadowMap_pars_vert>\n\nvarying vec3 xlv_POS;\nvarying vec3 xlv_NORMAL;                \nvarying vec2 xlv_TEXCOORD0;\n\n#include <transpose>\n#include <inverse>\n\nvoid main() {   \n    vec4 tmpvar_1 = vec4(_glesVertex.xyz, 1.0);                            \n\n    vec3 normal = (transpose(inverse(glstate_matrix_model)) * vec4(_glesNormal, 1.0)).xyz;\n    xlv_NORMAL = normal;\n    #ifdef FLIP_SIDED\n     xlv_NORMAL = - xlv_NORMAL;\n    #endif\n\n    vec3 worldpos = (glstate_matrix_model * tmpvar_1).xyz;\n    xlv_POS = worldpos; \n\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n\n    #include <shadowMap_vert>\n     \n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
        ShaderLib.line_frag = "varying lowp vec4 xlv_COLOR;\nvoid main() {\n    gl_FragData[0] = xlv_COLOR;\n}";
        ShaderLib.line_vert = "attribute vec4 _glesVertex;\nattribute vec4 _glesColor;\nuniform highp mat4 glstate_matrix_mvp;\nvarying lowp vec4 xlv_COLOR;\nvoid main() {\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_COLOR = _glesColor;\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
        ShaderLib.materialcolor_vert = "attribute vec4 _glesVertex;\nuniform vec4 _Color;\nuniform highp mat4 glstate_matrix_mvp;\nvarying lowp vec4 xlv_COLOR;\nvoid main() {\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_COLOR = _Color;\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
        ShaderLib.particlesystem_frag = "\nuniform sampler2D _MainTex;\nuniform vec4 _TintColor;\nvarying float v_discard;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\n\n#ifdef RENDERMODE_MESH\n varying vec4 v_mesh_color;\n#endif\n\nvoid main()\n{ \n #ifdef RENDERMODE_MESH\n  gl_FragColor=v_mesh_color;\n #else\n  gl_FragColor=vec4(1.0); \n #endif\n  \n #ifdef DIFFUSEMAP\n  if(v_discard!=0.0)\n   discard;\n  #ifdef TINTCOLOR\n   gl_FragColor*=texture2D(_MainTex,v_texcoord)*_TintColor*v_color*2.0;\n  #else\n   gl_FragColor*=texture2D(_MainTex,v_texcoord)*v_color;\n  #endif\n #else\n  #ifdef TINTCOLOR\n   gl_FragColor*=_TintColor*v_color*2.0;\n  #else\n   gl_FragColor*=v_color;\n  #endif\n #endif\n}";
        ShaderLib.particlesystem_vert = "#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n attribute vec2 _glesCorner;\n#endif\n#ifdef RENDERMESH\n attribute vec3 _glesVertex;\n attribute vec4 _glesColor;\n#endif\nattribute vec2 _glesMultiTexCoord0;\nattribute vec3 _startPosition;\nattribute vec3 _startVelocity;\nattribute vec4 _startColor;\nattribute vec3 _startSize;\nattribute vec3 _startRotation;\nattribute vec2 _time;\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)||defined(ROTATIONTWOCONSTANTS)||defined(ROTATIONTWOCURVES)\n  attribute vec4 _random0;\n#endif\n#if defined(TEXTURESHEETANIMATIONTWOCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n  attribute vec4 _random1;\n#endif\nattribute vec3 _startWorldPosition;\nattribute vec4 _startWorldRotation;\n\n#include <particle_common>\n\nvoid main()\n{\n float age = u_currentTime - _time.y;\n float t = age/_time.x;\n if(t>1.0){    \n   v_discard=1.0;\n   return;\n  }\n   \n #include <particle_affector>\n gl_Position=glstate_matrix_vp*vec4(center,1.0);\n v_color = computeColor(_startColor, t);\n #ifdef DIFFUSEMAP\n  v_texcoord =computeUV(_glesMultiTexCoord0, t);\n #endif\n v_discard=0.0;\n}\n\n";
        ShaderLib.postdepth_frag = "precision highp float;\n//varying highp vec3 xlv_Normal;   \n\nconst float PackUpscale = 256. / 255.; \n// fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; \n// 0..1 -> fraction (excluding 1)\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) \n{\n    vec4 r = vec4( fract( v * PackFactors ), v );\n r.yzw -= r.xyz * ShiftRight8;\n // tidy overflow\n    return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) \n{\n    return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( const in float v ) \n{\n    vec2 r = vec2( fract( v * PackFactors.z ), v );\n r.y -= r.x * ShiftRight8;\n    return r * PackUpscale;\n}\nfloat unpackRGToDepth( const in vec2 v ) \n{\n    return dot( v.xy, UnpackFactors.zw );\n}\nvec3 packDepthToRGB( const in float v ) \n{\n    vec3 r = vec3( fract( v * PackFactors.yz ), v );\n r.yz -= r.xy * ShiftRight8;\n // tidy overflow\n    return r * PackUpscale;\n}\nfloat unpackRGBToDepth( const in vec3 v ) \n{\n    return dot( v.xyz, UnpackFactors.yzw );\n}\nvoid main() \n{\n    float z = gl_FragCoord.z;// fract(gl_FragCoord.z *256.*256.);\n    // highp vec2 normal =xlv_Normal.xy;\n    gl_FragColor=packDepthToRGBA(z);\n}";
        ShaderLib.postdepth_vert = "precision highp float;\nattribute vec4 _glesVertex;    \n\nuniform highp mat4 glstate_matrix_mvp;      \n            \nvoid main()                                     \n{        \n    gl_Position = (glstate_matrix_mvp * _glesVertex);  \n}";
        ShaderLib.postquaddepth_frag = "precision mediump float;\nvarying highp vec2 xlv_TEXCOORD0;       \nuniform sampler2D _DepthTex;   \nuniform sampler2D _MainTex;  \n\n\nconst float PackUpscale = 256. / 255.; \n// fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; \n// 0..1 -> fraction (excluding 1)\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) \n{\n    vec4 r = vec4( fract( v * PackFactors ), v );\n r.yzw -= r.xyz * ShiftRight8;\n // tidy overflow\n    return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) \n{\n    return dot( v, UnpackFactors );\n}\n\n\nfloat planeDistance(const in vec3 positionA, const in vec3 normalA, \n                    const in vec3 positionB, const in vec3 normalB) \n{\n  vec3 positionDelta = positionB-positionA;\n  float planeDistanceDelta = max(abs(dot(positionDelta, normalA)), abs(dot(positionDelta, normalB)));\n  return planeDistanceDelta;\n}\n\nvoid main()         \n{\n    lowp vec4 c1=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0.001,0));\n    lowp vec4 c2=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(-0.001,0));\n    lowp vec4 c3=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0,0.001));\n    lowp vec4 c4=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0,-0.001));\n    highp float z1 = unpackRGBAToDepth(c1);\n    highp float z2 = unpackRGBAToDepth(c2);\n    highp float z3 = unpackRGBAToDepth(c3);\n    highp float z4 = unpackRGBAToDepth(c4);\n    highp float d = clamp(  (abs(z2-z1)+abs(z4-z3))*10.0,0.0,1.0);\n    lowp vec4 c=texture2D(_MainTex, xlv_TEXCOORD0);\n    lowp float g = c.r*0.3+c.g*0.6+c.b*0.1;\n\n    gl_FragColor =mix(vec4(g,g,g,1.),vec4(1.0,1.0,0.0,1.0),d);// vec4(g*d,g*d,g*d,1.0);\n}";
        ShaderLib.postquad_vert = "attribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0; \nuniform highp vec4 _MainTex_ST; \nvarying highp vec2 xlv_TEXCOORD0;   \nvoid main()                     \n{ \n    gl_Position = _glesVertex;\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw; \n}   ";
        ShaderLib.tintcolor_frag = "uniform sampler2D _MainTex;\nuniform lowp float _AlphaCut;\nuniform lowp vec4 _TintColor;\n\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main() \n{\n    lowp vec4 tmpvar_3 = _TintColor*texture2D(_MainTex, xlv_TEXCOORD0);\n    if(tmpvar_3.a < _AlphaCut)\n        discard;\n    gl_FragData[0] = tmpvar_3;\n}";
        ShaderLib.transparentdiffuse_vert = "";
        ShaderLib.uifont_frag = "precision mediump float;\nuniform sampler2D _MainTex;\nvarying lowp vec4 xlv_COLOR;\nvarying lowp vec4 xlv_COLOREx;\nvarying highp vec2 xlv_TEXCOORD0;  \nvoid main() {\n    float scale = 10.0;\n    float d = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.5) * scale;  //0.5\n    float bd = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.34) * scale;  //0.34\n\n    float c=xlv_COLOR.a * clamp ( d,0.0,1.0);\n    float bc=xlv_COLOREx.a * clamp ( bd,0.0,1.0);\n    bc =min(1.0-c,bc);\n\n    gl_FragData[0] =xlv_COLOR*c + xlv_COLOREx*bc;\n}";
        ShaderLib.uifont_vert = "attribute vec4 _glesVertex;   \nattribute vec4 _glesColor;                  \nattribute vec4 _glesColorEx;                  \nattribute vec4 _glesMultiTexCoord0;         \nuniform highp mat4 glstate_matrix_mvp;      \nvarying lowp vec4 xlv_COLOR;                \nvarying lowp vec4 xlv_COLOREx;                                                 \nvarying highp vec2 xlv_TEXCOORD0;           \nvoid main() {                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = _glesVertex.xyz;             \n    xlv_COLOR = _glesColor;                     \n    xlv_COLOREx = _glesColorEx;                     \n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;     \n    gl_Position = (glstate_matrix_mvp * tmpvar_1);  \n}";
        ShaderLib.ui_frag = "uniform sampler2D _MainTex;\nvarying lowp vec4 xlv_COLOR;\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main() {\n    lowp vec4 tmpvar_3;\n    tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\n    gl_FragData[0] = tmpvar_3;\n}";
        ShaderLib.vertcolor_frag = "uniform sampler2D _MainTex;                                                 \nvarying lowp vec4 xlv_COLOR;                                                 \nvarying highp vec2 xlv_TEXCOORD0;   \nvoid main() \n{\n    lowp vec4 col_1;    \n    mediump vec4 prev_2;\n    lowp vec4 tmpvar_3;\n\n    tmpvar_3 = (texture2D(_MainTex, xlv_TEXCOORD0));\n    //prev_2 = tmpvar_3;\n    //mediump vec4 tmpvar_4;\n    //tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);\n    //col_1 = tmpvar_4;\n    //col_1.x = xlv_TEXCOORD0.x;\n    //col_1.y = xlv_TEXCOORD0.y;\n    gl_FragData[0] = tmpvar_3;\n}";
        ShaderLib.vertcolor_vert = "attribute vec4 _glesVertex;   \nattribute vec4 _glesNormal;   \nattribute vec4 _glesColor;                  \nattribute vec4 _glesMultiTexCoord0;        \nuniform highp mat4 glstate_matrix_mvp;   \nvarying lowp vec4 xlv_COLOR;                \nvarying highp vec2 xlv_TEXCOORD0;   \n\nuniform highp vec4 _MainTex_ST;       \n\nvoid main()                                     \n{                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = _glesVertex.xyz;             \n    xlv_COLOR = _glesColor;                     \n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;   \n\n    //xlv_COLOR.xyz =pos.xyz;\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);  \n}\n";
    })(ShaderLib = egret3d.ShaderLib || (egret3d.ShaderLib = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderChunk;
    (function (ShaderChunk) {
        ShaderChunk.begin_vert = "vec3 transformed = vec3(_glesVertex);\n// #if defined(USE_NORMAL) || defined(USE_ENV_MAP)\n    vec3 objectNormal = vec3(_glesNormal);\n// #endif";
        ShaderChunk.bsdfs = "// diffuse just use lambert\n\nvec3 BRDF_Diffuse_Lambert(vec3 diffuseColor) {\n    return RECIPROCAL_PI * diffuseColor;\n}\n\n// specular use Cook-Torrance microfacet model, http://ruh.li/GraphicsCookTorrance.html\n// About RECIPROCAL_PI: referenced by http://www.joshbarczak.com/blog/?p=272\n\nvec4 F_Schlick( const in vec4 specularColor, const in float dotLH ) {\n // Original approximation by Christophe Schlick '94\n float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n // Optimized variant (presented by Epic at SIGGRAPH '13)\n // float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\n\n// use blinn phong instead of phong\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n    // ( shininess * 0.5 + 1.0 ), three.js do this, but why ???\n return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n return 0.25;\n}\n\nvec4 BRDF_Specular_BlinnPhong(vec4 specularColor, vec3 N, vec3 L, vec3 V, float shininess) {\n    vec3 H = normalize(L + V);\n\n    float dotNH = saturate(dot(N, H));\n    float dotLH = saturate(dot(L, H));\n\n    vec4 F = F_Schlick(specularColor, dotLH);\n\n    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n    float D = D_BlinnPhong(shininess, dotNH);\n\n    return F * G * D;\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n float a2 = pow2( alpha );\n\n float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n return RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n // geometry term = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n\n float a2 = pow2( alpha );\n\n float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n return 1.0 / ( gl * gv );\n\n}\n\n// Moving Frostbite to Physically Based Rendering 2.0 - page 12, listing 2\n// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n float a2 = pow2( alpha );\n\n // dotNL and dotNV are explicitly swapped. This is not a mistake.\n float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n return 0.5 / max( gv + gl, EPSILON );\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec4 BRDF_Specular_GGX(vec4 specularColor, vec3 N, vec3 L, vec3 V, float roughness) {\n\n float alpha = pow2( roughness ); // UE4's roughness\n\n vec3 H = normalize(L + V);\n\n float dotNL = saturate( dot(N, L) );\n float dotNV = saturate( dot(N, V) );\n float dotNH = saturate( dot(N, H) );\n float dotLH = saturate( dot(L, H) );\n\n vec4 F = F_Schlick( specularColor, dotLH );\n\n float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n float D = D_GGX( alpha, dotNH );\n\n return F * G * D;\n\n}\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec4 BRDF_Specular_GGX_Environment( const in vec3 N, const in vec3 V, const in vec4 specularColor, const in float roughness ) {\n\n float dotNV = saturate( dot( N, V ) );\n\n const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n vec4 r = roughness * c0 + c1;\n\n float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n return specularColor * AB.x + AB.y;\n\n}\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}";
        ShaderChunk.bumpMap_pars_frag = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n uniform float bumpScale;\n\n // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd(vec2 uv) {\n\n  vec2 dSTdx = dFdx( uv );\n  vec2 dSTdy = dFdy( uv );\n\n  float Hll = bumpScale * texture2D( bumpMap, uv ).x;\n  float dBx = bumpScale * texture2D( bumpMap, uv + dSTdx ).x - Hll;\n  float dBy = bumpScale * texture2D( bumpMap, uv + dSTdy ).x - Hll;\n\n  return vec2( dBx, dBy );\n\n }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n\n  vec3 vSigmaX = dFdx( surf_pos );\n  vec3 vSigmaY = dFdy( surf_pos );\n  vec3 vN = surf_norm;  // normalized\n\n  vec3 R1 = cross( vSigmaY, vN );\n  vec3 R2 = cross( vN, vSigmaX );\n\n  float fDet = dot( vSigmaX, R1 );\n\n  vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n  return normalize( abs( fDet ) * surf_norm - vGrad );\n\n }\n\n#endif\n";
        ShaderChunk.inverse = "mat4 inverse(mat4 m) {\n    float\n    a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n    a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n    a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n    a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n    b00 = a00 * a11 - a01 * a10,\n    b01 = a00 * a12 - a02 * a10,\n    b02 = a00 * a13 - a03 * a10,\n    b03 = a01 * a12 - a02 * a11,\n    b04 = a01 * a13 - a03 * a11,\n    b05 = a02 * a13 - a03 * a12,\n    b06 = a20 * a31 - a21 * a30,\n    b07 = a20 * a32 - a22 * a30,\n    b08 = a20 * a33 - a23 * a30,\n    b09 = a21 * a32 - a22 * a31,\n    b10 = a21 * a33 - a23 * a31,\n    b11 = a22 * a33 - a23 * a32,\n    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    return mat4(\n        a11 * b11 - a12 * b10 + a13 * b09,\n        a02 * b10 - a01 * b11 - a03 * b09,\n        a31 * b05 - a32 * b04 + a33 * b03,\n        a22 * b04 - a21 * b05 - a23 * b03,\n        a12 * b08 - a10 * b11 - a13 * b07,\n        a00 * b11 - a02 * b08 + a03 * b07,\n        a32 * b02 - a30 * b05 - a33 * b01,\n        a20 * b05 - a22 * b02 + a23 * b01,\n        a10 * b10 - a11 * b08 + a13 * b06,\n        a01 * b08 - a00 * b10 - a03 * b06,\n        a30 * b04 - a31 * b02 + a33 * b00,\n        a21 * b02 - a20 * b04 - a23 * b00,\n        a11 * b07 - a10 * b09 - a12 * b06,\n        a00 * b09 - a01 * b07 + a02 * b06,\n        a31 * b01 - a30 * b03 - a32 * b00,\n        a20 * b03 - a21 * b01 + a22 * b00) / det;\n}";
        ShaderChunk.light_frag = "#ifdef USE_LIGHT    \n    vec3 L;\n    vec3 light;\n    vec3 totalReflect = vec3(0., 0., 0.);\n\n    #ifdef USE_DIRECT_LIGHT\n        for(int i = 0; i < USE_DIRECT_LIGHT; i++) {\n            light = vec3(glstate_directLights[i * 15 + 6], glstate_directLights[i * 15 + 7], glstate_directLights[i * 15 + 8]) * glstate_directLights[i * 15 + 9];\n\n            L.x = glstate_directLights[i * 15 + 3];\n            L.y = glstate_directLights[i * 15 + 4];\n            L.z = glstate_directLights[i * 15 + 5];\n            L = normalize(-L);\n\n            float dotNL = saturate( dot(N, L) );\n            vec3 irradiance = light * dotNL;\n\n            #ifdef USE_PBR\n                irradiance *= PI;\n            #endif\n\n            #ifdef USE_SHADOW\n                irradiance *= bool( glstate_directLights[i * 15 + 10] ) ? getShadow( glstate_directionalShadowMap[ i ], vDirectionalShadowCoord[ i ], glstate_directLights[i * 15 + 11], glstate_directLights[i * 15 + 12], vec2(glstate_directLights[i * 15 + 13], glstate_directLights[i * 15 + 14]) ) : 1.0;\n            #endif\n\n            vec3 reflectLight = irradiance * BRDF_Diffuse_Lambert(diffuseColor.xyz);\n\n            totalReflect += reflectLight;\n        }\n    #endif\n\n    #ifdef USE_POINT_LIGHT\n        for(int i = 0; i < USE_POINT_LIGHT; i++) {\n            L = vec3(glstate_pointLights[i * 19 + 0], glstate_pointLights[i * 19 + 1], glstate_pointLights[i * 19 + 2]) - xlv_POS;\n            float dist = pow(clamp(1. - length(L) / glstate_pointLights[i * 19 + 10], 0.0, 1.0), glstate_pointLights[i * 19 + 11]);\n            light = vec3(glstate_pointLights[i * 19 + 6], glstate_pointLights[i * 19 + 7], glstate_pointLights[i * 19 + 8]) * glstate_pointLights[i * 19 + 9] * dist;\n            L = normalize(L);\n\n            float dotNL = saturate( dot(N, L) );\n            vec3 irradiance = light * dotNL;\n\n            #ifdef USE_PBR\n                irradiance *= PI;\n            #endif\n\n            #ifdef USE_SHADOW\n                vec3 worldV = xlv_POS - vec3(glstate_pointLights[i * 19 + 0], glstate_pointLights[i * 19 + 1], glstate_pointLights[i * 19 + 2]);\n                irradiance *= bool( glstate_pointLights[i * 19 + 12] ) ? getPointShadow( glstate_pointShadowMap[ i ], worldV, glstate_pointLights[i * 19 + 13], glstate_pointLights[i * 19 + 14], vec2(glstate_pointLights[i * 19 + 17], glstate_pointLights[i * 19 + 18]), glstate_pointLights[i * 19 + 15], glstate_pointLights[i * 19 + 16]) : 1.0;\n            #endif\n\n            vec3 reflectLight = irradiance * BRDF_Diffuse_Lambert(diffuseColor.xyz);\n\n            totalReflect += reflectLight;\n        }\n    #endif\n\n    #ifdef USE_SPOT_LIGHT\n        for(int i = 0; i < USE_SPOT_LIGHT; i++) {\n            L = vec3(glstate_spotLights[i * 19 + 0], glstate_spotLights[i * 19 + 1], glstate_spotLights[i * 19 + 2]) - xlv_POS;\n            float lightDistance = length(L);\n            L = normalize(L);\n            float angleCos = dot( L, -normalize(vec3(glstate_spotLights[i * 19 + 3], glstate_spotLights[i * 19 + 4], glstate_spotLights[i * 19 + 5])) );\n\n            if( all( bvec2(angleCos > glstate_spotLights[i * 19 + 12], lightDistance < glstate_spotLights[i * 19 + 10]) ) ) {\n\n                float spotEffect = smoothstep( glstate_spotLights[i * 19 + 12], glstate_spotLights[i * 19 + 13], angleCos );\n                float dist = pow(clamp(1. - lightDistance / glstate_spotLights[i * 19 + 10], 0.0, 1.0), glstate_spotLights[i * 19 + 11]);\n                light = vec3(glstate_spotLights[i * 19 + 6], glstate_spotLights[i * 19 + 7], glstate_spotLights[i * 19 + 8]) * glstate_spotLights[i * 19 + 9] * dist * spotEffect;\n\n                float dotNL = saturate( dot(N, L) );\n                vec3 irradiance = light * dotNL;\n\n                #ifdef USE_PBR\n                    irradiance *= PI;\n                #endif\n\n                #ifdef USE_SHADOW\n                    irradiance *= bool( glstate_spotLights[i * 17 + 14] ) ? getShadow( glstate_spotShadowMap[ i ], vSpotShadowCoord[ i ], glstate_spotLights[i * 17 + 15], glstate_spotLights[i * 17 + 16], vec2(glstate_spotLights[i * 17 + 17], glstate_spotLights[i * 17 + 18])) : 1.0;\n                #endif\n\n                vec3 reflectLight = irradiance * BRDF_Diffuse_Lambert(diffuseColor.xyz);\n\n                totalReflect += reflectLight;\n            }\n\n        }\n    #endif\n\n    outColor.xyz = totalReflect;\n#endif";
        ShaderChunk.light_pars_frag = "#ifdef USE_DIRECT_LIGHT\n    uniform float glstate_directLights[USE_DIRECT_LIGHT * 15];\n#endif\n\n#ifdef USE_POINT_LIGHT\n    uniform float glstate_pointLights[USE_POINT_LIGHT * 19];\n#endif\n\n#ifdef USE_SPOT_LIGHT\n    uniform float glstate_spotLights[USE_SPOT_LIGHT * 19];\n#endif";
        ShaderChunk.normal_frag = "#ifdef DOUBLE_SIDED\n    float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n    float flipNormal = 1.0;\n#endif\n#ifdef FLAT_SHADED\n    // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n    vec3 fdx = vec3( dFdx( xlv_POS.x ), dFdx( xlv_POS.y ), dFdx( xlv_POS.z ) );\n    vec3 fdy = vec3( dFdy( xlv_POS.x ), dFdy( xlv_POS.y ), dFdy( xlv_POS.z ) );\n    vec3 N = normalize( cross( fdx, fdy ) );\n#else\n    vec3 N = normalize(xlv_NORMAL) * flipNormal;\n#endif\n#ifdef USE_NORMAL_MAP\n    vec3 normalMapColor = texture2D(_NormalTex, xlv_TEXCOORD0).rgb;\n    // for now, uv coord is flip Y\n    mat3 tspace = tsn(N, -xlv_POS, vec2(xlv_TEXCOORD0.x, 1.0 - xlv_TEXCOORD0.y));\n    // mat3 tspace = tbn(normalize(v_Normal), v_ViewModelPos, vec2(xlv_TEXCOORD0.x, 1.0 - xlv_TEXCOORD0.y));\n    N = normalize(tspace * (normalMapColor * 2.0 - 1.0));\n#elif defined(USE_BUMPMAP)\n    N = perturbNormalArb(-xlv_POS, N, dHdxy_fwd(xlv_TEXCOORD0));\n#endif";
        ShaderChunk.packing = "const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\n    vec4 r = vec4( fract( v * PackFactors ), v );\n    r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n    return r * PackUpscale;\n\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\n    return dot( v, UnpackFactors );\n\n}";
        ShaderChunk.particle_affector = "vec3 lifeVelocity = computeVelocity(t);\nvec4 worldRotation;\nif(u_simulationSpace==1)\n worldRotation=_startWorldRotation;\nelse\n worldRotation=u_worldRotation;\nvec3 gravity=u_gravity*age;\n\nvec3 center=computePosition(_startVelocity, lifeVelocity, age, t,gravity,worldRotation); \n#ifdef SPHERHBILLBOARD\n   vec2 corner=_glesCorner.xy;\n      vec3 cameraUpVector =normalize(glstate_cameraUp);\n      vec3 sideVector = normalize(cross(glstate_cameraForward,cameraUpVector));\n      vec3 upVector = normalize(cross(sideVector,glstate_cameraForward));\n     corner*=computeBillbardSize(_startSize.xy,t);\n  #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n   if(u_startRotation3D){\n    vec3 rotation=vec3(_startRotation.xy,computeRotation(_startRotation.z,age,t));\n    center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,rotation);\n   }\n   else{\n    float rot = computeRotation(_startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n    center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n   }\n  #else\n   if(u_startRotation3D){\n    center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,_startRotation);\n   }\n   else{\n    float c = cos(_startRotation.x);\n    float s = sin(_startRotation.x);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n    center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n   }\n  #endif\n #endif\n #ifdef STRETCHEDBILLBOARD\n  vec2 corner=_glesCorner.xy;\n  vec3 velocity;\n  #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n      if(u_spaceType==0)\n       velocity=rotation_quaternions(u_sizeScale*(_startVelocity+lifeVelocity),worldRotation)+gravity;\n      else\n       velocity=rotation_quaternions(u_sizeScale*_startVelocity,worldRotation)+lifeVelocity+gravity;\n   #else\n      velocity= rotation_quaternions(u_sizeScale*_startVelocity,worldRotation)+gravity;\n   #endif \n  vec3 cameraUpVector = normalize(velocity);\n  vec3 direction = normalize(center-glstate_cameraPos);\n    vec3 sideVector = normalize(cross(direction,normalize(velocity)));\n  sideVector=u_sizeScale.xzy*sideVector;\n  cameraUpVector=length(vec3(u_sizeScale.x,0.0,0.0))*cameraUpVector;\n    vec2 size=computeBillbardSize(_startSize.xy,t);\n    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n    corner=rotaionZHalfPI*corner;\n    corner.y=corner.y-abs(corner.y);\n    float speed=length(velocity);\n    center +=sign(u_sizeScale.x)*(sign(u_lengthScale)*size.x*corner.x*sideVector+(speed*u_speeaScale+size.y*u_lengthScale)*corner.y*cameraUpVector);\n #endif\n #ifdef HORIZONTALBILLBOARD\n  vec2 corner=_glesCorner.xy;\n    const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n    const vec3 sideVector = vec3(-1.0,0.0,0.0);\n  float rot = computeRotation(_startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n  corner*=computeBillbardSize(_startSize.xy,t);\n    center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n #endif\n #ifdef VERTICALBILLBOARD\n  vec2 corner=_glesCorner.xy;\n    const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n    vec3 sideVector = normalize(cross(glstate_cameraForward,cameraUpVector));\n  float rot = computeRotation(_startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n  corner*=computeBillbardSize(_startSize.xy,t);\n    center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n #endif\n #ifdef RENDERMESH\n    vec3 size=computeMeshSize(_startSize,t);\n  #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n    if(u_startRotation3D){\n     vec3 rotation=vec3(_startRotation.xy,-computeRotation(_startRotation.z, age,t));\n     center+= rotation_quaternions(u_sizeScale*rotation_euler(_glesVertex*size,rotation),worldRotation);\n    }\n    else{\n     #ifdef ROTATIONOVERLIFETIME\n      float angle=computeRotation(_startRotation.x, age,t);\n      if(_startPosition.x>0.1 || _startPosition.x < -0.1||_startPosition.y>0.1 || _startPosition.y < -0.1){\n       center+= (rotation_quaternions(rotation_axis(u_sizeScale*_glesVertex*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(_startPosition.xy,0.0))),angle),worldRotation));//已验证\n      }\n      else{\n       #ifdef SHAPE\n        center+= u_sizeScale.xzy*(rotation_quaternions(rotation_axis(_glesVertex*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n       #else\n        if(u_simulationSpace==1)\n         center+=rotation_axis(u_sizeScale*_glesVertex*size,vec3(0.0,0.0,-1.0),angle);\n        else if(u_simulationSpace==0)\n         center+=rotation_quaternions(u_sizeScale*rotation_axis(_glesVertex*size,vec3(0.0,0.0,-1.0),angle),worldRotation);\n       #endif\n      }\n     #endif\n     #ifdef ROTATIONSEPERATE\n      vec3 angle=compute3DRotation(vec3(0.0,0.0,_startRotation.z), age,t);\n      center+= (rotation_quaternions(rotation_euler(u_sizeScale*_glesVertex*size,vec3(angle.x,angle.y,angle.z)),worldRotation));\n     #endif \n    }\n  #else\n  if(u_startRotation3D){\n   center+= rotation_quaternions(u_sizeScale*rotation_euler(_glesVertex*size,_startRotation),worldRotation);\n  }\n  else{\n   if(_startPosition.x>0.1 || _startPosition.x < -0.1||_startPosition.y>0.1 || _startPosition.y < -0.1){\n    if(u_simulationSpace==1)\n     center+= rotation_axis(u_sizeScale*_glesVertex*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(_startPosition.xy,0.0))),_startRotation.x);\n    else if(u_simulationSpace==0)\n     center+= (rotation_quaternions(u_sizeScale*rotation_axis(_glesVertex*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(_startPosition.xy,0.0))),_startRotation.x),worldRotation));\n   }\n   else{\n    #ifdef SHAPE\n     if(u_simulationSpace==1)\n      center+= u_sizeScale*rotation_axis(_glesVertex*size,vec3(0.0,-1.0,0.0),_startRotation.x);\n     else if(u_simulationSpace==0)\n      center+= rotation_quaternions(u_sizeScale*rotation_axis(_glesVertex*size,vec3(0.0,-1.0,0.0),_startRotation.x),worldRotation); \n    #else\n     if(u_simulationSpace==1)\n      center+= rotation_axis(u_sizeScale*_glesVertex*size,vec3(0.0,0.0,-1.0),_startRotation.x);\n     else if(u_simulationSpace==0)\n      center+= rotation_quaternions(u_sizeScale*rotation_axis(_glesVertex*size,vec3(0.0,0.0,-1.0),_startRotation.x),worldRotation);\n    #endif\n   }\n  }\n  #endif\n  v_mesh_color=_glesColor;\n  #endif";
        ShaderChunk.particle_common = "\n\nuniform float u_currentTime;\nuniform vec3 u_gravity;\n\nuniform vec3 u_worldPosition;\nuniform vec4 u_worldRotation;\nuniform bool u_startRotation3D;\nuniform int u_scalingMode;\nuniform vec3 u_positionScale;\nuniform vec3 u_sizeScale;\nuniform mat4 glstate_matrix_vp;\n\n#ifdef STRETCHEDBILLBOARD\n uniform vec3 glstate_cameraPos;\n#endif\nuniform vec3 glstate_cameraForward;\nuniform vec3 glstate_cameraUp;\n\nuniform float u_lengthScale;\nuniform float u_speeaScale;\nuniform int u_simulationSpace;\n\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n  uniform int u_spaceType;\n#endif\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYTWOCONSTANT)\n  uniform vec3 u_velocityConst;\n#endif\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)\n  uniform vec2 u_velocityCurveX[4];\n  uniform vec2 u_velocityCurveY[4];\n  uniform vec2 u_velocityCurveZ[4];\n#endif\n#ifdef VELOCITYTWOCONSTANT\n  uniform vec3 u_velocityConstMax;\n#endif\n#ifdef VELOCITYTWOCURVE\n  uniform vec2 u_velocityCurveMaxX[4];\n  uniform vec2 u_velocityCurveMaxY[4];\n  uniform vec2 u_velocityCurveMaxZ[4];\n#endif\n\n#ifdef COLOROGRADIENT\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n#endif\n#ifdef COLORTWOGRADIENTS\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n  uniform vec4 u_colorGradientMax[4];\n  uniform vec2 u_alphaGradientMax[4];\n#endif\n\n#if defined(SIZECURVE)||defined(SIZETWOCURVES)\n  uniform vec2 u_sizeCurve[4];\n#endif\n#ifdef SIZETWOCURVES\n  uniform vec2 u_sizeCurveMax[4];\n#endif\n#if defined(SIZECURVESEPERATE)||defined(SIZETWOCURVESSEPERATE)\n  uniform vec2 u_sizeCurveX[4];\n  uniform vec2 u_sizeCurveY[4];\n  uniform vec2 u_sizeCurveZ[4];\n#endif\n#ifdef SIZETWOCURVESSEPERATE\n  uniform vec2 u_sizeCurveMaxX[4];\n  uniform vec2 u_sizeCurveMaxY[4];\n  uniform vec2 u_sizeCurveMaxZ[4];\n#endif\n\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform float u_rotationConst;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform float u_rotationConstMax;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurve[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMax[4];\n  #endif\n#endif\n#ifdef ROTATIONSEPERATE\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform vec3 u_rotationConstSeprarate;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform vec3 u_rotationConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurveX[4];\n    uniform vec2 u_rotationCurveY[4];\n    uniform vec2 u_rotationCurveZ[4];\n  uniform vec2 u_rotationCurveW[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMaxX[4];\n    uniform vec2 u_rotationCurveMaxY[4];\n    uniform vec2 u_rotationCurveMaxZ[4];\n  uniform vec2 u_rotationCurveMaxW[4];\n  #endif\n#endif\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\n  uniform float u_cycles;\n  uniform vec4 u_subUV;\n  uniform vec2 u_uvCurve[4];\n#endif\n#ifdef TEXTURESHEETANIMATIONTWOCURVE\n  uniform vec2 u_uvCurveMax[4];\n#endif\n\nvarying float v_discard;\nvarying vec4 v_color;\n#ifdef DIFFUSEMAP\n varying vec2 v_texcoord;\n#endif\n#ifdef RENDERMESH\n varying vec4 v_mesh_color;\n#endif\n\nvec3 rotation_euler(in vec3 vector,in vec3 euler)\n{\n  float halfPitch = euler.x * 0.5;\n float halfYaw = euler.y * 0.5;\n float halfRoll = euler.z * 0.5;\n\n float sinPitch = sin(halfPitch);\n float cosPitch = cos(halfPitch);\n float sinYaw = sin(halfYaw);\n float cosYaw = cos(halfYaw);\n float sinRoll = sin(halfRoll);\n float cosRoll = cos(halfRoll);\n\n float quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n float quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n float quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n float quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n \n float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n float xx = quaX * x;\n  float xy = quaX * y;\n float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n \n}\n\nvec3 rotation_axis(in vec3 vector,in vec3 axis, in float angle)\n{\n float halfAngle = angle * 0.5;\n float sin = sin(halfAngle);\n \n float quaX = axis.x * sin;\n float quaY = axis.y * sin;\n float quaZ = axis.z * sin;\n float quaW = cos(halfAngle);\n \n float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n float xx = quaX * x;\n  float xy = quaX * y;\n float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n}\n\nvec3 rotation_quaternions(in vec3 v,in vec4 q) \n{\n return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(SIZECURVE)||defined(SIZECURVESEPERATE)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)\nfloat evaluate_curve_float(in vec2 curves[4],in float t)\n{\n float res;\n for(int i=1;i<4;i++)\n {\n  vec2 curve=curves[i];\n  float curTime=curve.x;\n  if(curTime>=t)\n  {\n   vec2 lastCurve=curves[i-1];\n   float lastTime=lastCurve.x;\n   float tt=(t-lastTime)/(curTime-lastTime);\n   res=mix(lastCurve.y,curve.y,tt);\n   break;\n  }\n }\n return res;\n}\n#endif\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\nfloat evaluate_curve_total(in vec2 curves[4],in float t)\n{\n float res=0.0;\n for(int i=1;i<4;i++)\n {\n  vec2 curve=curves[i];\n  float curTime=curve.x;\n  vec2 lastCurve=curves[i-1];\n  float lastValue=lastCurve.y;\n  \n  if(curTime>=t){\n   float lastTime=lastCurve.x;\n   float tt=(t-lastTime)/(curTime-lastTime);\n   res+=(lastValue+mix(lastValue,curve.y,tt))/2.0*_time.x*(t-lastTime);\n   break;\n  }\n  else{\n   res+=(lastValue+curve.y)/2.0*_time.x*(curTime-lastCurve.x);\n  }\n }\n return res;\n}\n#endif\n\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)\nvec4 evaluate_curve_color(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float t)\n{\n vec4 overTimeColor;\n for(int i=1;i<4;i++)\n {\n  vec2 gradientAlpha=gradientAlphas[i];\n  float alphaKey=gradientAlpha.x;\n  if(alphaKey>=t)\n  {\n   vec2 lastGradientAlpha=gradientAlphas[i-1];\n   float lastAlphaKey=lastGradientAlpha.x;\n   float age=(t-lastAlphaKey)/(alphaKey-lastAlphaKey);\n   overTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n   break;\n  }\n }\n \n for(int i=1;i<4;i++)\n {\n  vec4 gradientColor=gradientColors[i];\n  float colorKey=gradientColor.x;\n  if(colorKey>=t)\n  {\n   vec4 lastGradientColor=gradientColors[i-1];\n   float lastColorKey=lastGradientColor.x;\n   float age=(t-lastColorKey)/(colorKey-lastColorKey);\n   overTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n   break;\n  }\n }\n return overTimeColor;\n}\n#endif\n\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\nfloat evaluate_curve_frame(in vec2 gradientFrames[4],in float t)\n{\n float overTimeFrame;\n for(int i=1;i<4;i++)\n {\n  vec2 gradientFrame=gradientFrames[i];\n  float key=gradientFrame.x;\n  if(key>=t)\n  {\n   vec2 lastGradientFrame=gradientFrames[i-1];\n   float lastKey=lastGradientFrame.x;\n   float age=(t-lastKey)/(key-lastKey);\n   overTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n   break;\n  }\n }\n return floor(overTimeFrame);\n}\n#endif\n\nvec3 computeVelocity(in float t)\n{\n  vec3 res;\n  #ifdef VELOCITYCONSTANT\n  res=u_velocityConst; \n  #endif\n  #ifdef VELOCITYCURVE\n     res= vec3(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveZ,t));\n  #endif\n  #ifdef VELOCITYTWOCONSTANT\n  res=mix(u_velocityConst,u_velocityConstMax,vec3(_random1.y,_random1.z,_random1.w)); \n  #endif\n  #ifdef VELOCITYTWOCURVE\n     res=vec3(mix(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveMaxX,t),_random1.y),\n             mix(evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveMaxY,t),_random1.z),\n        mix(evaluate_curve_float(u_velocityCurveZ,t),evaluate_curve_float(u_velocityCurveMaxZ,t),_random1.w));\n  #endif\n     \n  return res;\n} \n\nvec3 computePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float t,vec3 gravityVelocity,vec4 worldRotation)\n{\n    vec3 startPosition;\n    vec3 lifePosition;\n  #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n   #ifdef VELOCITYCONSTANT\n      startPosition=startVelocity*age;\n      lifePosition=lifeVelocity*age;\n   #endif\n   #ifdef VELOCITYCURVE\n      startPosition=startVelocity*age;\n      lifePosition=vec3(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveZ,t));\n   #endif\n   #ifdef VELOCITYTWOCONSTANT\n      startPosition=startVelocity*age;\n      lifePosition=lifeVelocity*age;\n   #endif\n   #ifdef VELOCITYTWOCURVE\n      startPosition=startVelocity*age;\n      lifePosition=vec3(mix(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveMaxX,t),_random1.y)\n                 ,mix(evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveMaxY,t),_random1.z)\n                 ,mix(evaluate_curve_total(u_velocityCurveZ,t),evaluate_curve_total(u_velocityCurveMaxZ,t),_random1.w));\n   #endif\n\n   vec3 finalPosition;\n   if(u_spaceType==0){\n     if(u_scalingMode!=2)\n      finalPosition =rotation_quaternions(u_positionScale*(_startPosition.xyz+startPosition+lifePosition),worldRotation);\n     else\n      finalPosition =rotation_quaternions(u_positionScale*_startPosition.xyz+startPosition+lifePosition,worldRotation);\n   }\n   else{\n     if(u_scalingMode!=2)\n       finalPosition = rotation_quaternions(u_positionScale*(_startPosition.xyz+startPosition),worldRotation)+lifePosition;\n     else\n       finalPosition = rotation_quaternions(u_positionScale*_startPosition.xyz+startPosition,worldRotation)+lifePosition;\n   }\n    #else\n    startPosition=startVelocity*age;\n    vec3 finalPosition;\n    if(u_scalingMode!=2)\n      finalPosition = rotation_quaternions(u_positionScale*(_startPosition.xyz+startPosition),worldRotation);\n    else\n      finalPosition = rotation_quaternions(u_positionScale*_startPosition.xyz+startPosition,worldRotation);\n  #endif\n  \n  if(u_simulationSpace==1)\n    finalPosition=finalPosition+_startWorldPosition;\n  else if(u_simulationSpace==0) \n    finalPosition=finalPosition+u_worldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return finalPosition;\n}\n\n\nvec4 computeColor(in vec4 color,in float t)\n{\n #ifdef COLOROGRADIENT\n   color*=evaluate_curve_color(u_alphaGradient,u_colorGradient,t);\n #endif \n #ifdef COLORTWOGRADIENTS\n   color*=mix(evaluate_curve_color(u_alphaGradient,u_colorGradient,t),evaluate_curve_color(u_alphaGradientMax,u_colorGradientMax,t),_random0.y);\n #endif\n\n  return color;\n}\n\nvec2 computeBillbardSize(in vec2 size,in float t)\n{\n #ifdef SIZECURVE\n  size*=evaluate_curve_float(u_sizeCurve,t);\n #endif\n #ifdef SIZETWOCURVES\n   size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),_random0.z); \n #endif\n #ifdef SIZECURVESEPERATE\n  size*=vec2(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t));\n #endif\n #ifdef SIZETWOCURVESSEPERATE\n   size*=vec2(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),_random0.z)\n         ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),_random0.z));\n #endif\n return size;\n}\n\n#ifdef RENDERMESH\nvec3 computeMeshSize(in vec3 size,in float t)\n{\n #ifdef SIZECURVE\n  size*=evaluate_curve_float(u_sizeCurve,t);\n #endif\n #ifdef SIZETWOCURVES\n   size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),_random0.z); \n #endif\n #ifdef SIZECURVESEPERATE\n  size*=vec3(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveZ,t));\n #endif\n #ifdef SIZETWOCURVESSEPERATE\n   size*=vec3(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),_random0.z)\n         ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),_random0.z)\n       ,mix(evaluate_curve_float(u_sizeCurveZ,t),evaluate_curve_float(u_sizeCurveMaxZ,t),_random0.z));\n #endif\n return size;\n}\n#endif\n\nfloat computeRotation(in float rotation,in float age,in float t)\n{ \n #ifdef ROTATIONOVERLIFETIME\n  #ifdef ROTATIONCONSTANT\n   float ageRot=u_rotationConst*age;\n         rotation+=ageRot;\n  #endif\n  #ifdef ROTATIONCURVE\n   rotation+=evaluate_curve_total(u_rotationCurve,t);\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n   float ageRot=mix(u_rotationConst,u_rotationConstMax,_random0.w)*age;\n     rotation+=ageRot;\n   #endif\n  #ifdef ROTATIONTWOCURVES\n   rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),_random0.w);\n  #endif\n #endif\n #ifdef ROTATIONSEPERATE\n  #ifdef ROTATIONCONSTANT\n   float ageRot=u_rotationConstSeprarate.z*age;\n         rotation+=ageRot;\n  #endif\n  #ifdef ROTATIONCURVE\n   rotation+=evaluate_curve_total(u_rotationCurveZ,t);\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n   float ageRot=mix(u_rotationConstSeprarate.z,u_rotationConstMaxSeprarate.z,_random0.w)*age;\n         rotation+=ageRot;\n     #endif\n  #ifdef ROTATIONTWOCURVES\n   rotation+=mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),_random0.w));\n  #endif\n #endif\n return rotation;\n}\n\n#if defined(RENDERMESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE))\nvec3 compute3DRotation(in vec3 rotation,in float age,in float t)\n{ \n #ifdef ROTATIONOVERLIFETIME\n   #ifdef ROTATIONCONSTANT\n     float ageRot=u_rotationConst*age;\n       rotation+=ageRot;\n   #endif\n   #ifdef ROTATIONCURVE\n     rotation+=evaluate_curve_total(u_rotationCurve,t);\n   #endif\n   #ifdef ROTATIONTWOCONSTANTS\n     float ageRot=mix(u_rotationConst,u_rotationConstMax,_random0.w)*age;\n       rotation+=ageRot;\n   #endif\n   #ifdef ROTATIONTWOCURVES\n     rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),_random0.w);\n   #endif\n #endif\n #ifdef ROTATIONSEPERATE\n    #ifdef ROTATIONCONSTANT\n     vec3 ageRot=u_rotationConstSeprarate*age;\n           rotation+=ageRot;\n    #endif\n    #ifdef ROTATIONCURVE\n     rotation+=vec3(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveZ,t));\n    #endif\n    #ifdef ROTATIONTWOCONSTANTS\n     vec3 ageRot=mix(u_rotationConstSeprarate,u_rotationConstMaxSeprarate,_random0.w)*age;\n           rotation+=ageRot;\n     #endif\n    #ifdef ROTATIONTWOCURVES\n     rotation+=vec3(mix(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveMaxX,t),_random0.w)\n           ,mix(evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveMaxY,t),_random0.w)\n           ,mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),_random0.w));\n    #endif\n #endif\n return rotation;\n}\n#endif\n\nvec2 computeUV(in vec2 uv,in float t)\n{ \n #ifdef TEXTURESHEETANIMATIONCURVE\n  float cycleNormalizedAge=t*u_cycles;\n  float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n  float frame=evaluate_curve_frame(u_uvCurve,uvNormalizedAge);\n  uv.x *= u_subUV.x + u_subUV.z;\n  uv.y *= u_subUV.y + u_subUV.w;\n  float totalULength=frame*u_subUV.x;\n  float floorTotalULength=floor(totalULength);\n   uv.x+=totalULength-floorTotalULength;\n  uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n #ifdef TEXTURESHEETANIMATIONTWOCURVE\n  float cycleNormalizedAge=t*u_cycles;\n  float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n   float frame=floor(mix(evaluate_curve_frame(u_uvCurve,uvNormalizedAge),evaluate_curve_frame(u_uvCurveMax,uvNormalizedAge),_random1.x));\n  uv.x *= u_subUV.x + u_subUV.z;\n  uv.y *= u_subUV.y + u_subUV.w;\n  float totalULength=frame*u_subUV.x;\n  float floorTotalULength=floor(totalULength);\n   uv.x+=totalULength-floorTotalULength;\n  uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n return uv;\n}";
        ShaderChunk.shadowMap_frag = "#ifdef USE_SHADOW\n    // outColor *= getShadowMask();\n#endif";
        ShaderChunk.shadowMap_pars_frag = "#ifdef USE_SHADOW\n\n    #include <packing>\n\n    #ifdef USE_DIRECT_LIGHT\n\n        uniform sampler2D glstate_directionalShadowMap[ USE_DIRECT_LIGHT ];\n        varying vec4 vDirectionalShadowCoord[ USE_DIRECT_LIGHT ];\n\n    #endif\n\n    #ifdef USE_POINT_LIGHT\n\n        uniform samplerCube glstate_pointShadowMap[ USE_POINT_LIGHT ];\n\n    #endif\n\n    #ifdef USE_SPOT_LIGHT\n\n        uniform sampler2D glstate_spotShadowMap[ USE_SPOT_LIGHT ];\n        varying vec4 vSpotShadowCoord[ USE_SPOT_LIGHT ];\n\n    #endif\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    float textureCubeCompare( samplerCube depths, vec3 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( textureCube( depths, uv ) ) );\n\n    }\n\n    float getShadow( sampler2D shadowMap, vec4 shadowCoord, float shadowBias, float shadowRadius, vec2 shadowMapSize ) {\n        shadowCoord.xyz /= shadowCoord.w;\n\n        float depth = shadowCoord.z + shadowBias;\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, depth <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n            #ifdef USE_PCF_SOFT_SHADOW\n                // TODO x, y not equal\n                float texelSize = shadowRadius / shadowMapSize.x;\n\n                vec2 poissonDisk[4];\n                poissonDisk[0] = vec2(-0.94201624, -0.39906216);\n                poissonDisk[1] = vec2(0.94558609, -0.76890725);\n                poissonDisk[2] = vec2(-0.094184101, -0.92938870);\n                poissonDisk[3] = vec2(0.34495938, 0.29387760);\n\n                return texture2DCompare( shadowMap, shadowCoord.xy + poissonDisk[0] * texelSize, depth ) * 0.25 +\n                    texture2DCompare( shadowMap, shadowCoord.xy + poissonDisk[1] * texelSize, depth ) * 0.25 +\n                    texture2DCompare( shadowMap, shadowCoord.xy + poissonDisk[2] * texelSize, depth ) * 0.25 +\n                    texture2DCompare( shadowMap, shadowCoord.xy + poissonDisk[3] * texelSize, depth ) * 0.25;\n            #else\n                return texture2DCompare( shadowMap, shadowCoord.xy, depth );\n            #endif\n        }\n\n        return 1.0;\n\n    }\n\n    float getPointShadow( samplerCube shadowMap, vec3 V, float shadowBias, float shadowRadius, vec2 shadowMapSize, float shadowCameraNear, float shadowCameraFar ) {\n\n        // depth = normalized distance from light to fragment position\n  float depth = ( length( V ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n  depth += shadowBias;\n\n        V.x = -V.x; // for left-hand?\n\n        #ifdef USE_PCF_SOFT_SHADOW\n            // TODO x, y equal force\n            float texelSize = shadowRadius / shadowMapSize.x;\n\n            vec3 poissonDisk[4];\n      poissonDisk[0] = vec3(-1.0, 1.0, -1.0);\n      poissonDisk[1] = vec3(1.0, -1.0, -1.0);\n      poissonDisk[2] = vec3(-1.0, -1.0, -1.0);\n      poissonDisk[3] = vec3(1.0, -1.0, 1.0);\n\n            return textureCubeCompare( shadowMap, normalize(V) + poissonDisk[0] * texelSize, depth ) * 0.25 +\n                textureCubeCompare( shadowMap, normalize(V) + poissonDisk[1] * texelSize, depth ) * 0.25 +\n                textureCubeCompare( shadowMap, normalize(V) + poissonDisk[2] * texelSize, depth ) * 0.25 +\n                textureCubeCompare( shadowMap, normalize(V) + poissonDisk[3] * texelSize, depth ) * 0.25;\n        #else\n            return textureCubeCompare( shadowMap, normalize(V), depth);\n        #endif\n    }\n\n#endif";
        ShaderChunk.shadowMap_pars_vert = "#ifdef USE_SHADOW\n\n    #ifdef USE_DIRECT_LIGHT\n\n        uniform mat4 glstate_directionalShadowMatrix[ USE_DIRECT_LIGHT ];\n        varying vec4 vDirectionalShadowCoord[ USE_DIRECT_LIGHT ];\n\n    #endif\n\n    #ifdef USE_POINT_LIGHT\n\n        // nothing\n\n    #endif\n\n    #ifdef USE_SPOT_LIGHT\n\n        uniform mat4 glstate_spotShadowMatrix[ USE_SPOT_LIGHT ];\n        varying vec4 vSpotShadowCoord[ USE_SPOT_LIGHT ];\n\n    #endif\n\n#endif";
        ShaderChunk.shadowMap_vert = "#ifdef USE_SHADOW\n\n    vec4 worldPosition = glstate_matrix_model * tmpvar_1;\n\n    #ifdef USE_DIRECT_LIGHT\n\n        for ( int i = 0; i < USE_DIRECT_LIGHT; i ++ ) {\n\n            vDirectionalShadowCoord[ i ] = glstate_directionalShadowMatrix[ i ] * worldPosition;\n\n        }\n\n    #endif\n\n    #ifdef USE_POINT_LIGHT\n\n        // nothing\n\n    #endif\n\n    #ifdef USE_SPOT_LIGHT\n\n        for ( int i = 0; i < USE_SPOT_LIGHT; i ++ ) {\n\n            vSpotShadowCoord[ i ] = glstate_spotShadowMatrix[ i ] * worldPosition;\n\n        }\n\n    #endif\n\n#endif";
        ShaderChunk.tbn = "mat3 tbn(vec3 N, vec3 p, vec2 uv) {\n    vec3 dp1 = dFdx(p.xyz);\n    vec3 dp2 = dFdy(p.xyz);\n    vec2 duv1 = dFdx(uv.st);\n    vec2 duv2 = dFdy(uv.st);\n    vec3 dp2perp = cross(dp2, N);\n    vec3 dp1perp = cross(N, dp1);\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n    float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));\n    return mat3(T * invmax, B * invmax, N);\n}";
        ShaderChunk.transpose = "mat4 transpose(mat4 inMatrix) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n    mat4 outMatrix = mat4(\n        vec4(i0.x, i1.x, i2.x, i3.x),\n        vec4(i0.y, i1.y, i2.y, i3.y),\n        vec4(i0.z, i1.z, i2.z, i3.z),\n        vec4(i0.w, i1.w, i2.w, i3.w)\n    );\n    return outMatrix;\n}";
        ShaderChunk.tsn = "mat3 tsn(vec3 N, vec3 V, vec2 uv) {\n\n    vec3 q0 = dFdx( V.xyz );\n    vec3 q1 = dFdy( V.xyz );\n    vec2 st0 = dFdx( uv.st );\n    vec2 st1 = dFdy( uv.st );\n\n    vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n    vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n    // vec3 N = normalize( N );\n\n    mat3 tsn = mat3( S, T, N );\n    return tsn;\n}";
    })(ShaderChunk = egret3d.ShaderChunk || (egret3d.ShaderChunk = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var DefaultTextures = (function () {
        function DefaultTextures() {
        }
        DefaultTextures.init = function () {
            var gl = egret3d.WebGLKit.webgl;
            var t1 = new egret3d.Texture("white");
            t1.glTexture = egret3d.GlTexture2D.createColorTexture(gl, 255, 255, 255);
            this.WHITE = t1;
            var t2 = new egret3d.Texture("gray");
            t2.glTexture = egret3d.GlTexture2D.createColorTexture(gl, 128, 128, 128);
            this.GRAY = t2;
            var t3 = new egret3d.Texture("grid");
            t3.glTexture = egret3d.GlTexture2D.createGridTexture(gl);
            this.GRID = t3;
            paper.Asset.register(t1);
            paper.Asset.register(t2);
            paper.Asset.register(t3);
        };
        return DefaultTextures;
    }());
    egret3d.DefaultTextures = DefaultTextures;
    __reflect(DefaultTextures.prototype, "egret3d.DefaultTextures");
})(egret3d || (egret3d = {}));
var RES;
(function (RES) {
    var processor;
    (function (processor) {
        function getFileName(url, removeEX) {
            if (removeEX === void 0) { removeEX = false; }
            var filei = url.lastIndexOf("/");
            var file = url.substr(filei + 1);
            if (removeEX) {
                file = file.substring(0, file.indexOf("."));
            }
            return file;
        }
        ;
        function dirname(url) {
            return url.substring(0, url.lastIndexOf("/"));
        }
        function getUrl(resource) {
            return resource.root + resource.url;
        }
        function combinePath(base, relative) {
            var stack = base.split("/"), parts = relative.split("/");
            stack.pop(); // remove current file name (or empty string)
            // (omit if "base" is the current folder without trailing slash)
            for (var i = 0; i < parts.length; i++) {
                if (parts[i] == ".")
                    continue;
                if (parts[i] == "..")
                    stack.pop();
                else
                    stack.push(parts[i]);
            }
            return stack.join("/");
        }
        function formatUrlAndSort(assets, path) {
            var list = [];
            list = assets.map(function (item) {
                return { url: combinePath(path + "/", item.url), hashCode: item.hashCode };
            });
            return list;
        }
        function promisify(loader, resource) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            var onSuccess = function () {
                                var texture = loader['data'] ? loader['data'] : loader['response'];
                                resolve(texture);
                            };
                            var onError = function () {
                                var e = new RES.ResourceManagerError(1001, resource.url);
                                reject(e);
                            };
                            loader.addEventListener(egret.Event.COMPLETE, onSuccess, _this);
                            loader.addEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
                        })];
                });
            });
        }
        processor.GLVertexShaderProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, url, filename, name;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, host.load(resource, "text")];
                            case 1:
                                text = _a.sent();
                                url = getUrl(resource);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                return [2 /*return*/, egret3d.Shader.registerVertShader(name, text)];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2 /*return*/];
                    });
                });
            }
            // getData(host, resource, key, subkey) { //可选函数
            // }
        };
        processor.GLFragmentShaderProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, url, filename, name;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, host.load(resource, "text")];
                            case 1:
                                text = _a.sent();
                                url = getUrl(resource);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                return [2 /*return*/, egret3d.Shader.registerFragShader(name, text)];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2 /*return*/];
                    });
                });
            }
        };
        processor.ShaderProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data, url, shader;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, host.load(resource, "json")];
                            case 1:
                                data = _a.sent();
                                url = getUrl(resource);
                                shader = new egret3d.Shader(url);
                                shader.$parse(data);
                                paper.Asset.register(shader, true);
                                return [2 /*return*/, shader];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        processor.TextureDescProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data, url, filename, _name, _filterMode, _format, _mipmap, _wrap, _textureFormat, _linear, _repeat, textureUrl, loader, image, texture, gl, t2d;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, host.load(resource, "json")];
                            case 1:
                                data = _a.sent();
                                url = getUrl(resource);
                                filename = getFileName(url);
                                _name = data["name"];
                                _filterMode = data["filterMode"];
                                _format = data["format"];
                                _mipmap = data["mipmap"];
                                _wrap = data["wrap"];
                                _textureFormat = 1 /* RGBA */;
                                if (_format == "RGB") {
                                    _textureFormat = 2 /* RGB */;
                                }
                                else if (_format == "Gray") {
                                    _textureFormat = 3 /* Gray */;
                                }
                                _linear = true;
                                if (_filterMode.indexOf("linear") < 0) {
                                    _linear = false;
                                }
                                _repeat = false;
                                if (_wrap.indexOf("Repeat") >= 0) {
                                    _repeat = true;
                                }
                                textureUrl = url.replace(filename, _name);
                                loader = new egret.ImageLoader();
                                loader.load(textureUrl);
                                return [4 /*yield*/, promisify(loader, resource)];
                            case 2:
                                image = _a.sent();
                                texture = new egret3d.Texture(url);
                                texture.realName = _name;
                                gl = egret3d.WebGLKit.webgl;
                                t2d = new egret3d.GlTexture2D(gl, _textureFormat);
                                t2d.uploadImage(image.source, _mipmap, _linear, true, _repeat);
                                texture.glTexture = t2d;
                                paper.Asset.register(texture, true);
                                return [2 /*return*/, texture];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        processor.TextureProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var gl, url, loader, image, _texture, _textureFormat, t2d;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                gl = egret3d.WebGLKit.webgl;
                                url = getUrl(resource);
                                loader = new egret.ImageLoader();
                                loader.load(url);
                                return [4 /*yield*/, promisify(loader, resource)];
                            case 1:
                                image = _a.sent();
                                _texture = new egret3d.Texture(url);
                                _textureFormat = 1 /* RGBA */;
                                t2d = new egret3d.GlTexture2D(gl, _textureFormat);
                                t2d.uploadImage(image.source, true, true, true, true);
                                _texture.glTexture = t2d;
                                paper.Asset.register(_texture, true);
                                return [2 /*return*/, _texture];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        processor.MaterialProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var json, url, material, shaderName, shader, mapUniform, _a, _b, _i, i, jsonChild, _c, value, url_1, texture, r, tempValue;
                    return __generator(this, function (_d) {
                        switch (_d.label) {
                            case 0: return [4 /*yield*/, host.load(resource, "json")];
                            case 1:
                                json = _d.sent();
                                url = getUrl(resource);
                                material = new egret3d.Material(url);
                                shaderName = json.shader;
                                shader = paper.Asset.find(shaderName);
                                material.setShader(shader);
                                mapUniform = json.mapUniform;
                                _a = [];
                                for (_b in mapUniform)
                                    _a.push(_b);
                                _i = 0;
                                _d.label = 2;
                            case 2:
                                if (!(_i < _a.length)) return [3 /*break*/, 11];
                                i = _a[_i];
                                jsonChild = mapUniform[i];
                                _c = jsonChild.type;
                                switch (_c) {
                                    case egret3d.UniformTypeEnum.Texture: return [3 /*break*/, 3];
                                    case egret3d.UniformTypeEnum.Float: return [3 /*break*/, 7];
                                    case egret3d.UniformTypeEnum.Float4: return [3 /*break*/, 8];
                                }
                                return [3 /*break*/, 9];
                            case 3:
                                value = jsonChild.value;
                                url_1 = combinePath(dirname(resource.url) + "/", value);
                                texture = paper.Asset.find(url_1);
                                if (!!texture) return [3 /*break*/, 6];
                                r = RES.host.resourceConfig["getResource"](url_1);
                                if (!r) return [3 /*break*/, 5];
                                return [4 /*yield*/, RES.getResAsync(r.name)];
                            case 4:
                                texture = _d.sent();
                                return [3 /*break*/, 6];
                            case 5:
                                texture = egret3d.DefaultTextures.GRID;
                                _d.label = 6;
                            case 6:
                                material.setTexture(i, texture);
                                return [3 /*break*/, 10];
                            case 7:
                                material.setFloat(i, jsonChild.value);
                                return [3 /*break*/, 10];
                            case 8:
                                tempValue = jsonChild.value;
                                if (Array.isArray(tempValue)) {
                                    material.setVector4v(i, tempValue);
                                }
                                else {
                                    console.error("不支持的旧格式，请访问 http://developer.egret.com/cn/docs/3d/file-format/ 进行升级");
                                }
                                return [3 /*break*/, 10];
                            case 9:
                                console.warn("\u4E0D\u652F\u6301\u7684 Uniform \u53C2\u6570\uFF1A" + material.url + "," + i);
                                _d.label = 10;
                            case 10:
                                _i++;
                                return [3 /*break*/, 2];
                            case 11:
                                paper.Asset.register(material, true);
                                return [2 /*return*/, material];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        processor.GLTFProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var result, url, glTF;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, host.load(resource, "bin")];
                            case 1:
                                result = _a.sent();
                                url = getUrl(resource);
                                glTF = new egret3d.GLTFAsset(url);
                                glTF.parseFromBinary(new Uint32Array(result));
                                paper.Asset.register(glTF, true);
                                return [2 /*return*/, glTF];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        processor.PrefabProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data, url, subassets, prefab;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, host.load(resource, "json")];
                            case 1:
                                data = _a.sent();
                                url = getUrl(resource);
                                return [4 /*yield*/, loadSubAssets(data, resource)];
                            case 2:
                                subassets = _a.sent();
                                prefab = new egret3d.Prefab(url);
                                prefab.$parse(data, subassets);
                                paper.Asset.register(prefab, true);
                                return [2 /*return*/, prefab];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        function loadSubAssets(data, resource) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                var assets, result, list;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            assets = data.assets;
                            result = [];
                            list = formatUrlAndSort(assets, dirname(resource.url));
                            return [4 /*yield*/, Promise.all(list.map((function (item) { return __awaiter(_this, void 0, void 0, function () {
                                    var r, asset;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                r = RES.host.resourceConfig["getResource"](item.url);
                                                if (!r) return [3 /*break*/, 2];
                                                return [4 /*yield*/, RES.host.load(r)];
                                            case 1:
                                                asset = _a.sent();
                                                asset.hashCode = item.hashCode;
                                                result.push(asset);
                                                _a.label = 2;
                                            case 2: return [2 /*return*/];
                                        }
                                    });
                                }); })))];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, result];
                    }
                });
            });
        }
        processor.SceneProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data, url, subassets, scene;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, host.load(resource, "json")];
                            case 1:
                                data = _a.sent();
                                url = getUrl(resource);
                                return [4 /*yield*/, loadSubAssets(data, resource)];
                            case 2:
                                subassets = _a.sent();
                                scene = new egret3d.RawScene(url);
                                scene.$parse(data, subassets);
                                paper.Asset.register(scene, true);
                                return [2 /*return*/, scene];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        RES.processor.map("GLVertexShader", processor.GLVertexShaderProcessor);
        RES.processor.map("GLFragmentShader", processor.GLFragmentShaderProcessor);
        RES.processor.map("Shader", processor.ShaderProcessor);
        RES.processor.map("Texture", processor.TextureProcessor);
        RES.processor.map("TextureDesc", processor.TextureDescProcessor);
        RES.processor.map("Material", processor.MaterialProcessor);
        RES.processor.map("GLTFBinary", processor.GLTFProcessor);
        RES.processor.map("Prefab", processor.PrefabProcessor);
        RES.processor.map("Scene", processor.SceneProcessor);
    })(processor = RES.processor || (RES.processor = {}));
})(RES || (RES = {}));
var egret3d;
(function (egret3d) {
    var DefaultShaders = (function () {
        function DefaultShaders() {
        }
        DefaultShaders.init = function () {
            if (this._inited) {
                return;
            }
            this._inited = true;
            var def_code_vs = egret3d.Shader.registerVertShader("def_code", egret3d.ShaderLib.code_vert);
            var def_code_fs = egret3d.Shader.registerFragShader("def_code", egret3d.ShaderLib.code_frag);
            var def_code2_fs = egret3d.Shader.registerFragShader("def_code2", egret3d.ShaderLib.code2_frag);
            var def_ui_fs = egret3d.Shader.registerFragShader("def_ui", egret3d.ShaderLib.ui_frag);
            var def_uifont_vs = egret3d.Shader.registerVertShader("def_uifont", egret3d.ShaderLib.uifont_vert);
            var def_uifont_fs = egret3d.Shader.registerFragShader("def_uifont", egret3d.ShaderLib.uifont_frag);
            var def_diffuse_vs = egret3d.Shader.registerVertShader("def_diffuse", egret3d.ShaderLib.diffuse_vert);
            var def_diffuse_fs = egret3d.Shader.registerFragShader("def_diffuse", egret3d.ShaderLib.diffuse_frag);
            var def_boneeff_vs = egret3d.Shader.registerVertShader("def_boneeff", egret3d.ShaderLib.boneeff_vert);
            var def_bonelambert_vs = egret3d.Shader.registerVertShader("def_bonelambert_vert", egret3d.ShaderLib.bonelambert_vert);
            var def_diffuselightmap_vs = egret3d.Shader.registerVertShader("def_diffuselightmap", egret3d.ShaderLib.diffuselightmap_vert);
            var def_diffuselightmap_fs = egret3d.Shader.registerFragShader("def_diffuselightmap", egret3d.ShaderLib.diffuselightmap_frag);
            var def_postquad_vs = egret3d.Shader.registerVertShader("def_postquad", egret3d.ShaderLib.postquad_vert);
            var def_postquaddepth_fs = egret3d.Shader.registerFragShader("def_postquaddepth", egret3d.ShaderLib.postquaddepth_frag);
            var def_postdepth_vs = egret3d.Shader.registerVertShader("def_postdepth", egret3d.ShaderLib.postdepth_vert);
            var def_postdepth_fs = egret3d.Shader.registerFragShader("def_postdepth", egret3d.ShaderLib.postdepth_frag);
            var def_line_vs = egret3d.Shader.registerVertShader("def_line", egret3d.ShaderLib.line_vert);
            var def_line_fs = egret3d.Shader.registerFragShader("def_line", egret3d.ShaderLib.line_frag);
            var def_materialcolor_vs = egret3d.Shader.registerVertShader("def_materialcolor", egret3d.ShaderLib.materialcolor_vert);
            var def_diffusetintcolor_fs = egret3d.Shader.registerFragShader("def_diffusetintcolor", egret3d.ShaderLib.tintcolor_frag);
            var def_diffusevertcolor_vs = egret3d.Shader.registerVertShader("def_diffusevertcolor", egret3d.ShaderLib.vertcolor_vert);
            var def_diffusevertcolor_fs = egret3d.Shader.registerFragShader("def_diffusevertcolor", egret3d.ShaderLib.vertcolor_frag);
            var def_lambert_vs = egret3d.Shader.registerVertShader("def_lambert", egret3d.ShaderLib.lambert_vert);
            var def_lambert_fs = egret3d.Shader.registerFragShader("def_lambert", egret3d.ShaderLib.lambert_frag);
            var def_lambertnormal_vs = egret3d.Shader.registerVertShader("def_lambertnormal", "#define USE_NORMAL_MAP \n" + egret3d.ShaderLib.lambert_vert);
            var def_lambertnormal_fs = egret3d.Shader.registerFragShader("def_lambertnormal", "#define USE_NORMAL_MAP \n" + egret3d.ShaderLib.lambert_frag);
            var def_depthpackage_vs = egret3d.Shader.registerVertShader("def_depthpackage", egret3d.ShaderLib.depthpackage_vert); // non-linear
            var def_depthpackage_fs = egret3d.Shader.registerFragShader("def_depthpackage", egret3d.ShaderLib.depthpackage_frag);
            var def_distancepackage_vs = egret3d.Shader.registerVertShader("def_depthpackage", egret3d.ShaderLib.distancepackage_vert); // linear
            var def_distancepackage_fs = egret3d.Shader.registerFragShader("def_depthpackage", egret3d.ShaderLib.distancepackage_frag);
            var def_particlesystem_vs = egret3d.Shader.registerVertShader("def_particlesystem", "#define DIFFUSEMAP \n#define TINTCOLOR \n" + egret3d.ShaderLib.particlesystem_vert);
            var def_particlesystem_fs = egret3d.Shader.registerFragShader("def_particlesystem", "#define DIFFUSEMAP \n#define TINTCOLOR \n" + egret3d.ShaderLib.particlesystem_frag);
            var def_alphaBlend_fs = egret3d.Shader.registerFragShader("def_alphaBlend", egret3d.ShaderLib.alphaBlend_frag);
            var def_alphaCut_fs = egret3d.Shader.registerFragShader("def_alphaCut", egret3d.ShaderLib.alphaCut_frag);
            {
                var shader = new egret3d.Shader("shader/lambert");
                shader.renderQueue = egret3d.RenderQueue.Geometry;
                shader.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRAY };
                shader.defaultValue["_Color"] = { type: "Vector4", value: [1, 1, 1, 1] };
                shader.passes["base"] = [];
                var renderPass = new egret3d.DrawPass(def_lambert_vs, def_lambert_fs);
                renderPass.state_ztest = true;
                renderPass.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                renderPass.state_zwrite = true;
                renderPass.state_showface = egret3d.ShowFaceStateEnum.CCW;
                renderPass.setAlphaBlend(egret3d.BlendModeEnum.Close);
                shader.passes["base"].push(renderPass);
                shader.passes["base_depth_package"] = [];
                var depthPass = new egret3d.DrawPass(def_depthpackage_vs, def_depthpackage_fs);
                depthPass.state_ztest = true;
                depthPass.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                depthPass.state_zwrite = true;
                depthPass.state_showface = egret3d.ShowFaceStateEnum.CCW;
                depthPass.setAlphaBlend(egret3d.BlendModeEnum.Close);
                shader.passes["base_depth_package"].push(depthPass);
                shader.passes["base_distance_package"] = [];
                var distancePass = new egret3d.DrawPass(def_distancepackage_vs, def_distancepackage_fs);
                distancePass.state_ztest = true;
                distancePass.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                distancePass.state_zwrite = true;
                distancePass.state_showface = egret3d.ShowFaceStateEnum.CCW;
                distancePass.setAlphaBlend(egret3d.BlendModeEnum.Close);
                shader.passes["base_distance_package"].push(distancePass);
                var skinPass = new egret3d.DrawPass(def_bonelambert_vs, def_lambert_fs);
                shader.passes["skin"] = [];
                skinPass.state_ztest = true;
                skinPass.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                skinPass.state_zwrite = true;
                skinPass.state_showface = egret3d.ShowFaceStateEnum.CCW;
                skinPass.setAlphaBlend(egret3d.BlendModeEnum.Close);
                shader.passes["skin"].push(skinPass);
                this.LAMBERT = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = new egret3d.Shader("shader/lambertnormal");
                shader.renderQueue = egret3d.RenderQueue.Geometry;
                shader.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRAY };
                shader.defaultValue["_Color"] = { type: "Vector4", value: [1, 1, 1, 1] };
                shader.passes["base"] = [];
                var renderPass = new egret3d.DrawPass(def_lambertnormal_vs, def_lambertnormal_fs);
                renderPass.state_ztest = true;
                renderPass.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                renderPass.state_zwrite = true;
                renderPass.state_showface = egret3d.ShowFaceStateEnum.CCW;
                renderPass.setAlphaBlend(egret3d.BlendModeEnum.Close);
                shader.passes["base"].push(renderPass);
                shader.passes["base_depth_package"] = [];
                var depthPass = new egret3d.DrawPass(def_depthpackage_vs, def_depthpackage_fs);
                depthPass.state_ztest = true;
                depthPass.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                depthPass.state_zwrite = true;
                depthPass.state_showface = egret3d.ShowFaceStateEnum.CCW;
                depthPass.setAlphaBlend(egret3d.BlendModeEnum.Close);
                shader.passes["base_depth_package"].push(depthPass);
                shader.passes["base_distance_package"] = [];
                var distancePass = new egret3d.DrawPass(def_distancepackage_vs, def_distancepackage_fs);
                distancePass.state_ztest = true;
                distancePass.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                distancePass.state_zwrite = true;
                distancePass.state_showface = egret3d.ShowFaceStateEnum.CCW;
                distancePass.setAlphaBlend(egret3d.BlendModeEnum.Close);
                shader.passes["base_distance_package"].push(distancePass);
                this.LAMBERT_NORMAL = shader;
                paper.Asset.register(shader);
            }
            {
                var sh = new egret3d.Shader("shader/def");
                sh.renderQueue = egret3d.RenderQueue.Geometry;
                sh.passes["base"] = [];
                sh.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRID };
                sh.defaultValue["_MainTex_ST"] = { type: "Vector4", value: [1, 1, 0, 0] };
                sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                var p = new egret3d.DrawPass(def_diffuse_vs, def_diffuse_fs);
                sh.passes["base"].push(p);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = true;
                p.state_showface = egret3d.ShowFaceStateEnum.CCW;
                // p.setProgram(diffuseProgram);
                p.setAlphaBlend(egret3d.BlendModeEnum.Close);
                // p.uniformTexture("_MainTex", null);
                paper.Asset.register(sh);
            }
            {
                // 兼容外部引入的 transparent.shader.json
                var sh = new egret3d.Shader("transparent.shader.json");
                sh.renderQueue = egret3d.RenderQueue.Transparent;
                sh.passes["base"] = [];
                sh.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRID };
                sh.defaultValue["_MainTex_ST"] = { type: "Vector4", value: [1, 1, 0, 0] };
                sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                var p = new egret3d.DrawPass(def_diffuse_vs, def_diffuse_fs);
                sh.passes["base"].push(p);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = true;
                p.state_showface = egret3d.ShowFaceStateEnum.CCW;
                // p.setProgram(diffuseProgram);
                p.setAlphaBlend(egret3d.BlendModeEnum.Blend);
                // p.uniformTexture("_MainTex", null);
                this.TRANSPARENT = sh;
                paper.Asset.register(sh);
            }
            {
                // 兼容外部引入的 transparent_tintColor.shader.json
                var sh = new egret3d.Shader("transparent_tintColor.shader.json");
                sh.renderQueue = egret3d.RenderQueue.Transparent;
                sh.passes["base"] = [];
                sh.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRID };
                sh.defaultValue["_MainTex_ST"] = { type: "Vector4", value: [1, 1, 0, 0] };
                sh.defaultValue["_TintColor"] = { type: "Vector4", value: [0.5, 0.5, 0.5, 0.5] };
                var p = new egret3d.DrawPass(def_diffuse_vs, def_alphaBlend_fs);
                sh.passes["base"].push(p);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = false;
                p.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p.setAlphaBlend(egret3d.BlendModeEnum.Add);
                this.TRANSPARENT_ADDITIVE = sh;
                paper.Asset.register(sh);
            }
            {
                // 兼容外部引入的 transparent_tintColor.shader.json
                var sh = new egret3d.Shader("transparent_alphaCut.shader.json");
                sh.renderQueue = egret3d.RenderQueue.AlphaTest;
                sh.passes["base"] = [];
                sh.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRID };
                sh.defaultValue["_MainTex_ST"] = { type: "Vector4", value: [1, 1, 0, 0] };
                sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                var p = new egret3d.DrawPass(def_diffuse_vs, def_alphaCut_fs);
                sh.passes["base"].push(p);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = true;
                p.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p.setAlphaBlend(egret3d.BlendModeEnum.Close);
                this.TRANSPARENT_ADDITIVE = sh;
                paper.Asset.register(sh);
            }
            {
                // 兼容外部引入的 transparent_additive.shader.json
                var sh = new egret3d.Shader("transparent_additive.shader.json");
                sh.renderQueue = egret3d.RenderQueue.Transparent;
                sh.passes["base"] = [];
                sh.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRID };
                sh.defaultValue["_MainTex_ST"] = { type: "Vector4", value: [1, 1, 0, 0] };
                sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                var p = new egret3d.DrawPass(def_diffuse_vs, def_diffuse_fs);
                sh.passes["base"].push(p);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = true;
                p.state_showface = egret3d.ShowFaceStateEnum.CCW;
                // p.setProgram(diffuseProgram);
                p.setAlphaBlend(egret3d.BlendModeEnum.Add);
                // p.uniformTexture("_MainTex", null);
                this.TRANSPARENT_ADDITIVE = sh;
                paper.Asset.register(sh);
            }
            {
                // 兼容外部引入的 transparent_additive_bothside.shader.json
                var sh = new egret3d.Shader("transparent_additive_bothside.shader.json");
                sh.renderQueue = egret3d.RenderQueue.Transparent;
                sh.passes["base"] = [];
                sh.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRID };
                sh.defaultValue["_MainTex_ST"] = { type: "Vector4", value: [1, 1, 0, 0] };
                sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                var p = new egret3d.DrawPass(def_diffuse_vs, def_diffuse_fs);
                sh.passes["base"].push(p);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = true;
                p.state_showface = egret3d.ShowFaceStateEnum.ALL;
                // p.setProgram(diffuseProgram);
                p.setAlphaBlend(egret3d.BlendModeEnum.Add);
                // p.uniformTexture("_MainTex", null);
                this.TRANSPARENT_ADDITIVE_BOTH_SIDE = sh;
                paper.Asset.register(sh);
            }
            {
                // 兼容外部引入的 transparent_bothside.shader.json
                var sh = new egret3d.Shader("transparent_bothside.shader.json");
                sh.renderQueue = egret3d.RenderQueue.Transparent;
                sh.passes["base"] = [];
                sh.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRID };
                sh.defaultValue["_MainTex_ST"] = { type: "Vector4", value: [1, 1, 0, 0] };
                sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                var p = new egret3d.DrawPass(def_diffuse_vs, def_diffuse_fs);
                sh.passes["base"].push(p);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = true;
                p.state_showface = egret3d.ShowFaceStateEnum.ALL;
                // p.setProgram(diffuseProgram);
                p.setAlphaBlend(egret3d.BlendModeEnum.Blend);
                // p.uniformTexture("_MainTex", null);
                this.TRANSPARENT_BOTH_SIDE = sh;
                paper.Asset.register(sh);
            }
            {
                // 兼容外部引入的 diffuse.shader.json
                var sh = new egret3d.Shader("diffuse.shader.json");
                sh.renderQueue = egret3d.RenderQueue.Geometry;
                sh.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRAY };
                sh.defaultValue["_MainTex_ST"] = { type: "Vector4", value: [1, 1, 0, 0] };
                sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                var p = new egret3d.DrawPass(def_diffuse_vs, def_diffuse_fs);
                sh.passes["base"] = [];
                sh.passes["base"].push(p);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = true;
                p.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p.setAlphaBlend(egret3d.BlendModeEnum.Close);
                var p2 = new egret3d.DrawPass(def_boneeff_vs, def_diffuse_fs);
                sh.passes["skin"] = [];
                sh.passes["skin"].push(p2);
                p2.state_ztest = true;
                p2.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p2.state_zwrite = true;
                p2.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p2.setAlphaBlend(egret3d.BlendModeEnum.Close);
                var p3 = new egret3d.DrawPass(def_diffuselightmap_vs, def_diffuselightmap_fs);
                sh.passes["lightmap"] = [];
                sh.passes["lightmap"].push(p3);
                p3.state_ztest = true;
                p3.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p3.state_zwrite = true;
                p3.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p3.setAlphaBlend(egret3d.BlendModeEnum.Close);
                var p4 = new egret3d.DrawPass(def_postquad_vs, def_postquaddepth_fs);
                sh.passes["quad"] = [];
                sh.passes["quad"].push(p4);
                p4.state_ztest = true;
                p4.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p4.state_zwrite = true;
                p4.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p4.setAlphaBlend(egret3d.BlendModeEnum.Close);
                var p5 = new egret3d.DrawPass(def_postdepth_vs, def_postdepth_fs);
                sh.passes["base_depth"] = [];
                sh.passes["base_depth"].push(p5);
                p5.state_ztest = true;
                p5.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p5.state_zwrite = true;
                p5.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p5.setAlphaBlend(egret3d.BlendModeEnum.Close);
                var p6 = new egret3d.DrawPass(def_depthpackage_vs, def_depthpackage_fs);
                sh.passes["base_depth_package"] = [];
                sh.passes["base_depth_package"].push(p6);
                p6.state_ztest = false;
                p6.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p6.state_zwrite = false;
                p6.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p6.setAlphaBlend(egret3d.BlendModeEnum.Close);
                // p.uniformTexture("_MainTex", null);
                this.DIFFUSE = sh;
                paper.Asset.register(sh);
            }
            {
                var sh = new egret3d.Shader("shader/diffuse_tintcolor");
                sh.renderQueue = egret3d.RenderQueue.Geometry;
                sh.passes["base"] = [];
                sh.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRID };
                sh.defaultValue["_MainTex_ST"] = { type: "Vector4", value: [1, 1, 0, 0] };
                sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                sh.defaultValue["_TintColor"] = { type: "Vector4", value: [1, 1, 1, 1] };
                var p = new egret3d.DrawPass(def_diffuse_vs, def_diffusetintcolor_fs);
                sh.passes["base"].push(p);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = true;
                p.state_showface = egret3d.ShowFaceStateEnum.CCW;
                // p.setProgram(diffuseProgram);
                p.setAlphaBlend(egret3d.BlendModeEnum.Close);
                // p.uniformTexture("_MainTex", null);
                this.DIFFUSE_TINT_COLOR = sh;
                paper.Asset.register(sh);
            }
            {
                var sh = new egret3d.Shader("shader/diffuse_vertcolor");
                sh.renderQueue = egret3d.RenderQueue.Geometry;
                sh.passes["base"] = [];
                sh.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRID };
                sh.defaultValue["_MainTex_ST"] = { type: "Vector4", value: [1, 1, 0, 0] };
                sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                var p = new egret3d.DrawPass(def_diffusevertcolor_vs, def_diffusevertcolor_fs);
                sh.passes["base"].push(p);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = true;
                p.state_showface = egret3d.ShowFaceStateEnum.CCW;
                // p.setProgram(diffuseProgram);
                p.setAlphaBlend(egret3d.BlendModeEnum.Close);
                // p.uniformTexture("_MainTex", null);
                this.DIFFUSE_VERT_COLOR = sh;
                paper.Asset.register(sh);
            }
            {
                // 兼容外部引入的 diffuse_bothside.shader.json
                var sh = new egret3d.Shader("diffuse_bothside.shader.json");
                sh.renderQueue = egret3d.RenderQueue.Geometry;
                // sh.defaultAsset = true;
                sh.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRID };
                sh.defaultValue["_MainTex_ST"] = { type: "Vector4", value: [1, 1, 0, 0] };
                sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                var p = new egret3d.DrawPass(def_diffuse_vs, def_diffuse_fs);
                sh.passes["base"] = [];
                sh.passes["base"].push(p);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = true;
                p.state_showface = egret3d.ShowFaceStateEnum.ALL;
                p.setAlphaBlend(egret3d.BlendModeEnum.Close);
                var p2 = new egret3d.DrawPass(def_boneeff_vs, def_diffuse_fs);
                sh.passes["skin"] = [];
                sh.passes["skin"].push(p2);
                p2.state_ztest = true;
                p2.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p2.state_zwrite = true;
                p2.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p2.setAlphaBlend(egret3d.BlendModeEnum.Close);
                var p3 = new egret3d.DrawPass(def_diffuselightmap_vs, def_diffuselightmap_fs);
                sh.passes["lightmap"] = [];
                sh.passes["lightmap"].push(p3);
                p3.state_ztest = true;
                p3.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p3.state_zwrite = true;
                p3.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p3.setAlphaBlend(egret3d.BlendModeEnum.Close);
                var p4 = new egret3d.DrawPass(def_postquad_vs, def_postquaddepth_fs);
                sh.passes["quad"] = [];
                sh.passes["quad"].push(p4);
                p4.state_ztest = true;
                p4.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p4.state_zwrite = true;
                p4.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p4.setAlphaBlend(egret3d.BlendModeEnum.Close);
                var p5 = new egret3d.DrawPass(def_postdepth_vs, def_postdepth_fs);
                sh.passes["base_depth"] = [];
                sh.passes["base_depth"].push(p5);
                p5.state_ztest = true;
                p5.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p5.state_zwrite = true;
                p5.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p5.setAlphaBlend(egret3d.BlendModeEnum.Close);
                // p.uniformTexture("_MainTex", null);
                this.DIFFUSE_BOTH_SIDE = sh;
                paper.Asset.register(sh);
            }
            {
                var sh = new egret3d.Shader("shader/defui");
                sh.passes["base"] = [];
                var p = new egret3d.DrawPass(def_code_vs, def_ui_fs);
                sh.passes["base"].push(p);
                // p.setProgram(program2);
                p.state_showface = egret3d.ShowFaceStateEnum.CW; // ui 只需要显示正面
                p.state_ztest = false;
                p.state_zwrite = false;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.setAlphaBlend(egret3d.BlendModeEnum.Blend_PreMultiply);
                var p2 = new egret3d.DrawPass(def_code_vs, def_ui_fs);
                sh.passes["base"].push(p2);
                // p2.setProgram(program2);
                p2.state_showface = egret3d.ShowFaceStateEnum.ALL;
                p2.state_ztest = true;
                p2.state_zwrite = false;
                p2.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p2.setAlphaBlend(egret3d.BlendModeEnum.Blend_PreMultiply);
                this.UI = sh;
                paper.Asset.register(sh);
            }
            {
                var sh = new egret3d.Shader("shader/defuifont");
                sh.passes["base"] = [];
                var p = new egret3d.DrawPass(def_uifont_vs, def_uifont_fs);
                sh.passes["base"].push(p);
                // p.setProgram(programuifont);
                p.state_showface = egret3d.ShowFaceStateEnum.CW;
                p.state_ztest = false;
                p.state_zwrite = false;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.setAlphaBlend(egret3d.BlendModeEnum.Blend_PreMultiply);
                var p2 = new egret3d.DrawPass(def_uifont_vs, def_uifont_fs);
                sh.passes["base"].push(p2);
                // p2.setProgram(programuifont);
                p2.state_showface = egret3d.ShowFaceStateEnum.ALL;
                p2.state_ztest = true;
                p2.state_zwrite = false;
                p2.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p2.setAlphaBlend(egret3d.BlendModeEnum.Blend_PreMultiply);
                this.UI_FONT = sh;
                paper.Asset.register(sh);
            }
            {
                var sh = new egret3d.Shader("line.shader.json");
                sh.renderQueue = egret3d.RenderQueue.Geometry;
                // sh.defaultAsset = true;
                sh.passes["base"] = [];
                var p = new egret3d.DrawPass(def_line_vs, def_line_fs);
                sh.passes["base"].push(p);
                // p.setProgram(programline);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = true;
                p.state_showface = egret3d.ShowFaceStateEnum.ALL;
                p.setAlphaBlend(egret3d.BlendModeEnum.Close);
                this.LINE = sh;
                paper.Asset.register(sh);
            }
            {
                var sh = new egret3d.Shader("materialcolor.shader.json");
                sh.renderQueue = egret3d.RenderQueue.Geometry;
                sh.defaultValue["_Color"] = { type: "Vector4", value: [1, 1, 1, 1] };
                // sh.defaultAsset = true;
                sh.passes["base"] = [];
                var p = new egret3d.DrawPass(def_materialcolor_vs, def_line_fs);
                sh.passes["base"].push(p);
                // p.setProgram(programmaterialcolor);
                p.state_ztest = true;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = true;
                p.state_showface = egret3d.ShowFaceStateEnum.ALL;
                p.setAlphaBlend(egret3d.BlendModeEnum.Close);
                sh.renderQueue = egret3d.RenderQueue.Overlay;
                this.MATERIAL_COLOR = sh;
                paper.Asset.register(sh);
            }
            {
                var sh = new egret3d.Shader("gizmos.shader.json");
                sh.renderQueue = egret3d.RenderQueue.Overlay;
                sh.defaultValue["_Color"] = { type: "Vector4", value: [1, 1, 1, 1] };
                // sh.defaultAsset = true;
                sh.passes["base"] = [];
                var p = new egret3d.DrawPass(def_materialcolor_vs, def_line_fs);
                sh.passes["base"].push(p);
                // p.setProgram(programmaterialcolor);
                p.state_ztest = false;
                p.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                p.state_zwrite = false;
                p.state_showface = egret3d.ShowFaceStateEnum.CCW;
                p.setAlphaBlend(egret3d.BlendModeEnum.Blend);
                sh.renderQueue = egret3d.RenderQueue.Overlay;
                this.GIZMOS_COLOR = sh;
                paper.Asset.register(sh);
            }
            {
                var shader = new egret3d.Shader("particles.shader.json");
                shader.renderQueue = egret3d.RenderQueue.Transparent;
                shader.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRAY };
                shader.defaultValue["_TintColor"] = { type: "Vector4", value: [1.0, 1.0, 1.0, 1.0] };
                shader.passes["base"] = [];
                var renderPass = new egret3d.DrawPass(def_particlesystem_vs, def_particlesystem_fs);
                renderPass.state_ztest = true;
                renderPass.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                renderPass.state_zwrite = true;
                renderPass.state_showface = egret3d.ShowFaceStateEnum.ALL;
                renderPass.setAlphaBlend(egret3d.BlendModeEnum.Close);
                shader.passes["base"].push(renderPass);
                this.PARTICLE = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = new egret3d.Shader("particles_additive.shader.json");
                shader.renderQueue = egret3d.RenderQueue.Transparent;
                shader.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRAY };
                shader.defaultValue["_TintColor"] = { type: "Vector4", value: [1.0, 1.0, 1.0, 1.0] };
                shader.passes["base"] = [];
                var renderPass = new egret3d.DrawPass(def_particlesystem_vs, def_particlesystem_fs);
                renderPass.state_ztest = true;
                renderPass.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                renderPass.state_zwrite = false;
                renderPass.state_showface = egret3d.ShowFaceStateEnum.ALL;
                renderPass.setAlphaBlend(egret3d.BlendModeEnum.Add);
                shader.passes["base"].push(renderPass);
                this.PARTICLE_ADDITIVE = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = new egret3d.Shader("particles_additive_premultiply.shader.json");
                shader.renderQueue = egret3d.RenderQueue.Transparent;
                shader.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRAY };
                shader.defaultValue["_TintColor"] = { type: "Vector4", value: [1.0, 1.0, 1.0, 1.0] };
                shader.passes["base"] = [];
                var renderPass = new egret3d.DrawPass(def_particlesystem_vs, def_particlesystem_fs);
                renderPass.state_ztest = true;
                renderPass.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                renderPass.state_zwrite = true;
                renderPass.state_showface = egret3d.ShowFaceStateEnum.ALL;
                renderPass.setAlphaBlend(egret3d.BlendModeEnum.Add_PreMultiply);
                shader.passes["base"].push(renderPass);
                this.PARTICLE_ADDITIVE_PREMYLTIPLY = shader;
                paper.Asset.register(shader);
            }
            {
                //TODO
                var shader = new egret3d.Shader("particles_blend1.shader.json");
                shader.renderQueue = egret3d.RenderQueue.Transparent;
                shader.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRAY };
                shader.defaultValue["_TintColor"] = { type: "Vector4", value: [1.0, 1.0, 1.0, 1.0] };
                shader.passes["base"] = [];
                var renderPass = new egret3d.DrawPass(def_particlesystem_vs, def_particlesystem_fs);
                renderPass.state_ztest = true;
                renderPass.state_ztest_method = egret3d.WebGLKit.LEQUAL;
                renderPass.state_zwrite = true;
                renderPass.state_showface = egret3d.ShowFaceStateEnum.ALL;
                renderPass.setAlphaBlend(egret3d.BlendModeEnum.Blend);
                shader.passes["base"].push(renderPass);
                this.PARTICLE_BLEND = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = new egret3d.Shader("particles_blend.shader.json");
                shader.renderQueue = egret3d.RenderQueue.Transparent;
                shader.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRAY };
                shader.defaultValue["_TintColor"] = { type: "Vector4", value: [1.0, 1.0, 1.0, 1.0] };
                shader.passes["base"] = [];
                var renderPass = new egret3d.DrawPass(def_particlesystem_vs, def_particlesystem_fs);
                renderPass.state_ztest = true;
                renderPass.state_ztest_method = egret3d.WebGLKit.EQUAL;
                renderPass.state_zwrite = true;
                renderPass.state_showface = egret3d.ShowFaceStateEnum.ALL;
                renderPass.setAlphaBlend(egret3d.BlendModeEnum.Blend);
                shader.passes["base"].push(renderPass);
                this.PARTICLE_BLEND = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = new egret3d.Shader("particles_blend_premultiply.shader.json");
                shader.renderQueue = egret3d.RenderQueue.Transparent;
                shader.defaultValue["_MainTex"] = { type: "Texture", value: egret3d.DefaultTextures.GRAY };
                shader.defaultValue["_TintColor"] = { type: "Vector4", value: [1.0, 1.0, 1.0, 1.0] };
                shader.passes["base"] = [];
                var renderPass = new egret3d.DrawPass(def_particlesystem_vs, def_particlesystem_fs);
                renderPass.state_ztest = true;
                renderPass.state_ztest_method = egret3d.WebGLKit.EQUAL;
                renderPass.state_zwrite = true;
                renderPass.state_showface = egret3d.ShowFaceStateEnum.ALL;
                renderPass.setAlphaBlend(egret3d.BlendModeEnum.Blend_PreMultiply);
                shader.passes["base"].push(renderPass);
                this.PARTICLE_BLEND_PREMYLTIPLY = shader;
                paper.Asset.register(shader);
            }
        };
        DefaultShaders._inited = false;
        return DefaultShaders;
    }());
    egret3d.DefaultShaders = DefaultShaders;
    __reflect(DefaultShaders.prototype, "egret3d.DefaultShaders");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _plane = {
        vbo: new Float32Array([
            -5, 0, 5, -5, 0, -5, 5, 0, 5, 5, 0, -5,
            0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
            1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            0, 0, 0, 1, 1, 0, 1, 1
        ]),
        ibo: new Uint16Array([
            0, 1, 2,
            2, 1, 3
        ])
    };
    var _cube = {
        vbo: new Float32Array([
            -0.5, -0.5, -0.5,
            -0.5, -0.5, 0.5,
            0.5, -0.5, -0.5,
            0.5, -0.5, 0.5,
            -0.5, 0.5, 0.5,
            -0.5, 0.5, -0.5,
            0.5, 0.5, 0.5,
            0.5, 0.5, -0.5,
            -0.5, -0.5, 0.5,
            -0.5, 0.5, 0.5,
            0.5, -0.5, 0.5,
            0.5, 0.5, 0.5,
            -0.5, 0.5, -0.5,
            -0.5, -0.5, -0.5,
            0.5, 0.5, -0.5,
            0.5, -0.5, -0.5,
            0.5, -0.5, -0.5,
            0.5, -0.5, 0.5,
            0.5, 0.5, -0.5,
            0.5, 0.5, 0.5,
            -0.5, -0.5, 0.5,
            -0.5, -0.5, -0.5,
            -0.5, 0.5, 0.5,
            -0.5, 0.5, -0.5,
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,
            0, 1, 0,
            0, 1, 0,
            0, 1, 0,
            0, 1, 0,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, -1,
            0, 0, -1,
            0, 0, -1,
            0, 0, -1,
            1, 0, 0,
            1, 0, 0,
            1, 0, 0,
            1, 0, 0,
            -1, 0, 0,
            -1, 0, 0,
            -1, 0, 0,
            -1, 0, 0,
            -1, 0, 0, 1,
            -1, 0, 0, 1,
            -1, 0, 0, 1,
            -1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            -1, 0, 0, 1,
            -1, 0, 0, 1,
            -1, 0, 0, 1,
            -1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            0, 0, 1, 1,
            0, 0, 1, 1,
            0, 0, 1, 1,
            0, 0, 1, 1,
            0, 0, -1, 1,
            0, 0, -1, 1,
            0, 0, -1, 1,
            0, 0, -1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            0, 0,
            0, 1,
            1, 0,
            1, 1,
            0, 0,
            0, 1,
            1, 0,
            1, 1,
            1, 1,
            1, 0,
            0, 1,
            0, 0,
            0, 0,
            0, 1,
            1, 0,
            1, 1,
            0, 1,
            1, 1,
            0, 0,
            1, 0,
            0, 1,
            1, 1,
            0, 0,
            1, 0,
        ]),
        ibo: new Uint16Array([
            0, 1, 2, 2, 1, 3,
            4, 5, 6, 6, 5, 7,
            8, 9, 10, 10, 9, 11,
            12, 13, 14, 14, 13, 15,
            16, 17, 18, 18, 17, 19,
            20, 21, 22, 22, 21, 23
        ])
    };
    var _circleLine = {
        vbo: new Float32Array([
            -0.5, 0.5, 0,
            -0.5, -0.5, 0,
            0.5, 0.5, 0,
            0.5, -0.5, 0,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            0, 0,
            0, 1,
            1, 0,
            1, 1,
        ]),
        ibo: new Uint16Array([
            0, 1, 2,
            2, 1, 3
        ])
    };
    var _quadParticle = {
        vbo: new Float32Array([
            0, 0.5, 0,
            0, -0.5, 0,
            1, 0.5, 0,
            1, -0.5, 0,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            0, 0,
            0, 1,
            1, 0,
            1, 1,
        ]),
        ibo: new Uint16Array([
            0, 1, 2,
            2, 1, 3
        ])
    };
    var _quad = {
        vbo: new Float32Array([
            -0.5, 0.5, 0,
            -0.5, -0.5, 0,
            0.5, 0.5, 0,
            0.5, -0.5, 0,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            0, 0,
            0, 1,
            1, 0,
            1, 1,
        ]),
        ibo: new Uint16Array([
            0, 1, 2,
            2, 1, 3
        ])
    };
    var _pyramid = {
        vbo: new Float32Array([
            -0.5, -1, -0.5,
            0, 1, 0,
            0.5, -1, -0.5,
            0.5, -1, -0.5,
            0, 1, 0,
            0.5, -1, 0.5,
            0.5, -1, 0.5,
            0, 1, 0,
            -0.5, -1, 0.5,
            -0.5, -1, 0.5,
            0, 1, 0,
            -0.5, -1, -0.5,
            -0.5, -1, -0.5,
            0.5, -1, -0.5,
            0.5, -1, 0.5,
            -0.5, -1, 0.5,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            0, 0,
            0.5, 0.5,
            0, 1,
            0, 1,
            0.5, 0.5,
            1, 1,
            1, 1,
            0.5, 0.5,
            1, 0,
            1, 0,
            0.5, 0.5,
            0, 0,
            0, 0,
            1, 0,
            1, 1,
            0, 1,
        ]),
        ibo: new Uint16Array([
            0, 2, 1, 3, 5, 4,
            6, 8, 7, 9, 11, 10,
            12, 14, 13, 15, 14, 12
        ])
    };
    var _box = {
        ibo: new Uint16Array([
            0, 1, 2, 2, 1, 3,
            4, 5, 6, 6, 5, 7,
            1, 3, 5, 5, 3, 7,
            0, 2, 4, 4, 2, 6,
            6, 2, 7, 7, 2, 3,
            0, 4, 1, 1, 4, 5,
        ])
    };
    var _attributesA = [
        "POSITION" /* POSITION */,
        "NORMAL" /* NORMAL */,
        "TANGENT" /* TANGENT */,
        "COLOR_0" /* COLOR_0 */,
        "TEXCOORD_0" /* TEXCOORD_0 */,
    ];
    var _attributesB = [
        "POSITION" /* POSITION */,
        "NORMAL" /* NORMAL */,
        "TEXCOORD_0" /* TEXCOORD_0 */,
    ];
    var DefaultMeshes = (function () {
        function DefaultMeshes() {
        }
        DefaultMeshes.init = function () {
            if (this._inited) {
                return;
            }
            this._inited = true;
            this.QUAD = this._createDefaultMeshA(_quad);
            this.QUAD_PARTICLE = this._createDefaultMeshA(_quadParticle);
            this.PLANE = this._createDefaultMeshA(_plane);
            this.CIRCLE_LINE = this._createDefaultMeshA(_circleLine);
            this.CUBE = this._createDefaultMeshA(_cube);
            this.PYRAMID = this._createDefaultMeshA(_pyramid);
            this.CYLINDER = this.createCylinderCCW(2, 0.5);
            this.SPHERE = this.createSphereCCW();
        };
        DefaultMeshes._createDefaultMeshA = function (data) {
            var mesh = new egret3d.Mesh(data.vbo, data.ibo, _attributesA);
            return mesh;
        };
        // public static createBoxMesh(width: number, height: number, depth: number, widthSegments: uint = 1, heightSegments: uint = 1, depthSegments: uint = 1) {
        //     // const vertexCount = 8;
        //     // const mesh = new Mesh(vertexCount, _box.ibo, _attributesC);
        //     // const vertices = mesh.getVertices();
        //     // for (let i = 0; i < vertexCount; ++i) {
        //     //     const iD = i * 3;
        //     //     const vertex = array[i];
        //     //     vertices[iD] = vertex.x;
        //     //     vertices[iD + 1] = vertex.y;
        //     //     vertices[iD + 2] = vertex.z;
        //     // }
        //     // mesh.uploadSubVertexBuffer(_attributesC);
        //     return mesh;
        // }
        DefaultMeshes.createCylinderCCW = function (height, radius, segment) {
            if (segment === void 0) { segment = 20; }
            var index = 0;
            var mesh = new egret3d.Mesh(4 * segment + 2, 3 * 4 * segment, _attributesB);
            var normal = new egret3d.Vector3(0.0, 1.0, 0.0);
            var indices = mesh.getIndices();
            for (var s = 0; s < 4; s++) {
                var y = (s < 2 ? 0.5 : -0.5) * height;
                if (s === 3) {
                    normal.x = 0.0;
                    normal.y = -1.0;
                    normal.z = 0.0;
                }
                for (var i = 0; i < segment; i++) {
                    var r = i / segment * Math.PI * 2.0;
                    var x = Math.sin(r);
                    var z = Math.cos(r);
                    if (s === 1 || s === 2) {
                        normal.x = x;
                        normal.y = 0.0;
                        normal.z = z;
                    }
                    mesh.setAttribute(index, "POSITION" /* POSITION */, 0, x * radius, y, z * radius);
                    // mesh.setVertexAttribute(index, gltf.MeshAttributeType.NORMAL, 0, normal.x, normal.y, normal.z);
                    if (s === 0 || s === 3) {
                        mesh.setAttribute(index, "TEXCOORD_0" /* TEXCOORD_0 */, 0, x * 0.5 + 0.5, z * 0.5 + 0.5);
                    }
                    else {
                        mesh.setAttribute(index, "TEXCOORD_0" /* TEXCOORD_0 */, 0, i / segment, y < 0.0 ? 0.0 : 1.0);
                    }
                    index++;
                }
            }
            // Top
            mesh.setAttribute(index, "POSITION" /* POSITION */, 0, 0.0, 0.5 * height, 0.0);
            // mesh.setVertexAttribute(index, gltf.MeshAttributeType.NORMAL, 0, 0.0, 1.0, 0.0);
            mesh.setAttribute(index, "TEXCOORD_0" /* TEXCOORD_0 */, 0, 0.5, 0.5);
            index++;
            // Bottom
            mesh.setAttribute(index, "POSITION" /* POSITION */, 0, 0.0, -0.5 * height, 0.0);
            // mesh.setVertexAttribute(index, gltf.MeshAttributeType.NORMAL, 0, 0.0, -1.0, 0.0);
            mesh.setAttribute(index, "TEXCOORD_0" /* TEXCOORD_0 */, 0, 0.5, 0.5);
            index++;
            //
            index = 0;
            var iTop = 4 * segment;
            var iBottom = 4 * segment + 1;
            for (var i = 0; i < segment; i++) {
                // Top
                indices[index++] = iTop;
                indices[index++] = i === segment - 1 ? segment * 0 + 0 : segment * 0 + i + 1;
                indices[index++] = segment * 0 + i + 0;
                // Bottom
                indices[index++] = iBottom;
                indices[index++] = segment * 3 + i + 0;
                indices[index++] = i === segment - 1 ? segment * 3 + 0 : segment * 3 + i + 1;
                // Side
                var t = segment * 1 + i;
                var t2 = i === segment - 1 ? segment * 1 + 0 : segment * 1 + i + 1;
                var b = segment * 2 + i;
                var b2 = i === segment - 1 ? segment * 2 + 0 : segment * 2 + i + 1;
                indices[index++] = t;
                indices[index++] = t2;
                indices[index++] = b;
                indices[index++] = t2;
                indices[index++] = b2;
                indices[index++] = b;
            }
            mesh.uploadSubVertexBuffer(_attributesB);
            mesh.uploadSubIndexBuffer();
            return mesh;
        };
        DefaultMeshes.createSphereCCW = function (radius, widthSegments, heightSegments) {
            if (radius === void 0) { radius = 1.0; }
            if (widthSegments === void 0) { widthSegments = 24; }
            if (heightSegments === void 0) { heightSegments = 12; }
            widthSegments = Math.max(3, Math.floor(widthSegments));
            heightSegments = Math.max(2, Math.floor(heightSegments));
            var mesh = new egret3d.Mesh((widthSegments + 1) * (heightSegments + 1), widthSegments * heightSegments * 6 - 6, _attributesB);
            //
            var index = 0;
            var iv = 0;
            var vertex = new egret3d.Vector3();
            var normal = new egret3d.Vector3();
            var grid = new Array();
            for (var iy = 0; iy <= heightSegments; iy++) {
                var verticesRow = new Array();
                var v = iy / heightSegments;
                for (var ix = 0; ix <= widthSegments; ix++) {
                    var u = ix / widthSegments;
                    // Vertex.
                    vertex.x = -radius * Math.cos(u * Math.PI * 2) * Math.sin(v * Math.PI);
                    vertex.y = radius * Math.cos(v * Math.PI);
                    vertex.z = radius * Math.sin(u * Math.PI * 2) * Math.sin(v * Math.PI);
                    mesh.setAttribute(iv, "POSITION" /* POSITION */, 0, vertex.x, vertex.y, vertex.z);
                    // Normal.
                    normal.x = vertex.x;
                    normal.y = vertex.y;
                    normal.z = vertex.z;
                    var num = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                    if (num > Number.MIN_VALUE) {
                        mesh.setAttribute(iv, "NORMAL" /* NORMAL */, 0, normal.x / num, normal.y / num, normal.z / num);
                    }
                    else {
                        mesh.setAttribute(iv, "NORMAL" /* NORMAL */, 0, 0.0, 0.0, 0.0);
                    }
                    mesh.setAttribute(iv, "TEXCOORD_0" /* TEXCOORD_0 */, 0, 1.0 - u, v);
                    iv++;
                    verticesRow.push(index++);
                }
                grid.push(verticesRow);
            }
            // Indices.
            var tris = new Array();
            for (var iy = 0; iy < heightSegments; iy++) {
                for (var ix = 0; ix < widthSegments; ix++) {
                    var a = grid[iy][ix + 1];
                    var b = grid[iy][ix];
                    var c = grid[iy + 1][ix];
                    var d = grid[iy + 1][ix + 1];
                    if (iy !== 0) {
                        tris.push(a, d, b);
                    }
                    if (iy !== heightSegments - 1) {
                        tris.push(b, d, c);
                    }
                }
            }
            var indices = mesh.getIndices();
            for (var i = 0, l = tris.length; i < l; i++) {
                indices[i] = tris[i];
            }
            mesh.uploadSubVertexBuffer(_attributesB);
            mesh.uploadSubIndexBuffer();
            return mesh;
        };
        DefaultMeshes._inited = false;
        return DefaultMeshes;
    }());
    egret3d.DefaultMeshes = DefaultMeshes;
    __reflect(DefaultMeshes.prototype, "egret3d.DefaultMeshes");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 正则表达式的工具类，提供一些引擎用到的正则表达式
     */
    var RegexpUtil = (function () {
        function RegexpUtil() {
        }
        // shader properties
        RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
        RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        // material
        RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        // 特效解析，[1,2],2,1
        RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
        return RegexpUtil;
    }());
    egret3d.RegexpUtil = RegexpUtil;
    __reflect(RegexpUtil.prototype, "egret3d.RegexpUtil");
})(egret3d || (egret3d = {}));
// 0.04 处理utf8 string 不能用encode decode
var egret3d;
(function (egret3d) {
    var io;
    (function (io) {
        var BinReader = (function () {
            function BinReader(buf, seek) {
                if (seek === void 0) { seek = 0; }
                this._seek = seek;
                this._data = new DataView(buf, seek);
            }
            BinReader.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinReader.prototype.peek = function () {
                return this._seek;
            };
            BinReader.prototype.length = function () {
                return this._data.byteLength;
            };
            BinReader.prototype.canread = function () {
                return this._data.byteLength - this._seek;
            };
            BinReader.prototype.readStringAnsi = function () {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            };
            BinReader.utf8ArrayToString = function (array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
            };
            BinReader.prototype.readStringUtf8 = function () {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readStringUtf8FixLength = function (length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readSingle = function () {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readDouble = function () {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            };
            BinReader.prototype.readInt8 = function () {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readUInt8 = function () {
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readInt16 = function () {
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readUInt16 = function () {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readInt32 = function () {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUInt32 = function () {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUint8Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            };
            BinReader.prototype.readUint8ArrayByOffset = function (target, offset, length) {
                if (length === void 0) { length = 0; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            };
            BinReader.prototype.readUint16Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this.readUInt16();
                }
                return target;
            };
            BinReader.prototype.readSingleArray = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                // console.log(this._data.byteLength, this._data.byteOffset);
                for (var i = 0; i < length; i++) {
                    // target[i] = this._data.getFloat32(this._seek, true);
                    // this._seek += 4;
                    target[i] = this.readSingle();
                }
                return target;
            };
            Object.defineProperty(BinReader.prototype, "position", {
                get: function () {
                    return this.peek();
                },
                set: function (value) {
                    this.seek(value);
                },
                enumerable: true,
                configurable: true
            });
            BinReader.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            BinReader.prototype.readByte = function () {
                return this.readUInt8();
            };
            BinReader.prototype.readBytes = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                return this.readUint8Array(target, offset, length);
            };
            BinReader.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            BinReader.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            BinReader.prototype.readFloat = function () {
                return this.readSingle();
            };
            BinReader.prototype.readUTFBytes = function (length) {
                var arry = new Uint8Array(length);
                return BinReader.utf8ArrayToString(this.readUint8Array(arry));
            };
            BinReader.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            BinReader.prototype.readShort = function () {
                return this.readInt16();
            };
            BinReader.prototype.readInt = function () {
                return this.readInt32();
            };
            return BinReader;
        }());
        io.BinReader = BinReader;
        __reflect(BinReader.prototype, "egret3d.io.BinReader");
        var BinWriter = (function () {
            function BinWriter() {
                var buf = new ArrayBuffer(1024);
                this._length = 0;
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            BinWriter.prototype.sureData = function (addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            };
            BinWriter.prototype.getLength = function () {
                return length;
            };
            BinWriter.prototype.getBuffer = function () {
                return this._buf.buffer.slice(0, this._length);
            };
            BinWriter.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinWriter.prototype.peek = function () {
                return this._seek;
            };
            BinWriter.prototype.writeInt8 = function (num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeUInt8 = function (num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeInt16 = function (num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeUInt16 = function (num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeInt32 = function (num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeUInt32 = function (num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeSingle = function (num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeDouble = function (num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            };
            BinWriter.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            };
            BinWriter.prototype.writeStringUtf8 = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            };
            BinWriter.stringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            };
            BinWriter.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            };
            BinWriter.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            };
            Object.defineProperty(BinWriter.prototype, "length", {
                get: function () {
                    return this._seek;
                },
                enumerable: true,
                configurable: true
            });
            BinWriter.prototype.writeByte = function (num) {
                this.writeUInt8(num);
            };
            BinWriter.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = 0; }
                this.writeUint8Array(array, offset, length);
            };
            BinWriter.prototype.writeUnsignedShort = function (num) {
                this.writeUInt16(num);
            };
            BinWriter.prototype.writeUnsignedInt = function (num) {
                this.writeUInt32(num);
            };
            BinWriter.prototype.writeFloat = function (num) {
                this.writeSingle(num);
            };
            BinWriter.prototype.writeUTFBytes = function (str) {
                var strArray = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            };
            BinWriter.prototype.writeSymbolByte = function (num) {
                this.writeInt8(num);
            };
            BinWriter.prototype.writeShort = function (num) {
                this.writeInt16(num);
            };
            BinWriter.prototype.writeInt = function (num) {
                this.writeInt32(num);
            };
            return BinWriter;
        }());
        io.BinWriter = BinWriter;
        __reflect(BinWriter.prototype, "egret3d.io.BinWriter");
    })(io = egret3d.io || (egret3d.io = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var utils;
    (function (utils) {
        function getRelativePath(targetPath, sourcePath) {
            var relPath = "";
            targetPath = targetPath.replace("\\", "/");
            sourcePath = sourcePath.replace("\\", "/");
            var targetPathArr = targetPath.split('/');
            var sourcePathArr = sourcePath.split('/');
            var targetPathLen = targetPathArr.length;
            var sourcePathLen = sourcePathArr.length;
            var i = 0;
            while (targetPathArr[i] == sourcePathArr[i] && i < targetPathLen && i < sourcePathLen) {
                i++;
            }
            for (var j = 0; j < sourcePathLen - i - 1; j++) {
                relPath += "../";
            }
            targetPathArr = targetPathArr.slice(i, targetPathArr.length);
            relPath = relPath + targetPathArr.join("/");
            relPath = relPath.replace(" ", "_");
            return relPath;
        }
        utils.getRelativePath = getRelativePath;
    })(utils = egret3d.utils || (egret3d.utils = {}));
})(egret3d || (egret3d = {}));
var Stats;
(function (Stats_1) {
    var stats;
    var loop;
    /**
     * 显示调试面板
     */
    function show(container, refreshTime) {
        if (refreshTime === void 0) { refreshTime = 500; }
        if (stats == null) {
            stats = new Stats();
            stats.container.style.position = 'absolute';
            stats.container.style.left = '0px';
            stats.container.style.top = '0px';
            container.appendChild(stats.container);
        }
        else {
            container.appendChild(stats.container);
        }
        if (loop) {
            hide();
        }
        loop = setInterval(function () {
            stats.update();
        }, refreshTime);
        egret3d.Performance.enable = true;
    }
    Stats_1.show = show;
    /**
     * 关闭调试面板
     */
    function hide() {
        if (loop) {
            clearInterval(loop);
        }
        if (stats != null && stats.container.parentNode) {
            stats.container.parentNode.removeChild(stats.container);
        }
        egret3d.Performance.enable = false;
    }
    Stats_1.hide = hide;
    /**
     *
     * @author mrdoob / http://mrdoob.com/
     * @modify egret
     */
    var Stats = (function () {
        function Stats() {
            var _this = this;
            this.mode = 0;
            this.container = document.createElement('div');
            this.container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.7;z-index:1';
            this.container.addEventListener('click', function (event) {
                event.preventDefault();
                _this.showPanel(++_this.mode % _this.container.children.length);
            }, false);
            this.fpsPanel = this.addPanel(new Panel('FPS', '#0ff', '#002'));
            this.msPanel = this.addPanel(new Panel('MS', '#0f0', '#020'));
            this.renderPanel = this.addPanel(new Panel('R%', '#0f0', '#020'));
            if (self.performance && self.performance["memory"]) {
                this.memPanel = this.addPanel(new Panel('MB', '#f08', '#201'));
            }
            this.showPanel(0);
        }
        Stats.prototype.update = function () {
            var fps = egret3d.Performance.getFPS();
            var fpsEntity = egret3d.Performance.getEntity("fps");
            var allEntity = egret3d.Performance.getEntity("all");
            var renderEntity = egret3d.Performance.getEntity("render");
            this.fpsPanel.update(fps, 100);
            this.msPanel.update(allEntity.delta, 200);
            this.renderPanel.update(Math.floor(renderEntity.delta / fpsEntity.delta * 100), 100);
            if (this.memPanel) {
                var memory = performance["memory"];
                this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
            }
        };
        Stats.prototype.showPanel = function (id) {
            for (var i = 0; i < this.container.children.length; i++) {
                this.container.children[i]["style"].display = i === id ? 'block' : 'none';
            }
            this.mode = id;
        };
        Stats.prototype.addPanel = function (panel) {
            this.container.appendChild(panel.canvas);
            return panel;
        };
        return Stats;
    }());
    __reflect(Stats.prototype, "Stats");
    /**
     *
     */
    var Panel = (function () {
        function Panel(name, fg, bg) {
            this.name = name;
            this.fg = fg;
            this.bg = bg;
            this.min = Infinity;
            this.max = 0;
            this.PR = Math.round(window.devicePixelRatio || 1);
            this.WIDTH = 80 * this.PR;
            this.HEIGHT = 48 * this.PR;
            this.TEXT_X = 3 * this.PR;
            this.TEXT_Y = 2 * this.PR;
            this.GRAPH_X = 3 * this.PR;
            this.GRAPH_Y = 15 * this.PR;
            this.GRAPH_WIDTH = 74 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR;
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.WIDTH;
            this.canvas.height = this.HEIGHT;
            this.canvas.style.cssText = 'width:80px;height:48px';
            this.context = this.canvas.getContext('2d');
            this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';
            this.context.textBaseline = 'top';
            this.context.fillStyle = bg;
            this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);
            this.context.fillStyle = fg;
            this.context.fillText(name, this.TEXT_X, this.TEXT_Y);
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
            this.context.fillStyle = bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
        }
        Panel.prototype.update = function (value, maxValue) {
            this.min = Math.min(this.min, value);
            this.max = Math.max(this.max, value);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 1;
            this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);
            this.context.fillStyle = this.fg;
            this.context.fillText(Math.round(value) + ' ' + this.name + ' (' + Math.round(this.min) + '-' + Math.round(this.max) + ')', this.TEXT_X, this.TEXT_Y);
            this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT);
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, Math.round((1 - (value / maxValue)) * this.GRAPH_HEIGHT));
        };
        return Panel;
    }());
    __reflect(Panel.prototype, "Panel");
})(Stats || (Stats = {}));
var egret3d;
(function (egret3d) {
    /**
     * device input manager
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 用户输入设备管理器
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var InputManager = (function () {
        function InputManager() {
        }
        /**
         *
         */
        InputManager.init = function (canvas) {
            if (this._isInit) {
                return;
            }
            this._isInit = true;
            this.keyboard = new egret3d.KeyboardDevice(window);
            this.mouse = new egret3d.MouseDevice(canvas);
            this.touch = new egret3d.TouchDevice(canvas);
        };
        /**
         *
         */
        InputManager.update = function (deltaTime) {
            this.keyboard.update();
            this.mouse.update();
            this.touch.update();
        };
        /**
         * is pressed
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 是否正在被点击或者触摸
         * 只有单点触摸才被触发，多点触摸请使用 MouseDivice
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.isPressed = function () {
            if (this.mouse.isPressed(0)) {
                return true;
            }
            else {
                var t = this.touch.getTouch(0);
                if (t && this.touch.touchCount == 1) {
                    if (t.phase == egret3d.TouchPhase.MOVED || t.phase == egret3d.TouchPhase.STATIONARY) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * was pressed
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 是否完成一次点击或触摸
         * 只有单点触摸才被触发，多点触摸请使用 MouseDivice
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.wasPressed = function () {
            if (this.mouse.wasPressed(0)) {
                return true;
            }
            else {
                var t = this.touch.getTouch(0);
                if (t && this.touch.touchCount == 1) {
                    if (t.phase == egret3d.TouchPhase.BEGAN) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * was released
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 是否完成一次鼠标或触摸释放。
         * 只有单点触摸才被触发，多点触摸请使用 MouseDivice
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.wasReleased = function () {
            if (this.mouse.wasReleased(0)) {
                return true;
            }
            else {
                var t = this.touch.getTouch(0);
                if (t && this.touch.touchCount == 1) {
                    if (t.phase == egret3d.TouchPhase.ENDED || t.phase == egret3d.TouchPhase.CANCELED) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * get touch point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取点击或触摸位置
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.getTouchPoint = function () {
            var t = this.touch.getTouch(0);
            if (t) {
                this._touchPoint.x = t.position.x;
                this._touchPoint.y = t.position.y;
            }
            else {
                this._touchPoint.x = this.mouse.position.x;
                this._touchPoint.y = this.mouse.position.y;
            }
            return this._touchPoint;
        };
        InputManager._isInit = false;
        InputManager._touchPoint = new egret3d.Vector2();
        return InputManager;
    }());
    egret3d.InputManager = InputManager;
    __reflect(InputManager.prototype, "egret3d.InputManager");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _keyCodeToKeyIdentifier = {
        'TAB': 9,
        'ENTER': 13,
        'SHIFT': 16,
        'CONTROL': 17,
        'ALT': 18,
        'ESCAPE': 27,
        'LEFT': 37,
        'UP': 38,
        'RIGHT': 39,
        'DOWN': 40,
        'DELETE': 46,
        'WIN': 91
    };
    /**
     * keyboard input
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 键盘输入
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var KeyboardDevice = (function () {
        /**
         *
         */
        function KeyboardDevice(element, options) {
            if (options === void 0) { options = { preventDefault: false, stopPropagation: false }; }
            this._element = null;
            this._keymap = {};
            this._lastmap = {};
            this._keyDownHandler = this._handleKeyDown.bind(this);
            this._keyUpHandler = this._handleKeyUp.bind(this);
            this._keyPressHandler = this._handleKeyPress.bind(this);
            this._cacheKeyCodeMap = {};
            this.attach(element);
            this.preventDefault = options.preventDefault;
            this.stopPropagation = options.stopPropagation;
        }
        KeyboardDevice.prototype.attach = function (element) {
            if (this._element) {
                this.detach();
            }
            this._element = element;
            this._element.addEventListener("keydown", this._keyDownHandler, false);
            this._element.addEventListener("keypress", this._keyPressHandler, false);
            this._element.addEventListener("keyup", this._keyUpHandler, false);
        };
        KeyboardDevice.prototype.detach = function () {
            if (!this._element)
                return;
            this._element.removeEventListener("keydown", this._keyDownHandler, false);
            this._element.removeEventListener("keypress", this._keyPressHandler, false);
            this._element.removeEventListener("keyup", this._keyUpHandler, false);
            this._element = null;
        };
        KeyboardDevice.prototype._handleKeyDown = function (event) {
            var code = event.keyCode || event.charCode;
            var id = this._toKeyIdentifier(code);
            this._keymap[id] = true;
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        KeyboardDevice.prototype._handleKeyPress = function (event) {
            var code = event.keyCode || event.charCode;
            var id = this._toKeyIdentifier(code);
            // do nothing
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        KeyboardDevice.prototype._handleKeyUp = function (event) {
            var code = event.keyCode || event.charCode;
            var id = this._toKeyIdentifier(code);
            delete this._keymap[id];
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        KeyboardDevice.prototype._toKeyIdentifier = function (keyCode) {
            var code;
            if (typeof (keyCode) == "string") {
                var upperCode = keyCode.toUpperCase();
                if (!this._cacheKeyCodeMap[keyCode]) {
                    var _code = _keyCodeToKeyIdentifier[upperCode] || upperCode.charCodeAt(0);
                    this._cacheKeyCodeMap[upperCode] = _code;
                }
                code = this._cacheKeyCodeMap[upperCode];
            }
            else {
                code = keyCode;
            }
            // Convert to hex and add leading 0's
            var hex = code.toString(16).toUpperCase();
            var length = hex.length;
            for (var count = 0; count < (4 - length); count++) {
                hex = '0' + hex;
            }
            return 'U+' + hex;
        };
        /**
         *
         */
        KeyboardDevice.prototype.update = function () {
            var prop;
            for (prop in this._lastmap) {
                delete this._lastmap[prop];
            }
            for (prop in this._keymap) {
                if (this._keymap.hasOwnProperty(prop)) {
                    this._lastmap[prop] = this._keymap[prop];
                }
            }
        };
        /**
         * is pressed
         * @param key key code or char string
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键是否在按下状态
         * @param key 按键，可以为健值或者字符。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        KeyboardDevice.prototype.isPressed = function (key) {
            var id = this._toKeyIdentifier(key);
            return this._keymap[id];
        };
        /**
         * was pressed
         * @param key key code or char string
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被按下一次
         * @param key 按键，可以为健值或者字符。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        KeyboardDevice.prototype.wasPressed = function (key) {
            var id = this._toKeyIdentifier(key);
            return (this._keymap[id] && !this._lastmap[id]);
        };
        /**
         * was released
         * @param key key code or char string
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被抬起一次
         * @param key 按键，可以为健值或者字符。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        KeyboardDevice.prototype.wasReleased = function (key) {
            var id = this._toKeyIdentifier(key);
            return (!this._keymap[id] && this._lastmap[id]);
        };
        return KeyboardDevice;
    }());
    egret3d.KeyboardDevice = KeyboardDevice;
    __reflect(KeyboardDevice.prototype, "egret3d.KeyboardDevice");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * mouse input
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 鼠标输入
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var MouseDevice = (function (_super) {
        __extends(MouseDevice, _super);
        /**
         *
         */
        function MouseDevice(element) {
            var _this = _super.call(this) || this;
            _this._offsetX = 0;
            _this._offsetY = 0;
            _this._scalerX = 1;
            _this._scalerY = 1;
            _this._rotated = false;
            /**
             * mouse position
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前鼠标位置
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.position = new egret3d.Vector2();
            /**
             * mouse wheel value
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前鼠标滚轮值
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.wheel = 0;
            _this._buttons = [false, false, false];
            _this._lastbuttons = [false, false, false];
            _this._element = null;
            _this._upHandler = _this._handleUp.bind(_this);
            _this._moveHandler = _this._handleMove.bind(_this);
            _this._downHandler = _this._handleDown.bind(_this);
            _this._wheelHandler = _this._handleWheel.bind(_this);
            _this._contextMenuHandler = function (event) { event.preventDefault(); };
            _this.attach(element);
            return _this;
        }
        /**
         *
         */
        MouseDevice.prototype.updateOffsetAndScale = function (offsetX, offsetY, scalerX, scalerY, rotated) {
            this._offsetX = offsetX;
            this._offsetY = offsetY;
            this._scalerX = scalerX;
            this._scalerY = scalerY;
            this._rotated = rotated;
        };
        /**
         *
         */
        MouseDevice.prototype.convertPosition = function (e, out) {
            if (this._rotated) {
                out.y = (window.innerWidth - e.clientX + this._offsetX) * this._scalerX;
                out.x = (e.clientY - this._offsetY) * this._scalerY;
            }
            else {
                out.x = (e.clientX - this._offsetX) * this._scalerX;
                out.y = (e.clientY - this._offsetY) * this._scalerY;
            }
        };
        /**
         * disable right key menu
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 禁用右键菜单
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.disableContextMenu = function () {
            if (!this._element)
                return;
            this._element.addEventListener("contextmenu", this._contextMenuHandler);
        };
        /**
         * enable right key menu
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 启用右键菜单
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.enableContextMenu = function () {
            if (!this._element)
                return;
            this._element.removeEventListener("contextmenu", this._contextMenuHandler);
        };
        MouseDevice.prototype.attach = function (element) {
            if (this._element) {
                this.detach();
            }
            this._element = element;
            this._element.addEventListener("mouseup", this._upHandler, false);
            this._element.addEventListener("mousemove", this._moveHandler, false);
            this._element.addEventListener("mousedown", this._downHandler, false);
            this._element.addEventListener("mousewheel", this._wheelHandler, false); // WebKit
            this._element.addEventListener("DOMMouseScroll", this._wheelHandler, false); // Gecko
        };
        MouseDevice.prototype.detach = function () {
            if (!this._element)
                return;
            this._element.removeEventListener("mouseup", this._upHandler, false);
            this._element.removeEventListener("mousemove", this._moveHandler, false);
            this._element.removeEventListener("mousedown", this._downHandler, false);
            this._element.removeEventListener("mousewheel", this._wheelHandler, false); // WebKit
            this._element.removeEventListener("DOMMouseScroll", this._wheelHandler, false); // Gecko
            this._element = null;
        };
        /**
         *
         */
        MouseDevice.prototype.update = function () {
            // Copy current button state
            this._lastbuttons[0] = this._buttons[0];
            this._lastbuttons[1] = this._buttons[1];
            this._lastbuttons[2] = this._buttons[2];
            // set wheel to 0
            this.wheel = 0;
        };
        /**
         * is pressed
         * @param key key value. 0: left key; 1: middle key; 2: right key.
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键是否在按下状态
         * @param key 按键。0: 左键；1: 中键；2: 右键。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.isPressed = function (button) {
            return this._buttons[button];
        };
        /**
         * was pressed
         * @param key key value. 0: left key; 1: middle key; 2: right key.
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被按下一次
         * @param key 按键。0: 左键；1: 中键；2: 右键。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.wasPressed = function (button) {
            return (this._buttons[button] && !this._lastbuttons[button]);
        };
        /**
         * was released
         * @param key key value. 0: left key; 1: middle key; 2: right key.
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被抬起一次
         * @param key 按键。0: 左键；1: 中键；2: 右键。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.wasReleased = function (button) {
            return (!this._buttons[button] && this._lastbuttons[button]);
        };
        MouseDevice.prototype._handleUp = function (event) {
            // disable released button
            this._buttons[event.button] = false;
            this.convertPosition(event, this.position);
            this.dispatchEvent({ type: "mouseup", x: this.position.x, y: this.position.y, identifier: event.button });
        };
        MouseDevice.prototype._handleMove = function (event) {
            this.convertPosition(event, this.position);
            if (this._buttons[event.button]) {
                this.dispatchEvent({ type: "mousemove", x: this.position.x, y: this.position.y, identifier: event.button });
            }
        };
        MouseDevice.prototype._handleDown = function (event) {
            // Store which button has affected
            this._buttons[event.button] = true;
            this.convertPosition(event, this.position);
            this.dispatchEvent({ type: "mousedown", x: this.position.x, y: this.position.y, identifier: event.button });
        };
        MouseDevice.prototype._handleWheel = function (event) {
            // FF uses 'detail' and returns a value in 'no. of lines' to scroll
            // WebKit and Opera use 'wheelDelta', WebKit goes in multiples of 120 per wheel notch
            if (event.detail) {
                this.wheel = -1 * event.detail;
            }
            else if (event.wheelDelta) {
                this.wheel = event.wheelDelta / 120;
            }
            else {
                this.wheel = 0;
            }
        };
        return MouseDevice;
    }(egret3d.EventDispatcher));
    egret3d.MouseDevice = MouseDevice;
    __reflect(MouseDevice.prototype, "egret3d.MouseDevice");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * touch phase type
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 触摸状态
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var TouchPhase;
    (function (TouchPhase) {
        /**
         * touch began
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸开始
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["BEGAN"] = 0] = "BEGAN";
        /**
         * touch moved
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸移动
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["MOVED"] = 1] = "MOVED";
        /**
         * touch stationary
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸静止
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["STATIONARY"] = 2] = "STATIONARY";
        /**
         * touch ended
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸结束
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["ENDED"] = 3] = "ENDED";
        /**
         * touch canceled
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸取消
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["CANCELED"] = 4] = "CANCELED";
    })(TouchPhase = egret3d.TouchPhase || (egret3d.TouchPhase = {}));
    /**
     * touch point
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 触摸点信息
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var TouchPoint = (function () {
        function TouchPoint() {
            this.altitudeAngle = Math.PI / 2; // Value of 0 radians indicates that the stylus is parallel to the surface, pi/2 indicates that it is perpendicular.
            this.azimuthAngle = 0; // Value of 0 radians indicates that the stylus is pointed along the x-axis of the device.
            this.deltaPosition = new egret3d.Vector2(); // The position delta since last change.
            // public deltaTime:number = 0; // TODO Amount of time that has passed since the last recorded change in Touch values.
            this.fingerId = 0; // The unique index for the touch.
            this.maximumPossiblePressure = 1.0; // The maximum possible pressure value for a platform. If Input.touchPressureSupported returns false, the value of this property will always be 1.0f.
            this.position = new egret3d.Vector2(); // The position of the touch in pixel coordinates.
            this.pressure = 1.0; //	The current amount of pressure being applied to a touch. 1.0f is considered to be the pressure of an average touch. If Input.touchPressureSupported returns false, the value of this property will always be 1.0f.
            this.radius = new egret3d.Vector2(); // ADD: different from Unity
            // public radius:number = 0; // DELETE: An estimated value of the radius of a touch. Add radiusletiance to get the maximum touch size, subtract it to get the minimum touch size.
            // public radiusletiance:number = 0; // DELETE: The amount that the radius leties by for a touch.
            // public rawPosition:Vector2 = new Vector2(); // DELETE: The raw position used for the touch.
            // public tapCount:number = 0; // TODO Number of taps.
            this.type = "Direct"; // A value that indicates whether a touch was of Direct, Indirect (or remote), or Stylus type.
        }
        /**
         *
         */
        TouchPoint.prototype.set = function (touch, phase, device) {
            this.altitudeAngle = touch.rotationAngle;
            this.azimuthAngle = touch.rotationAngle;
            if (phase == TouchPhase.BEGAN || phase == TouchPhase.STATIONARY) {
                this.deltaPosition.x = 0;
                this.deltaPosition.y = 0;
            }
            else {
                device.convertPosition(touch, this.deltaPosition);
                egret3d.Vector2.subtract(this.deltaPosition, this.position, this.deltaPosition);
            }
            // this.deltaTime;
            this.fingerId = touch.identifier;
            this.phase = phase;
            device.convertPosition(touch, this.position);
            this.pressure = touch.force;
            this.radius.x = touch.radiusX;
            this.radius.y = touch.radiusY;
            // this.tapCount;
        };
        /**
         *
         */
        TouchPoint.create = function () {
            return this._pointPool.pop() || new TouchPoint();
        };
        /**
         *
         */
        TouchPoint.release = function (touchPoint) {
            this._pointPool.push(touchPoint);
        };
        TouchPoint._pointPool = [];
        return TouchPoint;
    }());
    egret3d.TouchPoint = TouchPoint;
    __reflect(TouchPoint.prototype, "egret3d.TouchPoint");
    /**
     * touch input
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 触摸输入
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var TouchDevice = (function (_super) {
        __extends(TouchDevice, _super);
        /**
         *
         */
        function TouchDevice(element, options) {
            if (options === void 0) { options = { preventDefault: true, stopPropagation: true }; }
            var _this = _super.call(this) || this;
            _this._offsetX = 0;
            _this._offsetY = 0;
            _this._scalerX = 1;
            _this._scalerY = 1;
            _this._rotated = false;
            _this._touchesMap = {};
            _this._touches = [];
            /**
             * touch count
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前触摸点的数量
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.touchCount = 0;
            _this._startHandler = _this._handleTouchStart.bind(_this);
            _this._endHandler = _this._handleTouchEnd.bind(_this);
            _this._moveHandler = _this._handleTouchMove.bind(_this);
            _this._cancelHandler = _this._handleTouchCancel.bind(_this);
            _this._element = null;
            _this.attach(element);
            _this.preventDefault = options.preventDefault;
            _this.stopPropagation = options.stopPropagation;
            return _this;
        }
        /**
         *
         */
        TouchDevice.prototype.updateOffsetAndScale = function (offsetX, offsetY, scalerX, scalerY, rotated) {
            this._offsetX = offsetX;
            this._offsetY = offsetY;
            this._scalerX = scalerX;
            this._scalerY = scalerY;
            this._rotated = rotated;
        };
        /**
         *
         */
        TouchDevice.prototype.convertPosition = function (e, out) {
            if (this._rotated) {
                out.y = (window.innerWidth - e.clientX + this._offsetX) * this._scalerX;
                out.x = (e.clientY - this._offsetY) * this._scalerY;
            }
            else {
                out.x = (e.clientX - this._offsetX) * this._scalerX;
                out.y = (e.clientY - this._offsetY) * this._scalerY;
            }
        };
        TouchDevice.prototype.attach = function (element) {
            if (this._element) {
                this.detach();
            }
            this._element = element;
            this._element.addEventListener('touchstart', this._startHandler, false);
            this._element.addEventListener('touchend', this._endHandler, false);
            this._element.addEventListener('touchmove', this._moveHandler, false);
            this._element.addEventListener('touchcancel', this._cancelHandler, false);
        };
        TouchDevice.prototype.detach = function () {
            if (!this._element)
                return;
            this._element.removeEventListener('touchstart', this._startHandler, false);
            this._element.removeEventListener('touchend', this._endHandler, false);
            this._element.removeEventListener('touchmove', this._moveHandler, false);
            this._element.removeEventListener('touchcancel', this._cancelHandler, false);
            this._element = null;
        };
        /**
         *
         */
        TouchDevice.prototype.update = function () {
            for (var i in this._touchesMap) {
                var touch = this._touchesMap[i];
                if (touch.phase === TouchPhase.BEGAN) {
                    touch.phase = TouchPhase.STATIONARY;
                }
                if (touch.phase === TouchPhase.MOVED) {
                    touch.phase = TouchPhase.STATIONARY;
                }
                if (touch.phase === TouchPhase.ENDED || touch.phase === TouchPhase.CANCELED) {
                    delete this._touchesMap[i];
                    var index = this._touches.indexOf(touch);
                    if (index > -1) {
                        this._touches.splice(index, 1);
                    }
                    this.touchCount--;
                }
            }
        };
        /**
         * get touch point
         * @param index touch index
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取触摸点
         * @param index 触摸点的索引
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchDevice.prototype.getTouch = function (index) {
            return this._touches[index];
        };
        TouchDevice.prototype._getTouch = function (identifier) {
            var touchPoint = this._touchesMap[identifier];
            if (!touchPoint) {
                touchPoint = TouchPoint.create();
                this._touchesMap[identifier] = touchPoint;
                this._touches.push(touchPoint);
                this.touchCount++;
            }
            return touchPoint;
        };
        TouchDevice.prototype._handleTouchStart = function (event) {
            // call preventDefault to avoid issues in Chrome Android:
            // http://wilsonpage.co.uk/touch-events-in-chrome-android/
            if (event["isScroll"] != true && !this._element['userTyping']) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.BEGAN, this);
                this.dispatchEvent({ type: "touchstart", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        TouchDevice.prototype._handleTouchEnd = function (event) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.ENDED, this);
                this.dispatchEvent({ type: "touchend", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        TouchDevice.prototype._handleTouchMove = function (event) {
            // call preventDefault to avoid issues in Chrome Android:
            // http://wilsonpage.co.uk/touch-events-in-chrome-android/
            if (event["isScroll"] != true && !this._element['userTyping']) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.MOVED, this);
                this.dispatchEvent({ type: "touchmove", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        TouchDevice.prototype._handleTouchCancel = function (event) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.CANCELED, this);
                this.dispatchEvent({ type: "touchend", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        return TouchDevice;
    }(egret3d.EventDispatcher));
    egret3d.TouchDevice = TouchDevice;
    __reflect(TouchDevice.prototype, "egret3d.TouchDevice");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var EndSystem = (function (_super) {
        __extends(EndSystem, _super);
        function EndSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [{ componentClass: paper.Behaviour, isExtends: true }];
            return _this;
        }
        EndSystem.prototype._onAddComponent = function (component) {
            var index = this._components.indexOf(component);
            if (index >= 0) {
                this._components[index] = null;
                return;
            }
            var gameObject = component.gameObject;
            console.debug("EndSystem remove behaviour error.", gameObject.name, gameObject.uuid, egret.getQualifiedClassName(component));
        };
        EndSystem.prototype._onRemoveComponent = function (component) {
            if (this._components.indexOf(component) < 0) {
                this._components.push(component);
                return;
            }
            var gameObject = component.gameObject;
            console.debug("EndSystem add behaviour error.", gameObject.name, gameObject.uuid, egret.getQualifiedClassName(component));
        };
        EndSystem.prototype.onUpdate = function () {
            if (this._isEditorUpdate()) {
                if (this._components.length > 0) {
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (component && paper._executeInEditModeComponents.indexOf(component.constructor) >= 0) {
                            component.onDisable && component.onDisable();
                        }
                    }
                    this._components.length = 0;
                }
            }
            else if (this._components.length > 0) {
                for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                    var component = _c[_b];
                    if (component) {
                        component.onDisable && component.onDisable();
                    }
                }
                this._components.length = 0;
            }
        };
        return EndSystem;
    }(paper.BaseSystem));
    paper.EndSystem = EndSystem;
    __reflect(EndSystem.prototype, "paper.EndSystem");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var WebGLKit = (function () {
        function WebGLKit() {
        }
        WebGLKit.activeTexture = function (index) {
            if (this._activeTextureIndex != index) {
                this.webgl.activeTexture(WebGLKit._texNumber[index]);
                this._activeTextureIndex = index;
            }
        };
        WebGLKit.showFace = function (value, frontFaceCW) {
            if (frontFaceCW === void 0) { frontFaceCW = false; }
            if (this._showFace != value || this._frontFaceCW != frontFaceCW) {
                var webgl = this.webgl;
                if (value == egret3d.ShowFaceStateEnum.ALL) {
                    webgl.disable(webgl.CULL_FACE);
                }
                else {
                    var ccw = (value == egret3d.ShowFaceStateEnum.CCW);
                    if (frontFaceCW) {
                        ccw = !ccw;
                    }
                    if (ccw) {
                        webgl.frontFace(webgl.CCW);
                    }
                    else {
                        webgl.frontFace(webgl.CW);
                    }
                    webgl.cullFace(webgl.BACK);
                    webgl.enable(webgl.CULL_FACE);
                }
                this._showFace = value;
                this._frontFaceCW = frontFaceCW;
            }
        };
        WebGLKit.zWrite = function (value) {
            if (this._zWrite !== value) {
                this.webgl.depthMask(value);
                this._zWrite = value;
            }
        };
        WebGLKit.zTest = function (value) {
            if (this._zTest !== value) {
                var webgl = this.webgl;
                if (value) {
                    webgl.enable(webgl.DEPTH_TEST);
                }
                else {
                    webgl.disable(webgl.DEPTH_TEST);
                }
                this._zTest = value;
            }
        };
        WebGLKit.zTestMethod = function (value) {
            if (this._zTestMethod !== value) {
                this.webgl.depthFunc(value);
                this._zTestMethod = value;
            }
        };
        WebGLKit.blend = function (value, equation, srcRGB, destRGB, srcAlpha, destAlpha) {
            var webgl = this.webgl;
            if (this._blend !== value) {
                value ? webgl.enable(webgl.BLEND) : webgl.disable(webgl.BLEND);
                this._blend = value;
            }
            if (value) {
                webgl.blendEquation(equation);
                // this.webgl.blendFunc(this.webgl.ONE, this.webgl.ONE_MINUS_SRC_ALPHA);
                webgl.blendFuncSeparate(srcRGB, destRGB, srcAlpha, destAlpha);
            }
        };
        WebGLKit.useProgram = function (program) {
            if (this._program != program) {
                this._program = program;
                this.webgl.useProgram(program);
                return true;
            }
            return false;
        };
        WebGLKit.setStates = function (drawPass, frontFaceCW) {
            if (frontFaceCW === void 0) { frontFaceCW = false; }
            WebGLKit.showFace(drawPass.state_showface, frontFaceCW);
            WebGLKit.zWrite(drawPass.state_zwrite);
            WebGLKit.zTest(drawPass.state_ztest);
            WebGLKit.blend(drawPass.state_blend, drawPass.state_blendEquation, drawPass.state_blendSrcRGB, drawPass.state_blendDestRGB, drawPass.state_blendSrcAlpha, drawPass.state_blendDestALpha);
            if (drawPass.state_ztest) {
                WebGLKit.zTestMethod(drawPass.state_ztest_method);
            }
        };
        WebGLKit.draw = function (context, basetype) {
            if (basetype === void 0) { basetype = "base"; }
            var drawCall = context.drawCall;
            var renderer = drawCall.renderer;
            var material = drawCall.material;
            if (!material) {
                console.warn("Material error.", renderer.gameObject.name, renderer.gameObject.uuid);
                return;
            }
            var shader = material.getShader();
            if (!shader) {
                console.warn("Shader error.", renderer.gameObject.name, renderer.gameObject.uuid);
                return;
            }
            var drawPasses = shader.passes[basetype + context.drawtype];
            if (!drawPasses) {
                drawPasses = shader.passes["base" + context.drawtype];
            }
            if (!drawPasses) {
                console.warn("draw passes error.", renderer.gameObject.name, renderer.gameObject.uuid);
                return;
            }
            // WebGLKit.draw(context, drawCall.material, drawCall.mesh, drawCall.subMeshIndex, drawType, transform._worldMatrixDeterminant < 0);
            var frontFaceCW = renderer.gameObject.transform._worldMatrixDeterminant < 0;
            var webGL = this.webgl;
            var mesh = drawCall.mesh;
            for (var i = 0; i < drawPasses.length; i++) {
                var pass = drawPasses[i];
                var program = egret3d.GlProgram.get(pass, context, material);
                this.setStates(pass, frontFaceCW);
                var force = WebGLKit.useProgram(program.program);
                program.uploadUniforms(material, context, force);
                program.bindAttributes(drawCall.mesh, drawCall.subMeshIndex, force);
                var primitive = mesh.glTFMesh.primitives[drawCall.subMeshIndex];
                var vertexAccessor = mesh.glTFAsset.getAccessor(primitive.attributes.POSITION);
                var bufferOffset = mesh.glTFAsset.getBufferOffset(vertexAccessor);
                if (primitive.indices !== undefined) {
                    var indexAccessor = mesh.glTFAsset.getAccessor(primitive.indices);
                    switch (primitive.mode) {
                        case 1 /* Lines */:
                            webGL.drawElements(webGL.LINES, indexAccessor.count, webGL.UNSIGNED_SHORT, bufferOffset);
                            break;
                        case 4 /* Triangles */:
                        default:
                            webGL.drawElements(webGL.TRIANGLES, indexAccessor.count, webGL.UNSIGNED_SHORT, bufferOffset);
                            break;
                    }
                }
                else {
                    switch (primitive.mode) {
                        case 1 /* Lines */:
                            webGL.drawArrays(webGL.LINES, bufferOffset, vertexAccessor.count);
                            break;
                        case 2 /* LineLoop */:
                            webGL.drawArrays(webGL.LINE_LOOP, bufferOffset, vertexAccessor.count);
                            break;
                        case 3 /* LineStrip */:
                            webGL.drawArrays(webGL.LINE_STRIP, bufferOffset, vertexAccessor.count);
                            break;
                        case 4 /* Triangles */:
                        default:
                            webGL.drawArrays(webGL.TRIANGLES, bufferOffset, vertexAccessor.count);
                            break;
                    }
                }
            }
        };
        WebGLKit.resetState = function () {
            this._activeTextureIndex = -1;
            this._showFace = undefined;
            this._zWrite = undefined;
            this._zTest = undefined;
            this._zTestMethod = undefined;
            this._blend = undefined;
            this._program = undefined;
            // ...
        };
        WebGLKit.init = function (canvas, options) {
            var webgl = canvas.getContext('webgl', options) ||
                canvas.getContext("experimental-webgl", options);
            if (WebGLKit._texNumber == null) {
                this.webgl = webgl;
                WebGLKit._texNumber = [];
                WebGLKit._texNumber.push(webgl.TEXTURE0);
                WebGLKit._texNumber.push(webgl.TEXTURE1);
                WebGLKit._texNumber.push(webgl.TEXTURE2);
                WebGLKit._texNumber.push(webgl.TEXTURE3);
                WebGLKit._texNumber.push(webgl.TEXTURE4);
                WebGLKit._texNumber.push(webgl.TEXTURE5);
                WebGLKit._texNumber.push(webgl.TEXTURE6);
                WebGLKit._texNumber.push(webgl.TEXTURE7);
                WebGLKit._texNumber.push(webgl.TEXTURE8);
                WebGLKit._texNumber.push(webgl.TEXTURE9);
                WebGLKit.LEQUAL = webgl.LEQUAL;
                WebGLKit.NEVER = webgl.NEVER;
                WebGLKit.EQUAL = webgl.EQUAL;
                WebGLKit.GEQUAL = webgl.GEQUAL;
                WebGLKit.NOTEQUAL = webgl.NOTEQUAL;
                WebGLKit.LESS = webgl.LESS;
                WebGLKit.GREATER = webgl.GREATER;
                WebGLKit.ALWAYS = webgl.ALWAYS;
                WebGLKit.FUNC_ADD = webgl.FUNC_ADD;
                WebGLKit.FUNC_SUBTRACT = webgl.FUNC_SUBTRACT;
                WebGLKit.FUNC_REVERSE_SUBTRACT = webgl.FUNC_REVERSE_SUBTRACT;
                WebGLKit.ONE = webgl.ONE;
                WebGLKit.ZERO = webgl.ZERO;
                WebGLKit.SRC_ALPHA = webgl.SRC_ALPHA;
                WebGLKit.SRC_COLOR = webgl.SRC_COLOR;
                WebGLKit.ONE_MINUS_SRC_ALPHA = webgl.ONE_MINUS_SRC_ALPHA;
                WebGLKit.ONE_MINUS_SRC_COLOR = webgl.ONE_MINUS_SRC_COLOR;
                WebGLKit.ONE_MINUS_DST_ALPHA = webgl.ONE_MINUS_DST_ALPHA;
                WebGLKit.ONE_MINUS_DST_COLOR = webgl.ONE_MINUS_DST_COLOR;
                this.capabilities.initialize(webgl);
            }
        };
        WebGLKit._texNumber = null;
        WebGLKit._activeTextureIndex = -1;
        WebGLKit._frontFaceCW = false;
        WebGLKit.capabilities = new egret3d.WebGLCapabilities();
        return WebGLKit;
    }());
    egret3d.WebGLKit = WebGLKit;
    __reflect(WebGLKit.prototype, "egret3d.WebGLKit");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    //最大允许合并的顶点数，超过就是下一批次
    egret3d.MAX_VERTEX_COUNT_PER_BUFFER = 50000;
    //
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpInverseMatrix = new egret3d.Matrix();
    //缓存已经校验过的对象，用于过滤
    var cacheInstances = [];
    var beforeCombineCount = 0;
    /**
     * 尝试对场景内所有静态对象合并
     */
    function autoCombine(scene) {
        combine(scene.gameObjects);
    }
    egret3d.autoCombine = autoCombine;
    /**
     * 尝试合并静态对象列表。
     * @param instances
     * @param root
     */
    function combine(instances) {
        cacheInstances.length = 0;
        beforeCombineCount = 0;
        var allCombines = {};
        //1.通过材质填充合并列表
        for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
            var obj = instances_1[_i];
            _colletCombineInstance(obj, allCombines);
        }
        console.log("合并前:" + beforeCombineCount);
        var afterCombineCount = 0;
        //2.相同材质的合并
        for (var key in allCombines) {
            var combines = allCombines[key];
            for (var _a = 0, combines_1 = combines; _a < combines_1.length; _a++) {
                var combine_1 = combines_1[_a];
                _combineInstance(combine_1);
                afterCombineCount++;
            }
        }
        console.log("合并后:" + afterCombineCount + "节省:" + (beforeCombineCount - afterCombineCount));
        cacheInstances.length = 0;
    }
    egret3d.combine = combine;
    /**
     * TODO(root暂时不支持)尝试合并静态对象列表，如果root有值，合并后可以操作root对象的transform，来实现整体移动，旋转，缩放；反之，相同材质列表的第一个对象为合并节点。
     * @param instances
     * @param root
     */
    function _colletCombineInstance(target, out, root) {
        //过滤重复的对象
        if (cacheInstances.indexOf(target.uuid) >= 0) {
            return;
        }
        cacheInstances.push(target.uuid);
        //
        for (var _i = 0, _a = target.transform.children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child) {
                _colletCombineInstance(child.gameObject, out, root);
            }
        }
        //不是静态的不考虑合并
        if (!target.isStatic) {
            return;
        }
        var meshFilter = target.getComponent(egret3d.MeshFilter);
        var meshRenderer = target.getComponent(egret3d.MeshRenderer);
        //合并条件判断
        if (!meshFilter || !meshFilter.mesh || !meshRenderer || !meshRenderer.materials || meshRenderer.materials.length < 1) {
            return;
        }
        beforeCombineCount++;
        var materials = meshRenderer.materials;
        var meshData = meshFilter.mesh;
        //合并筛选的条件:光照贴图_材质0_材质1... ：0_234_532...
        var key = meshRenderer.lightmapIndex + "_";
        materials.forEach(function (element) { key = key + "_" + element.uuid; });
        if (!out[key]) {
            out[key] = [];
            out[key].push(new CombineInstance());
        }
        var combines = out[key];
        //找相同材质合成列表的最后一个，如果最后一个顶点超过允许最大数了，就新建一个，下个批次处理
        var combine = combines[combines.length - 1];
        if (combine.vertexCount + meshData.vertexCount > egret3d.MAX_VERTEX_COUNT_PER_BUFFER) {
            combine = new CombineInstance();
            out[key].push(combine);
        }
        //合并节点以传入的对象为优先，如果没有传入，那么以每种材质的第一个对象为准
        if (!combine.root) {
            combine.root = root ? root : target;
            combine.lightmapIndex = meshRenderer.lightmapIndex;
            combine.lightmapScaleOffset = meshRenderer.lightmapScaleOffset;
        }
        //适配最大格式
        var glTFAsset = meshData.glTFAsset;
        var primitives = meshData.glTFMesh.primitives;
        for (var i = 0; i < primitives.length; i++) {
            var primitive = primitives[i];
            for (var attStr in primitives[i].attributes) {
                var attrType = attStr;
                if (!combine.meshAttribute[attrType]) {
                    combine.vertexBufferSize += egret3d.GLTFAsset.getAccessorTypeCount(glTFAsset.getAccessor(primitive.attributes[attStr]).type);
                }
                combine.meshAttribute[attrType] = attrType;
            }
            combine.indexBufferTotalSize += glTFAsset.getBufferLength(glTFAsset.getAccessor(primitive.indices)) / Uint16Array.BYTES_PER_ELEMENT;
        }
        //
        combine.vertexCount += meshData.vertexCount;
        combine.instances.push(target);
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     */
    function _combineInstance(combineInstance) {
        var combineMesh = _combineMesh(combineInstance);
        var combineRoot = combineInstance.root;
        //把合成好的放入root中，重新绘制
        if (combineRoot) {
            var meshFilter = combineRoot.getComponent(egret3d.MeshFilter);
            meshFilter.mesh = combineMesh;
        }
        // for(const instance of combineInstance.instances){
        //     const meshFilter = instance.getComponent(MeshFilter);
        //     meshFilter.mesh = combineMesh;
        // }
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     * @param root
     */
    function _combineMesh(combineInstance) {
        //
        egret3d.Matrix.inverse(combineInstance.root.transform.getWorldMatrix(), helpInverseMatrix);
        var meshAttribute = combineInstance.meshAttribute;
        var lightmapScaleOffset = combineInstance.lightmapScaleOffset;
        var newAttribute = [];
        var tempIndexBuffers = [];
        var tempVertexBuffers = {};
        for (var key in meshAttribute) {
            tempVertexBuffers[key] = [];
            newAttribute.push(key);
        }
        //
        var startIndex = 0;
        var endIndex = 0;
        for (var _i = 0, _a = combineInstance.instances; _i < _a.length; _i++) {
            var instance = _a[_i];
            var meshFilter = instance.getComponent(egret3d.MeshFilter);
            var meshRenderer = instance.getComponent(egret3d.MeshRenderer);
            var worldMatrix = instance.transform.getWorldMatrix();
            var orginLightmapScaleOffset = meshRenderer.lightmapScaleOffset;
            var mesh = meshFilter.mesh;
            var glTFAsset = mesh.glTFAsset;
            var primitives = mesh.glTFMesh.primitives;
            var isSharedBuffer = mesh.isSharedBuffer;
            //共享一个的buffer，vbo只处理一个submesh就可以了
            var combineOnce = true;
            for (var i = 0; i < primitives.length; i++) {
                var primitive = primitives[i];
                if (combineOnce) {
                    combineOnce = !isSharedBuffer;
                    var orginVertexCount = mesh.getVertexCount(i);
                    var orginAttributes = primitives[i].attributes;
                    var positionBuffer = glTFAsset.createTypeArrayFromAccessor(glTFAsset.getAccessor(orginAttributes.POSITION));
                    //vertexBuffers
                    for (var j = 0; j < positionBuffer.length; j += 3) {
                        helpVec3_1.x = positionBuffer[j + 0];
                        helpVec3_1.y = positionBuffer[j + 1];
                        helpVec3_1.z = positionBuffer[j + 2];
                        //转换成世界坐标后在转换为合并节点的本地坐标
                        egret3d.Matrix.transformVector3(helpVec3_1, worldMatrix, helpVec3_2);
                        egret3d.Matrix.transformVector3(helpVec3_2, helpInverseMatrix, helpVec3_1);
                        //
                        tempVertexBuffers["POSITION" /* POSITION */].push(helpVec3_1.x, helpVec3_1.y, helpVec3_1.z);
                    }
                    //
                    if (meshAttribute["NORMAL" /* NORMAL */]) {
                        if (orginAttributes.NORMAL) {
                            var normalBuffer = glTFAsset.createTypeArrayFromAccessor(glTFAsset.getAccessor(orginAttributes.NORMAL));
                            var target = tempVertexBuffers["NORMAL" /* NORMAL */];
                            var count = normalBuffer.length;
                            var startIndex_1 = target.length;
                            target.length += count;
                            for (var j = 0; j < count; j += 3) {
                                helpVec3_1.x = normalBuffer[j + 0];
                                helpVec3_1.y = normalBuffer[j + 1];
                                helpVec3_1.z = normalBuffer[j + 2];
                                worldMatrix.transformNormal(helpVec3_1);
                                helpInverseMatrix.transformNormal(helpVec3_1);
                                helpVec3_1.normalize();
                                target[startIndex_1 + j] = helpVec3_1.x;
                                target[startIndex_1 + j + 1] = helpVec3_1.y;
                                target[startIndex_1 + j + 2] = helpVec3_1.z;
                            }
                            // _copyAccessorBufferArray(glTFAsset, orginAttributes.NORMAL, tempVertexBuffers[gltf.MeshAttributeType.NORMAL]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["NORMAL" /* NORMAL */], orginVertexCount, [0, 0, 0]);
                        }
                    }
                    if (meshAttribute["TANGENT" /* TANGENT */]) {
                        if (orginAttributes.TANGENT) {
                            var tangentBuffer = glTFAsset.createTypeArrayFromAccessor(glTFAsset.getAccessor(orginAttributes.TANGENT));
                            var target = tempVertexBuffers["TANGENT" /* TANGENT */];
                            var count = tangentBuffer.length;
                            var startIndex_2 = target.length;
                            target.length += count;
                            for (var j = 0; j < count; j += 4) {
                                helpVec3_1.x = tangentBuffer[j + 0];
                                helpVec3_1.y = tangentBuffer[j + 1];
                                helpVec3_1.z = tangentBuffer[j + 2];
                                worldMatrix.transformNormal(helpVec3_1);
                                helpInverseMatrix.transformNormal(helpVec3_1);
                                helpVec3_1.normalize();
                                target[startIndex_2 + j] = helpVec3_1.x;
                                target[startIndex_2 + j + 1] = helpVec3_1.y;
                                target[startIndex_2 + j + 2] = helpVec3_1.z;
                                target[startIndex_2 + j + 3] = tangentBuffer[j + 3];
                            }
                            // _copyAccessorBufferArray(glTFAsset, orginAttributes.TANGENT, tempVertexBuffers[gltf.MeshAttributeType.TANGENT]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["TANGENT" /* TANGENT */], orginVertexCount, [0, 0, 0, 1]);
                        }
                    }
                    if (meshAttribute["COLOR_0" /* COLOR_0 */]) {
                        if (orginAttributes.COLOR_0) {
                            _copyAccessorBufferArray(glTFAsset, orginAttributes.COLOR_0, tempVertexBuffers["COLOR_0" /* COLOR_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["COLOR_0" /* COLOR_0 */], orginVertexCount, [1, 1, 1, 1]);
                        }
                    }
                    if (meshAttribute["TEXCOORD_0" /* TEXCOORD_0 */]) {
                        if (orginAttributes.TEXCOORD_0) {
                            _copyAccessorBufferArray(glTFAsset, orginAttributes.TEXCOORD_0, tempVertexBuffers["TEXCOORD_0" /* TEXCOORD_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["TEXCOORD_0" /* TEXCOORD_0 */], orginVertexCount, [0, 0]);
                        }
                    }
                    if (meshAttribute["TEXCOORD_1" /* TEXCOORD_1 */]) {
                        if (combineInstance.lightmapIndex >= 0) {
                            //如果有lightmap,那么将被合并的uv1的坐标转换为root下的坐标,有可能uv1没有，那用uv0来算
                            var uvBuffer = orginAttributes.TEXCOORD_1 ?
                                glTFAsset.createTypeArrayFromAccessor(glTFAsset.getAccessor(orginAttributes.TEXCOORD_1)) :
                                glTFAsset.createTypeArrayFromAccessor(glTFAsset.getAccessor(orginAttributes.TEXCOORD_0));
                            //
                            for (var j = 0; j < uvBuffer.length; j += 2) {
                                var u = uvBuffer[j + 0];
                                var v = uvBuffer[j + 1];
                                u = ((u * orginLightmapScaleOffset[0] + orginLightmapScaleOffset[2]) - lightmapScaleOffset[2]) / lightmapScaleOffset[0];
                                v = ((v * orginLightmapScaleOffset[1] - orginLightmapScaleOffset[1] - orginLightmapScaleOffset[3]) + lightmapScaleOffset[3] + lightmapScaleOffset[1]) / lightmapScaleOffset[1];
                                tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */].push(u, v);
                            }
                        }
                        else {
                            if (orginAttributes.TEXCOORD_1) {
                                _copyAccessorBufferArray(glTFAsset, orginAttributes.TEXCOORD_1, tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */]);
                            }
                            else {
                                _fillDefaultArray(tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */], orginVertexCount, [0, 0]);
                            }
                        }
                    }
                    if (meshAttribute["JOINTS_0" /* JOINTS_0 */]) {
                        if (orginAttributes.JOINTS_0) {
                            _copyAccessorBufferArray(glTFAsset, orginAttributes.JOINTS_0, tempVertexBuffers["JOINTS_0" /* JOINTS_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["JOINTS_0" /* JOINTS_0 */], orginVertexCount, [0, 0, 0, 0]);
                        }
                    }
                    if (meshAttribute["WEIGHTS_0" /* WEIGHTS_0 */]) {
                        if (orginAttributes.WEIGHTS_0) {
                            _copyAccessorBufferArray(glTFAsset, orginAttributes.WEIGHTS_0, tempVertexBuffers["WEIGHTS_0" /* WEIGHTS_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["WEIGHTS_0" /* WEIGHTS_0 */], orginVertexCount, [1, 0, 0, 0]);
                        }
                    }
                    if (meshAttribute["COLOR_1" /* COLOR_1 */]) {
                        if (orginAttributes.COLOR_1) {
                            _copyAccessorBufferArray(glTFAsset, orginAttributes.COLOR_1, tempVertexBuffers["COLOR_1" /* COLOR_1 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["COLOR_1" /* COLOR_1 */], orginVertexCount, [1, 1, 1, 1]);
                        }
                    }
                }
                var subIndexBuffer = glTFAsset.createTypeArrayFromAccessor(glTFAsset.getAccessor(primitive.indices));
                // //indexBuffers
                if (!tempIndexBuffers[i]) {
                    tempIndexBuffers[i] = [];
                }
                for (var j = 0; j < subIndexBuffer.length; j++) {
                    var index = subIndexBuffer[j] + startIndex;
                    tempIndexBuffers[i].push(index);
                    endIndex = index > endIndex ? index : endIndex;
                }
            }
            startIndex = endIndex + 1;
            meshFilter.mesh = null;
        }
        var newVertexBuffers = new Float32Array(combineInstance.vertexBufferSize * combineInstance.vertexCount);
        var newIndexBuffers = new Uint16Array(combineInstance.indexBufferTotalSize);
        var iv = 0;
        for (var key in tempVertexBuffers) {
            var arr = tempVertexBuffers[key];
            for (var _b = 0, arr_1 = arr; _b < arr_1.length; _b++) {
                var v = arr_1[_b];
                newVertexBuffers[iv++] = v;
            }
        }
        var ii = 0;
        for (var key in tempIndexBuffers) {
            var arr = tempIndexBuffers[key];
            for (var _c = 0, arr_2 = arr; _c < arr_2.length; _c++) {
                var v = arr_2[_c];
                newIndexBuffers[ii++] = v;
            }
        }
        var combineMesh = new egret3d.Mesh(newVertexBuffers, newIndexBuffers, tempIndexBuffers[0].length, newAttribute, 1 /* Static */);
        var indicesCount = 0;
        for (var i = 0; i < tempIndexBuffers.length; i++) {
            var subLen = tempIndexBuffers[i].length;
            if (i > 0) {
                //第一个submesh在构造函数中已经添加，需要手动添加后续的
                combineMesh.addSubMesh(indicesCount, subLen, i);
                combineMesh.uploadSubIndexBuffer(i);
            }
            indicesCount += subLen;
        }
        return combineMesh;
    }
    function _copyAccessorBufferArray(gltf, accessor, target) {
        var buffer = gltf.createTypeArrayFromAccessor(gltf.getAccessor(accessor));
        var count = buffer.length;
        var startIndex = target.length;
        target.length += count;
        for (var i = 0; i < count; i++) {
            target[startIndex + i] = buffer[i];
        }
    }
    function _fillDefaultArray(target, count, defaultValue) {
        var startIndex = target.length;
        var defaultValueCount = defaultValue.length;
        target.length += count * defaultValueCount;
        for (var i = 0; i < count; i++) {
            for (var j = 0; j < defaultValueCount; j++) {
                target[startIndex++] = defaultValue[j];
            }
        }
    }
    var CombineInstance = (function () {
        function CombineInstance() {
            this.vertexCount = 0;
            this.vertexBufferSize = 0;
            this.indexBufferTotalSize = 0;
            this.lightmapIndex = -1;
            this.meshAttribute = {};
            this.root = null;
            this.lightmapScaleOffset = null;
            this.instances = [];
        }
        return CombineInstance;
    }());
    __reflect(CombineInstance.prototype, "CombineInstance");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Performance
     * 数据收集
     */
    var Performance = (function () {
        function Performance() {
        }
        Performance.getEntity = function (key) {
            return this._entities[key];
        };
        Performance.getFPS = function () {
            var entity = this.getEntity("fps");
            return (entity && entity.averageDelta) ? Math.floor(1000 / entity.averageDelta) : 0;
        };
        Performance.updateFPS = function () {
            if (!this.enable) {
                return;
            }
            this.endCounter("fps");
            this.startCounter("fps", 60);
        };
        Performance._getNow = function () {
            if (window.performance) {
                return window.performance.now();
            }
            return new Date().getTime();
        };
        Performance.startCounter = function (key, averageRange) {
            if (averageRange === void 0) { averageRange = 1; }
            if (!this.enable) {
                return;
            }
            var entity = this._entities[key];
            if (!entity) {
                entity = {
                    start: 0,
                    end: 0,
                    delta: 0,
                    _cache: [],
                    averageRange: 1,
                    averageDelta: 0
                };
                this._entities[key] = entity;
            }
            entity.start = this._getNow();
            entity.averageRange = averageRange;
        };
        Performance.endCounter = function (key) {
            if (!this.enable) {
                return;
            }
            var entity = this._entities[key];
            if (entity) {
                entity.end = this._getNow();
                entity.delta = entity.end - entity.start;
                if (entity.averageRange > 1) {
                    entity._cache.push(entity.delta);
                    var length = entity._cache.length;
                    if (length >= entity.averageRange) {
                        if (length > entity.averageRange) {
                            entity._cache.shift();
                            length--;
                        }
                        var sum = 0;
                        for (var i = 0; i < length; i++) {
                            sum += entity._cache[i];
                        }
                        entity.averageDelta = sum / length;
                    }
                }
            }
        };
        Performance._entities = {};
        Performance.enable = false;
        return Performance;
    }());
    egret3d.Performance = Performance;
    __reflect(Performance.prototype, "egret3d.Performance");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Profile = (function () {
        function Profile() {
        }
        Profile._getNow = function () {
            // if (window.performance) {
            //     return window.performance.now();
            // }
            // return Date.now() * 0.001;
            return new Date().getTime();
        };
        Profile._print = function (list) {
            var totalTime = 0.0;
            for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
                var item = list_1[_i];
                totalTime += item.time;
            }
            console.log("------------------------");
            for (var _a = 0, list_2 = list; _a < list_2.length; _a++) {
                var item = list_2[_a];
                console.log(item.key + ":用时" + item.time + "平均:" + (item.time / item.count) + "最大值:" + item.maxTime + " 权重:" + (Math.round(item.time / totalTime * 100)) + "%");
            }
        };
        Profile.clear = function () {
            this.profileList.keys.length = 0;
            this.profileList.values.length = 0;
        };
        Profile.startTime = function (key, group) {
            if (group === void 0) { group = 0; }
            if (!this.debug) {
                return;
            }
            var index = this.profileList.keys.indexOf(key);
            if (index < 0) {
                this.profileList.keys.push(key);
                index = this.profileList.values.length;
                this.profileList.values.push({ key: key, count: 0, startTime: 0, time: 0, group: group, maxTime: 0 });
            }
            var item = this.profileList.values[index];
            item.count++;
            item.startTime = this._getNow();
        };
        Profile.endTime = function (key) {
            if (!this.debug) {
                return;
            }
            var index = this.profileList.keys.indexOf(key);
            if (index < 0) {
                console.log("invalid key error.", this);
            }
            else {
                var item = this.profileList.values[index];
                var d = this._getNow() - item.startTime;
                item.time += d;
                item.maxTime = item.maxTime > d ? item.maxTime : d;
            }
        };
        Profile.printAll = function () {
            if (!this.debug) {
                return;
            }
            var groups = {};
            for (var _i = 0, _a = this.profileList.values; _i < _a.length; _i++) {
                var item = _a[_i];
                if (!groups[item.group]) {
                    groups[item.group] = [];
                }
                groups[item.group].push(item);
            }
            for (var key in groups) {
                this._print(groups[key]);
            }
        };
        Profile.print = function (group) {
            if (group === void 0) { group = 0; }
            if (!this.debug) {
                return;
            }
            var list = [];
            for (var _i = 0, _a = this.profileList.values; _i < _a.length; _i++) {
                var item = _a[_i];
                if (item.group === group) {
                    list.push(item);
                }
            }
            this._print(list);
        };
        Profile.test = function () {
            var list0 = [];
            var map = {};
            for (var i = 0; i < 1000; i++) {
                list0.push(i);
                map[i] = i;
            }
            var old = this._getNow();
            for (var _i = 0, list0_1 = list0; _i < list0_1.length; _i++) {
                var i = list0_1[_i];
                console.log("list:");
            }
            console.log("list of用时:" + (this._getNow() - old));
            old = this._getNow();
            for (var i in list0) {
                console.log("list:");
            }
            console.log("list in用时:" + (this._getNow() - old));
            old = this._getNow();
            for (var key in map) {
                console.log("map:");
            }
            console.log("map用时:" + (this._getNow() - old));
        };
        Profile.debug = false;
        Profile.profileList = { keys: [], values: [] };
        return Profile;
    }());
    egret3d.Profile = Profile;
    __reflect(Profile.prototype, "egret3d.Profile");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _attributeInfos = {
        "_glesVertex": { name: "POSITION" /* POSITION */, normalized: false },
        "_glesNormal": { name: "NORMAL" /* NORMAL */, normalized: true },
        "_glesTangent": { name: "TANGENT" /* TANGENT */, normalized: true },
        "_glesMultiTexCoord0": { name: "TEXCOORD_0" /* TEXCOORD_0 */, normalized: false },
        "_glesMultiTexCoord1": { name: "TEXCOORD_1" /* TEXCOORD_1 */, normalized: false },
        "_glesColor": { name: "COLOR_0" /* COLOR_0 */, normalized: false },
        "_glesColorEx": { name: "COLOR_1" /* COLOR_1 */, normalized: false },
        "_glesBlendIndex4": { name: "JOINTS_0" /* JOINTS_0 */, normalized: false },
        "_glesBlendWeight4": { name: "WEIGHTS_0" /* WEIGHTS_0 */, normalized: false },
        "_glesCorner": { name: "CORNER" /* CORNER */, normalized: false },
        "_startPosition": { name: "START_POSITION" /* START_POSITION */, normalized: false },
        "_startVelocity": { name: "START_VELOCITY" /* START_VELOCITY */, normalized: false },
        "_startColor": { name: "START_COLOR" /* START_COLOR */, normalized: false },
        "_startSize": { name: "START_SIZE" /* START_SIZE */, normalized: false },
        "_startRotation": { name: "START_ROTATION" /* START_ROTATION */, normalized: false },
        "_time": { name: "TIME" /* TIME */, normalized: false },
        "_random0": { name: "RANDOM0" /* RANDOM0 */, normalized: false },
        "_random1": { name: "RANDOM1" /* RANDOM1 */, normalized: false },
        "_startWorldPosition": { name: "WORLD_POSITION" /* WORLD_POSITION */, normalized: false },
        "_startWorldRotation": { name: "WORLD_ROTATION" /* WORLD_ROTATION */, normalized: false },
    };
    var _uniformsKeyConvert = {
        "u_velocityCurveX[0]": "u_velocityCurveX",
        "u_velocityCurveY[0]": "u_velocityCurveY",
        "u_velocityCurveZ[0]": "u_velocityCurveZ",
        "u_velocityCurveMaxX[0]": "u_velocityCurveMaxX",
        "u_velocityCurveMaxY[0]": "u_velocityCurveMaxY",
        "u_velocityCurveMaxZ[0]": "u_velocityCurveMaxZ",
        "u_alphaGradient[0]": "u_alphaGradient",
        "u_colorGradient[0]": "u_colorGradient",
        "u_alphaGradientMax[0]": "u_alphaGradientMax",
        "u_colorGradientMax[0]": "u_colorGradientMax",
        "u_sizeCurve[0]": "u_sizeCurve",
        "u_sizeCurveMax[0]": "u_sizeCurveMax",
        "u_sizeCurveX[0]": "u_sizeCurveX",
        "u_sizeCurveY[0]": "u_sizeCurveY",
        "u_sizeCurveZ[0]": "u_sizeCurveZ",
        "u_sizeCurveMaxX[0]": "u_sizeCurveMaxX",
        "u_sizeCurveMaxY[0]": "u_sizeCurveMaxY",
        "u_sizeCurveMaxZ[0]": "u_sizeCurveMaxZ",
        "u_rotationCurve[0]": "u_rotationCurve",
        "u_rotationCurveMax[0]": "u_rotationCurveMax",
        "u_rotationCurveX[0]": "u_rotationCurveX",
        "u_rotationCurveY[0]": "u_rotationCurveY",
        "u_rotationCurveZ[0]": "u_rotationCurveZ",
        "u_rotationCurveW[0]": "u_rotationCurveW",
        "u_rotationCurveMaxX[0]": "u_rotationCurveMaxX",
        "u_rotationCurveMaxY[0]": "u_rotationCurveMaxY",
        "u_rotationCurveMaxZ[0]": "u_rotationCurveMaxZ",
        "u_rotationCurveMaxW[0]": "u_rotationCurveMaxW",
        "u_uvCurve[0]": "u_uvCurve",
        "u_uvCurveMax[0]": "u_uvCurveMax",
    };
    var _vsShaderMap = {};
    var _fsShaderMap = {};
    var parseIncludes = function (string) {
        var pattern = /#include +<([\w\d.]+)>/g;
        function replace(match, include) {
            var replace = egret3d.ShaderChunk[include];
            if (replace === undefined) {
                throw new Error('Can not resolve #include <' + include + '>');
            }
            return parseIncludes(replace);
        }
        return string.replace(pattern, replace);
    };
    var constDefines;
    function createConstDefines() {
        var defines = "precision " + egret3d.WebGLKit.capabilities.maxPrecision + " float; \n";
        defines += "precision " + egret3d.WebGLKit.capabilities.maxPrecision + " int; \n";
        defines += '#define PI 3.14159265359 \n';
        defines += '#define EPSILON 1e-6 \n';
        defines += 'float pow2( const in float x ) { return x*x; } \n';
        defines += '#define LOG2 1.442695 \n';
        defines += '#define RECIPROCAL_PI 0.31830988618 \n';
        defines += '#define saturate(a) clamp( a, 0.0, 1.0 ) \n';
        defines += '#define whiteCompliment(a) ( 1.0 - saturate( a ) ) \n';
        // defines += '#extension GL_OES_standard_derivatives : enable \n';
        return defines;
    }
    function buildDefines(context, material) {
        var defines = "";
        if (context.lightCount > 0) {
            defines += "#define USE_LIGHT " + context.lightCount + "\n";
            if (context.directLightCount > 0) {
                defines += "#define USE_DIRECT_LIGHT " + context.directLightCount + "\n";
            }
            if (context.pointLightCount > 0) {
                defines += "#define USE_POINT_LIGHT " + context.pointLightCount + "\n";
            }
            if (context.spotLightCount > 0) {
                defines += "#define USE_SPOT_LIGHT " + context.spotLightCount + "\n";
            }
            if (context.drawCall.renderer.receiveShadows) {
                defines += "#define USE_SHADOW \n";
                defines += "#define USE_PCF_SOFT_SHADOW \n";
            }
        }
        //自定义的宏定义TODO
        defines += material.shaderDefine;
        return defines;
    }
    function getWebGLShader(type, gl, info, defines) {
        var shader = gl.createShader(type);
        if (!constDefines) {
            constDefines = createConstDefines();
        }
        gl.shaderSource(shader, constDefines + defines + parseIncludes(info.src));
        gl.compileShader(shader);
        var parameter = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!parameter) {
            if (confirm("shader compile:" + info.name + " " + type + " error! ->" + gl.getShaderInfoLog(shader) + "\n" + ". did you want see the code?")) {
                gl.deleteShader(shader);
                alert(info.src);
            }
            return null;
        }
        return shader;
    }
    function getWebGLProgram(gl, vs, fs, defines) {
        var program = gl.createProgram();
        var key;
        key = vs.name + defines;
        var vertexShader = _vsShaderMap[key];
        if (!vertexShader) {
            var key_1 = vs.name + defines;
            vertexShader = getWebGLShader(gl.VERTEX_SHADER, gl, vs, defines);
            _vsShaderMap[key_1] = vertexShader;
        }
        key = fs.name + defines;
        var fragmentShader = _fsShaderMap[key];
        if (!fragmentShader) {
            var key_2 = fs.name + defines;
            fragmentShader = getWebGLShader(gl.FRAGMENT_SHADER, gl, fs, defines);
            _fsShaderMap[key_2] = fragmentShader;
        }
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        var parameter = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!parameter) {
            alert("program compile: " + vs.name + "_" + fs.name + " error! ->" + gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }
    /**
     * extract attributes
     */
    function extractAttributes(gl, program) {
        var attributes = {};
        var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < totalAttributes; i++) {
            var attribData = gl.getActiveAttrib(program, i);
            var name = attribData.name;
            var attribute = new egret3d.WebGLAttribute(gl, program, attribData);
            attributes[name] = attribute;
        }
        return attributes;
    }
    /**
     * extract uniforms
     */
    function extractUniforms(gl, program) {
        var uniforms = {};
        var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i < totalUniforms; i++) {
            var uniformData = gl.getActiveUniform(program, i);
            var name = _uniformsKeyConvert[uniformData.name] ? _uniformsKeyConvert[uniformData.name] : uniformData.name;
            var uniform = new egret3d.WebGLUniform(gl, program, uniformData);
            uniforms[name] = uniform;
        }
        return uniforms;
    }
    /**
     *
     * WebGLProgram的包装类，可以批量上传数据并具有标脏功能
     */
    var GlProgram = (function () {
        function GlProgram(gl, vShaderInfo, fShaderInfo, defines) {
            this._cacheContextVer = -1;
            this._cacheMeshVer = -1;
            this._cacheMeshEbo = -1;
            this._cacheMaterialVer = -1;
            this._samplerUnitMap = {};
            this._cacheTextureUniforms = [];
            this.gl = gl;
            var program = getWebGLProgram(gl, vShaderInfo, fShaderInfo, defines);
            this.program = program;
            this._attributes = extractAttributes(gl, program);
            this._uniforms = extractUniforms(gl, program);
            this._allocTexUnits();
        }
        GlProgram.get = function (pass, context, material) {
            var defines = buildDefines(context, material);
            var name = pass.vShaderInfo.name + "_" + pass.fShaderInfo.name + "_" + defines;
            if (!this._programMap[name]) {
                this._programMap[name] = new GlProgram(egret3d.WebGLKit.webgl, pass.vShaderInfo, pass.fShaderInfo, defines);
            }
            return this._programMap[name];
        };
        GlProgram.prototype._allocTexUnits = function () {
            var _this = this;
            // sampler数组中使用unit0会导致错误？
            var samplerArrayKeys = [];
            var samplerKeys = [];
            for (var key in this._uniforms) {
                if (this._uniforms[key].type == egret3d.WEBGL_UNIFORM_TYPE.SAMPLER_2D || this._uniforms[key].type == egret3d.WEBGL_UNIFORM_TYPE.SAMPLER_CUBE) {
                    if (key.indexOf("[") > -1) {
                        samplerArrayKeys.push(key);
                    }
                    else {
                        samplerKeys.push(key);
                    }
                }
            }
            var allKeys = samplerKeys.concat(samplerArrayKeys);
            var unitNumber = 0;
            allKeys.forEach(function (key) {
                _this._samplerUnitMap[key] = unitNumber;
                unitNumber++;
            });
        };
        GlProgram.prototype.bindAttributes = function (mesh, subMeshIndex, forceUpdate) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (forceUpdate === void 0) { forceUpdate = false; }
            if (!forceUpdate && this._cacheMesh == mesh && this._cacheMeshVer == mesh._version && this._cacheMeshEbo == subMeshIndex) {
                return;
            }
            // MD mesh
            // this._cacheMesh = mesh;
            // this._cacheMeshVer = mesh._version;
            // this._cacheMeshEbo = subMeshIndex;
            // let gl = this.gl;
            // gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo);
            // if (bindEbo >= 0) {
            //     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.ibos[bindEbo]);
            // }
            // let meshVertexFormat = mesh.vertexFormatData;
            // let info: { size: number, normalized: boolean, stride: number, offset: number }, attribute: WebGLAttribute;
            // for (let key in this._attributes) {
            //     attribute = this._attributes[key];
            //     info = meshVertexFormat[key];
            //     if (info) {
            //         if (attribute.count !== info.size) {
            //             // console.warn("Renderer: attribute " + name + " size not match! attribute-count:" + attribute.count + ", info-size:" + info.size);
            //         }
            //         gl.vertexAttribPointer(attribute.location, info.size, attribute.format, info.normalized, info.stride, info.offset);
            //         gl.enableVertexAttribArray(attribute.location);
            //     } else {
            //         gl.disableVertexAttribArray(attribute.location);
            //     }
            // }
            if (0 <= subMeshIndex && subMeshIndex < mesh.glTFMesh.primitives.length) {
                this._cacheMesh = mesh;
                this._cacheMeshVer = mesh._version;
                this._cacheMeshEbo = subMeshIndex;
                var gl = this.gl;
                var glTFAsset = mesh.glTFAsset;
                var primitive = mesh.glTFMesh.primitives[subMeshIndex];
                var ibo = mesh.ibos[subMeshIndex];
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo);
                if (ibo) {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
                }
                for (var k in this._attributes) {
                    var webGLAttribute = this._attributes[k];
                    var location_1 = webGLAttribute.location;
                    var name_2 = webGLAttribute.name;
                    var attributeInfo = _attributeInfos[name_2];
                    var accessorIndex = primitive.attributes[attributeInfo.name];
                    if (accessorIndex !== undefined) {
                        var accessor = glTFAsset.getAccessor(accessorIndex);
                        var bufferOffset = glTFAsset.getBufferOffset(accessor);
                        var typeCount = egret3d.GLTFAsset.getAccessorTypeCount(accessor.type);
                        gl.vertexAttribPointer(location_1, typeCount, webGLAttribute.format, attributeInfo.normalized, 0, bufferOffset);
                        gl.enableVertexAttribArray(location_1);
                    }
                    else {
                        gl.disableVertexAttribArray(location_1);
                    }
                }
            }
            else {
                console.warn("Error arguments.");
            }
        };
        GlProgram.prototype._updateRenderContextUniforms = function (context) {
            for (var key in this._uniforms) {
                switch (key) {
                    case "glstate_matrix_model":
                        this.setMatrix4(key, context.matrix_m);
                        break;
                    case "glstate_matrix_mvp":
                        this.setMatrix4(key, context.matrix_mvp);
                        break;
                    case "glstate_matrix_vp":
                        this.setMatrix4(key, context.matrix_vp);
                        break;
                    case "glstate_cameraPos":
                        this.setVector3(key, context.cameraPosition);
                        break;
                    case "glstate_cameraForward":
                        this.setVector3(key, context.cameraForward);
                        break;
                    case "glstate_cameraUp":
                        this.setVector3(key, context.cameraUp);
                        break;
                    case "glstate_directLights[0]":
                        if (context.directLightCount > 0) {
                            this.setFloatv(key, context.directLightArray);
                        }
                        break;
                    case "glstate_pointLights[0]":
                        if (context.pointLightCount > 0) {
                            this.setFloatv(key, context.pointLightArray);
                        }
                        break;
                    case "glstate_spotLights[0]":
                        if (context.spotLightCount > 0) {
                            this.setFloatv(key, context.spotLightArray);
                        }
                        break;
                    case "glstate_lightCount":
                        this.setFloat(key, context.lightCount);
                        break;
                    case "glstate_directionalShadowMatrix[0]":
                        this.setMatrix4v(key, context.directShadowMatrix);
                        break;
                    case "glstate_spotShadowMatrix[0]":
                        this.setMatrix4v(key, context.spotShadowMatrix);
                        break;
                    case "glstate_directionalShadowMap[0]":
                        for (var i = 0; i < context.directShadowMaps.length; i++) {
                            if (context.directShadowMaps[i]) {
                                this.setWebGLTexture("glstate_directionalShadowMap[" + i + "]", context.directShadowMaps[i]);
                            }
                        }
                        break;
                    case "glstate_pointShadowMap[0]":
                        for (var i = 0; i < context.pointShadowMaps.length; i++) {
                            if (context.pointShadowMaps[i]) {
                                this.setWebGLTexture("glstate_pointShadowMap[" + i + "]", context.pointShadowMaps[i]);
                            }
                        }
                        break;
                    case "glstate_spotShadowMap[0]":
                        for (var i = 0; i < context.spotShadowMaps.length; i++) {
                            if (context.spotShadowMaps[i]) {
                                this.setWebGLTexture("glstate_spotShadowMap[" + i + "]", context.spotShadowMaps[i]);
                            }
                        }
                        break;
                    case "_LightmapTex":
                        this.setTexture(key, context.lightmap);
                        break;
                    case "_LightmapIntensity":
                        this.setFloat(key, context.lightmapIntensity);
                        break;
                    case "glstate_lightmapOffset":
                        if (context.lightmapOffset) {
                            this.setVector4_2(key, context.lightmapOffset);
                        }
                        else {
                            console.debug("Error light map scale and offset.");
                        }
                        break;
                    case "glstate_lightmapUV":
                        this.setFloat(key, context.lightmapUV);
                        break;
                    case "glstate_vec4_bones[0]":
                        this.setVector4v(key, context.boneData);
                        break;
                    case "glstate_matrix_bones":
                        this.setVector4v(key, context.boneData);
                        break;
                    case "glstate_referencePosition":
                        this.setVector4_2(key, context.lightPosition);
                        break;
                    case "glstate_nearDistance":
                        this.setFloat(key, context.lightShadowCameraNear);
                        break;
                    case "glstate_farDistance":
                        this.setFloat(key, context.lightShadowCameraFar);
                        break;
                }
            }
        };
        GlProgram.prototype.setInt = function (key, value) {
            if (this._uniforms[key].value != value) {
                var uniform = this._uniforms[key];
                uniform.value = value;
                this.gl.uniform1i(uniform.location, uniform.value);
            }
        };
        GlProgram.prototype.setFloat = function (key, value) {
            if (this._uniforms[key].value != value) {
                var uniform = this._uniforms[key];
                uniform.value = value;
                this.gl.uniform1f(uniform.location, uniform.value);
            }
        };
        GlProgram.prototype.setFloatv = function (key, value) {
            var uniform = this._uniforms[key];
            uniform.value = value;
            this.gl.uniform1fv(uniform.location, uniform.value);
        };
        GlProgram.prototype.setMatrix4 = function (key, value) {
            var uniform = this._uniforms[key];
            uniform.value = value.rawData;
            this.gl.uniformMatrix4fv(uniform.location, false, uniform.value);
        };
        GlProgram.prototype.setMatrix4v = function (key, value) {
            var uniform = this._uniforms[key];
            uniform.value = value;
            this.gl.uniformMatrix4fv(uniform.location, false, uniform.value);
        };
        GlProgram.prototype.setVector2 = function (key, value) {
            var uniform = this._uniforms[key];
            var letray = uniform.value;
            if (!letray) {
                uniform.value = [value.x, value.y];
                this.gl.uniform2fv(uniform.location, uniform.value);
            }
            else {
                if (letray[0] != value.x || letray[1] != value.y) {
                    letray[0] = value.x;
                    letray[1] = value.y;
                    this.gl.uniform2fv(uniform.location, uniform.value);
                }
            }
        };
        GlProgram.prototype.setVector2v = function (key, value) {
            var uniform = this._uniforms[key];
            uniform.value = value;
            this.gl.uniform2fv(uniform.location, uniform.value);
        };
        GlProgram.prototype.setVector3v = function (key, value) {
            var uniform = this._uniforms[key];
            uniform.value = value;
            this.gl.uniform3fv(uniform.location, uniform.value);
        };
        GlProgram.prototype.setVector3 = function (key, value) {
            var uniform = this._uniforms[key];
            var letray = uniform.value;
            if (!letray) {
                uniform.value = [value.x, value.y, value.z];
                this.gl.uniform3fv(uniform.location, uniform.value);
            }
            else {
                if (letray[0] != value.x || letray[1] != value.y || letray[2] != value.z) {
                    letray[0] = value.x;
                    letray[1] = value.y;
                    letray[2] = value.z;
                    this.gl.uniform3fv(uniform.location, uniform.value);
                }
            }
        };
        GlProgram.prototype.setVector4v = function (key, value) {
            var uniform = this._uniforms[key];
            uniform.value = value;
            this.gl.uniform4fv(uniform.location, uniform.value);
        };
        GlProgram.prototype.setVector4_2 = function (key, value) {
            var uniform = this._uniforms[key];
            var letray = uniform.value;
            if (!letray) {
                uniform.value = value;
                this.gl.uniform4fv(uniform.location, uniform.value);
            }
            else {
                // if (letray[0] != value[0] || letray[1] != value[1] || letray[2] != value[2] || letray[3] != value[3]) {
                uniform.value = value;
                this.gl.uniform4fv(uniform.location, uniform.value);
                // }
            }
        };
        GlProgram.prototype.setVector4 = function (key, value) {
            var uniform = this._uniforms[key];
            var letray = uniform.value;
            if (!letray) {
                uniform.value = [value.x, value.y, value.z, value.w];
                this.gl.uniform4fv(uniform.location, uniform.value);
            }
            else {
                if (letray[0] != value.x || letray[1] != value.y || letray[2] != value.z || letray[3] != value.w) {
                    letray[0] = value.x;
                    letray[1] = value.y;
                    letray[2] = value.z;
                    letray[3] = value.w;
                    this.gl.uniform4fv(uniform.location, uniform.value);
                }
            }
        };
        GlProgram.prototype.setTexture = function (key, value) {
            var uniform = this._uniforms[key];
            uniform.value = value ? value.glTexture : null;
            var index = this._samplerUnitMap[key];
            var tex = uniform.value != null ? uniform.value.texture : null;
            // 只标记对应的纹理单元，之后再统一上传纹理
            var cacheTextureUniform = this._cacheTextureUniforms[index];
            if (!cacheTextureUniform) {
                this.gl.uniform1i(uniform.location, index);
                this._cacheTextureUniforms[index] = { dirty: true, texture: tex, cube: uniform.type === egret3d.WEBGL_UNIFORM_TYPE.SAMPLER_CUBE };
            }
            else {
                cacheTextureUniform.texture = tex;
                cacheTextureUniform.dirty = true;
            }
        };
        GlProgram.prototype.setWebGLTexture = function (key, value) {
            var uniform = this._uniforms[key];
            uniform.value = value;
            var index = this._samplerUnitMap[key];
            var tex = uniform.value != null ? value : null;
            // 只标记对应的纹理单元，之后再统一上传纹理
            var cacheTextureUniform = this._cacheTextureUniforms[index];
            if (!cacheTextureUniform) {
                this.gl.uniform1i(uniform.location, index);
                this._cacheTextureUniforms[index] = { dirty: true, texture: tex, cube: uniform.type === egret3d.WEBGL_UNIFORM_TYPE.SAMPLER_CUBE };
            }
            else {
                cacheTextureUniform.texture = tex;
                cacheTextureUniform.dirty = true;
            }
        };
        GlProgram.prototype._updateUniforms = function (unifroms) {
            for (var key in unifroms) {
                var type = unifroms[key].type;
                var value = unifroms[key].value;
                var target = this._uniforms[key];
                if (target == null) {
                    continue;
                }
                switch (type) {
                    case egret3d.UniformTypeEnum.Boolean:
                        this.setInt(key, value);
                        break;
                    case egret3d.UniformTypeEnum.Int:
                        this.setInt(key, value);
                        break;
                    case egret3d.UniformTypeEnum.Float:
                        this.setFloat(key, value);
                        break;
                    case egret3d.UniformTypeEnum.Floatv:
                        this.setFloatv(key, value);
                        break;
                    case egret3d.UniformTypeEnum.Float2:
                        this.setVector2(key, value);
                        break;
                    case egret3d.UniformTypeEnum.Float2v:
                        this.setVector2v(key, value);
                        break;
                    case egret3d.UniformTypeEnum.Float3:
                        this.setVector3(key, value);
                        break;
                    case egret3d.UniformTypeEnum.Float3v:
                        this.setVector3v(key, value);
                        break;
                    case egret3d.UniformTypeEnum.Float4:
                        this.setVector4(key, value);
                        break;
                    case egret3d.UniformTypeEnum.Float4v:
                        this.setVector4v(key, value);
                        break;
                    case egret3d.UniformTypeEnum.Float4x4:
                        this.setMatrix4(key, value);
                        break;
                    case egret3d.UniformTypeEnum.Float4x4v:
                        this.setMatrix4(key, value);
                        break;
                    case egret3d.UniformTypeEnum.Texture:
                        this.setTexture(key, value);
                        break;
                }
            }
        };
        GlProgram.prototype.uploadUniforms = function (material, context, forceUpdate) {
            if (forceUpdate === void 0) { forceUpdate = false; }
            var materialChange = this._cacheMaterial !== material || this._cacheMaterialVer !== material.version;
            if (materialChange) {
                this._updateUniforms(material.$uniforms);
                this._cacheMaterial = material;
                this._cacheMaterialVer = material.version;
            }
            var contextChange = this._cacheContext != context || this._cacheContextVer != context.version;
            if (contextChange) {
                this._updateRenderContextUniforms(context);
                this._cacheContext = context;
                this._cacheContextVer = context.version;
            }
            // 纹理上传特殊处理
            // shader切换的情况下，只需要重新上传纹理到对应的纹理单元即可
            // 并不需要调用unifrom函数
            if (forceUpdate) {
                for (var i = 0; i < this._cacheTextureUniforms.length; i++) {
                    var info = this._cacheTextureUniforms[i];
                    if (info) {
                        egret3d.WebGLKit.activeTexture(i);
                        this.gl.bindTexture(info.cube ? this.gl.TEXTURE_CUBE_MAP : this.gl.TEXTURE_2D, info.texture);
                    }
                }
            }
            else if (materialChange || contextChange) {
                for (var i = 0; i < this._cacheTextureUniforms.length; i++) {
                    var info = this._cacheTextureUniforms[i];
                    if (info && info.dirty) {
                        egret3d.WebGLKit.activeTexture(i);
                        this.gl.bindTexture(info.cube ? this.gl.TEXTURE_CUBE_MAP : this.gl.TEXTURE_2D, info.texture);
                    }
                }
            }
            else {
                // TODO 判断纹理标脏上传
            }
        };
        GlProgram._programMap = {};
        return GlProgram;
    }());
    egret3d.GlProgram = GlProgram;
    __reflect(GlProgram.prototype, "egret3d.GlProgram");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var TextureReader = (function () {
        function TextureReader(webgl, texRGBA, width, height, gray) {
            if (gray === void 0) { gray = true; }
            this.gray = gray;
            this.width = width;
            this.height = height;
            var fbo = webgl.createFramebuffer();
            var fbold = webgl.getParameter(webgl.FRAMEBUFFER_BINDING);
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbo);
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, texRGBA, 0);
            var readData = new Uint8Array(this.width * this.height * 4);
            readData[0] = 2;
            webgl.readPixels(0, 0, this.width, this.height, webgl.RGBA, webgl.UNSIGNED_BYTE, readData);
            webgl.deleteFramebuffer(fbo);
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbold);
            if (gray) {
                this.data = new Uint8Array(this.width * this.height);
                for (var i = 0; i < width * height; i++) {
                    this.data[i] = readData[i * 4];
                }
            }
            else {
                this.data = readData;
            }
        }
        TextureReader.prototype.getPixel = function (u, v) {
            var x = (u * this.width) | 0;
            var y = (v * this.height) | 0;
            if (x < 0 || x >= this.width || y < 0 || y >= this.height)
                return 0;
            if (this.gray) {
                return this.data[y * this.width + x];
            }
            else {
                var i = (y * this.width + x) * 4;
                return new egret3d.Color(this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]);
            }
        };
        return TextureReader;
    }());
    egret3d.TextureReader = TextureReader;
    __reflect(TextureReader.prototype, "egret3d.TextureReader");
    var GlRenderTarget = (function () {
        function GlRenderTarget(webgl, width, height, depth, stencil) {
            if (depth === void 0) { depth = false; }
            if (stencil === void 0) { stencil = false; }
            this.width = width;
            this.height = height;
            this.fbo = webgl.createFramebuffer();
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
            if (depth || stencil) {
                this.renderbuffer = webgl.createRenderbuffer();
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                if (depth && stencil) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                }
                else if (depth) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                }
                else {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                }
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            }
            this.texture = webgl.createTexture();
            this.fbo["width"] = width;
            this.fbo["height"] = height;
            webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
        }
        GlRenderTarget.prototype.use = function (webgl) {
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
            // webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
            // webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            //webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
        };
        GlRenderTarget.useNull = function (webgl) {
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
        };
        GlRenderTarget.prototype.dispose = function (webgl) {
            //if (this.texture == null && this.img != null)
            //    this.disposeit = true;
            if (this.texture != null) {
                webgl.deleteFramebuffer(this.renderbuffer);
                this.renderbuffer = null;
                webgl.deleteTexture(this.texture);
                this.texture = null;
            }
        };
        GlRenderTarget.prototype.caclByteLength = function () {
            //RGBA & no mipmap
            return this.width * this.height * 4;
        };
        GlRenderTarget.prototype.isFrameBuffer = function () {
            return true;
        };
        return GlRenderTarget;
    }());
    egret3d.GlRenderTarget = GlRenderTarget;
    __reflect(GlRenderTarget.prototype, "egret3d.GlRenderTarget", ["egret3d.IRenderTarget", "egret3d.ITexture"]);
    var GlRenderTargetCube = (function () {
        function GlRenderTargetCube(webgl, width, height, depth, stencil) {
            if (depth === void 0) { depth = false; }
            if (stencil === void 0) { stencil = false; }
            this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
            this.width = width;
            this.height = height;
            this.fbo = webgl.createFramebuffer();
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
            if (depth || stencil) {
                this.renderbuffer = webgl.createRenderbuffer();
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                if (depth && stencil) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                }
                else if (depth) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                }
                else {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                }
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            }
            this.texture = webgl.createTexture();
            this.fbo["width"] = width;
            this.fbo["height"] = height;
            webgl.bindTexture(webgl.TEXTURE_CUBE_MAP, this.texture);
            webgl.texParameteri(webgl.TEXTURE_CUBE_MAP, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
            webgl.texParameteri(webgl.TEXTURE_CUBE_MAP, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            for (var i = 0; i < 6; i++) {
                webgl.texImage2D(webgl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
            }
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_CUBE_MAP_POSITIVE_X + this.activeCubeFace, this.texture, 0);
        }
        GlRenderTargetCube.prototype.use = function (webgl) {
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
            // webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
            // webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_CUBE_MAP_POSITIVE_X + this.activeCubeFace, this.texture, 0);
        };
        GlRenderTargetCube.useNull = function (webgl) {
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
        };
        GlRenderTargetCube.prototype.dispose = function (webgl) {
            //if (this.texture == null && this.img != null)
            //    this.disposeit = true;
            if (this.texture != null) {
                webgl.deleteFramebuffer(this.renderbuffer);
                this.renderbuffer = null;
                webgl.deleteTexture(this.texture);
                this.texture = null;
            }
        };
        GlRenderTargetCube.prototype.caclByteLength = function () {
            //RGBA & no mipmap
            return this.width * this.height * 4;
        };
        GlRenderTargetCube.prototype.isFrameBuffer = function () {
            return true;
        };
        return GlRenderTargetCube;
    }());
    egret3d.GlRenderTargetCube = GlRenderTargetCube;
    __reflect(GlRenderTargetCube.prototype, "egret3d.GlRenderTargetCube", ["egret3d.IRenderTarget", "egret3d.ITexture"]);
    /**
     *
     */
    var GlTexture2D = (function () {
        function GlTexture2D(webgl, format, mipmap, linear) {
            if (format === void 0) { format = 1 /* RGBA */; }
            if (mipmap === void 0) { mipmap = false; }
            if (linear === void 0) { linear = true; }
            this.loaded = false;
            this.width = 0;
            this.height = 0;
            this.mipmap = false;
            this.webgl = webgl;
            this.format = format;
            this.texture = webgl.createTexture();
        }
        GlTexture2D.prototype.uploadImage = function (img, mipmap, linear, premultiply, repeat, mirroredU, mirroredV) {
            if (premultiply === void 0) { premultiply = true; }
            if (repeat === void 0) { repeat = false; }
            if (mirroredU === void 0) { mirroredU = false; }
            if (mirroredV === void 0) { mirroredV = false; }
            this.width = img.width;
            this.height = img.height;
            this.mipmap = mipmap;
            this.loaded = true;
            this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
            this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 0);
            this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
            var formatGL = this.webgl.RGBA;
            if (this.format == 2 /* RGB */) {
                formatGL = this.webgl.RGB;
            }
            else if (this.format == 3 /* Gray */) {
                formatGL = this.webgl.LUMINANCE;
            }
            this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, formatGL, formatGL, this.webgl.UNSIGNED_BYTE, img);
            if (mipmap) {
                this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                if (linear) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                }
            }
            else {
                if (linear) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                }
            }
            if (repeat) {
                if (mirroredU && mirroredV) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                }
                else if (mirroredU) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                }
                else if (mirroredV) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                }
            }
            else {
                this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
            }
        };
        GlTexture2D.prototype.uploadByteArray = function (mipmap, linear, width, height, data, repeat, mirroredU, mirroredV) {
            if (repeat === void 0) { repeat = false; }
            if (mirroredU === void 0) { mirroredU = false; }
            if (mirroredV === void 0) { mirroredV = false; }
            this.width = width;
            this.height = height;
            this.mipmap = mipmap;
            this.loaded = true;
            this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
            this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 0);
            this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
            var formatGL = this.webgl.RGBA;
            if (this.format == 2 /* RGB */) {
                formatGL = this.webgl.RGB;
            }
            else if (this.format == 3 /* Gray */) {
                formatGL = this.webgl.LUMINANCE;
            }
            this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, formatGL, width, height, 0, formatGL, this.webgl.UNSIGNED_BYTE, data);
            if (mipmap) {
                this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                if (linear) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                }
            }
            else {
                if (linear) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                }
            }
            if (repeat) {
                if (mirroredU && mirroredV) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                }
                else if (mirroredU) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                }
                else if (mirroredV) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                }
            }
            else {
                this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
            }
        };
        GlTexture2D.prototype.caclByteLength = function () {
            var pixellen = 1;
            if (this.format == 1 /* RGBA */) {
                pixellen = 4;
            }
            else if (this.format == 2 /* RGB */) {
                pixellen = 3;
            }
            var len = this.width * this.height * pixellen;
            if (this.mipmap) {
                len = len * (1 - Math.pow(0.25, 10)) / 0.75;
            }
            return len;
        };
        GlTexture2D.prototype.getReader = function (redOnly) {
            if (redOnly === void 0) { redOnly = false; }
            if (this.reader != null) {
                if (this.reader.gray != redOnly)
                    throw new Error("get param diff with this.reader");
                return this.reader;
            }
            if (this.format != 1 /* RGBA */)
                throw new Error("only rgba texture can read");
            if (this.texture == null)
                return null;
            if (this.reader == null)
                this.reader = new TextureReader(this.webgl, this.texture, this.width, this.height, redOnly);
            return this.reader;
        };
        //disposeit: boolean = false;
        GlTexture2D.prototype.dispose = function (webgl) {
            //if (this.texture == null && this.img != null) this.disposeit = true;
            if (this.texture != null) {
                webgl.deleteTexture(this.texture);
                this.texture = null;
            }
        };
        GlTexture2D.prototype.isFrameBuffer = function () {
            return false;
        };
        GlTexture2D.createColorTexture = function (webgl, r, g, b) {
            var mipmap = false;
            var linear = true;
            var width = 1;
            var height = 1;
            var texture = new GlTexture2D(webgl, 1 /* RGBA */, mipmap, linear);
            var data = new Uint8Array([r, g, b, 255]);
            texture.uploadByteArray(mipmap, linear, width, height, data);
            return texture;
        };
        GlTexture2D.createGridTexture = function (webgl) {
            var mipmap = false;
            var linear = true;
            var t = new GlTexture2D(webgl, 1 /* RGBA */, mipmap, linear);
            var width = 256;
            var height = 256;
            var data = new Uint8Array(width * width * 4);
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var seek = (y * width + x) * 4;
                    var bool = ((x - width * 0.5) * (y - height * 0.5)) > 0;
                    data[seek] = data[seek + 1] = data[seek + 2] = bool ? 0 : 255;
                    data[seek + 3] = 255;
                }
            }
            t.uploadByteArray(mipmap, linear, width, height, data);
            return t;
        };
        return GlTexture2D;
    }());
    egret3d.GlTexture2D = GlTexture2D;
    __reflect(GlTexture2D.prototype, "egret3d.GlTexture2D", ["egret3d.ITexture"]);
    var WriteableTexture2D = (function () {
        function WriteableTexture2D(webgl, format, width, height, linear, premultiply, repeat, mirroredU, mirroredV) {
            if (format === void 0) { format = 1 /* RGBA */; }
            if (premultiply === void 0) { premultiply = true; }
            if (repeat === void 0) { repeat = false; }
            if (mirroredU === void 0) { mirroredU = false; }
            if (mirroredV === void 0) { mirroredV = false; }
            this.premultiply = true;
            this.repeat = false;
            this.mirroredU = false;
            this.mirroredV = false;
            this.width = 0;
            this.height = 0;
            this.webgl = webgl;
            this.texture = webgl.createTexture();
            this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
            this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 0);
            this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
            this.format = format;
            this.formatGL = this.webgl.RGBA;
            if (format == 2 /* RGB */) {
                this.formatGL = this.webgl.RGB;
            }
            else if (format == 3 /* Gray */) {
                this.formatGL = this.webgl.LUMINANCE;
            }
            var data = null;
            this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, this.formatGL, width, height, 0, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
            if (linear) {
                this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
            }
            else {
                this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
            }
            if (repeat) {
                if (mirroredU && mirroredV) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                }
                else if (mirroredU) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                }
                else if (mirroredV) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                }
            }
            else {
                this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
            }
        }
        WriteableTexture2D.prototype.updateRect = function (data, x, y, width, height) {
            this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
            this.webgl.texSubImage2D(this.webgl.TEXTURE_2D, 0, x, y, width, height, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
        };
        WriteableTexture2D.prototype.updateRectImg = function (data, x, y) {
            this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
            this.webgl.texSubImage2D(this.webgl.TEXTURE_2D, 0, x, y, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
        };
        WriteableTexture2D.prototype.isFrameBuffer = function () {
            return false;
        };
        WriteableTexture2D.prototype.dispose = function (webgl) {
            if (this.texture != null) {
                webgl.deleteTexture(this.texture);
                this.texture = null;
            }
        };
        WriteableTexture2D.prototype.caclByteLength = function () {
            var pixellen = 1;
            if (this.format == 1 /* RGBA */) {
                pixellen = 4;
            }
            else if (this.format == 2 /* RGB */) {
                pixellen = 3;
            }
            var len = this.width * this.height * pixellen;
            return len;
        };
        return WriteableTexture2D;
    }());
    egret3d.WriteableTexture2D = WriteableTexture2D;
    __reflect(WriteableTexture2D.prototype, "egret3d.WriteableTexture2D", ["egret3d.ITexture"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var WEBGL_ATTRIBUTE_TYPE;
    (function (WEBGL_ATTRIBUTE_TYPE) {
        WEBGL_ATTRIBUTE_TYPE[WEBGL_ATTRIBUTE_TYPE["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
        WEBGL_ATTRIBUTE_TYPE[WEBGL_ATTRIBUTE_TYPE["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
        WEBGL_ATTRIBUTE_TYPE[WEBGL_ATTRIBUTE_TYPE["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
        WEBGL_ATTRIBUTE_TYPE[WEBGL_ATTRIBUTE_TYPE["FLOAT"] = 5126] = "FLOAT";
        WEBGL_ATTRIBUTE_TYPE[WEBGL_ATTRIBUTE_TYPE["BYTE"] = 65535] = "BYTE";
        WEBGL_ATTRIBUTE_TYPE[WEBGL_ATTRIBUTE_TYPE["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        WEBGL_ATTRIBUTE_TYPE[WEBGL_ATTRIBUTE_TYPE["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    })(WEBGL_ATTRIBUTE_TYPE = egret3d.WEBGL_ATTRIBUTE_TYPE || (egret3d.WEBGL_ATTRIBUTE_TYPE = {}));
    var WebGLAttribute = (function () {
        function WebGLAttribute(gl, program, attributeData) {
            this.gl = gl;
            this.name = attributeData.name;
            this.type = attributeData.type;
            this.size = attributeData.size;
            this.location = gl.getAttribLocation(program, this.name);
            this.count = this._initCount(this.type);
            this.format = this._initFormat(gl, this.type);
        }
        WebGLAttribute.prototype._initCount = function (type) {
            var count = 0;
            switch (type) {
                case WEBGL_ATTRIBUTE_TYPE.FLOAT:
                case WEBGL_ATTRIBUTE_TYPE.BYTE:
                case WEBGL_ATTRIBUTE_TYPE.UNSIGNED_BYTE:
                case WEBGL_ATTRIBUTE_TYPE.UNSIGNED_SHORT:
                    count = 1;
                    break;
                case WEBGL_ATTRIBUTE_TYPE.FLOAT_VEC2:
                    count = 2;
                    break;
                case WEBGL_ATTRIBUTE_TYPE.FLOAT_VEC3:
                    count = 3;
                    break;
                case WEBGL_ATTRIBUTE_TYPE.FLOAT_VEC4:
                    count = 4;
                    break;
            }
            return count;
        };
        WebGLAttribute.prototype._initFormat = function (gl, type) {
            var format;
            switch (type) {
                case WEBGL_ATTRIBUTE_TYPE.FLOAT:
                case WEBGL_ATTRIBUTE_TYPE.FLOAT_VEC2:
                case WEBGL_ATTRIBUTE_TYPE.FLOAT_VEC3:
                case WEBGL_ATTRIBUTE_TYPE.FLOAT_VEC4:
                    format = gl.FLOAT;
                    break;
                case WEBGL_ATTRIBUTE_TYPE.UNSIGNED_BYTE:
                    format = gl.UNSIGNED_BYTE;
                    break;
                case WEBGL_ATTRIBUTE_TYPE.UNSIGNED_SHORT:
                    format = gl.UNSIGNED_SHORT;
                    break;
                case WEBGL_ATTRIBUTE_TYPE.BYTE:
                    format = gl.BYTE;
                    break;
            }
            return format;
        };
        return WebGLAttribute;
    }());
    egret3d.WebGLAttribute = WebGLAttribute;
    __reflect(WebGLAttribute.prototype, "egret3d.WebGLAttribute");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 场景编辑器
         **/
        var Editor = (function () {
            function Editor() {
            }
            Object.defineProperty(Editor, "editorModel", {
                get: function () {
                    return this._editorModel;
                },
                enumerable: true,
                configurable: true
            });
            /**初始化 */
            Editor.init = function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                // 覆盖生成 uuid 的方式。
                                paper.createUUID = editor.generateUuid;
                                //启动egret3编辑环境
                                this.runEgret();
                                //初始化编辑模型
                                this._editorModel = new editor.EditorModel();
                                return [4 /*yield*/, this.editorModel.init()];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            Editor.runEgret = function () {
                egret3d.runEgret({ antialias: true, isEditor: true, isPlaying: false });
                paper.Application.systemManager.disableSystem(egret3d.CameraSystem);
                paper.Application.systemManager.registerBefore(editor.EditorCameraSystem, paper.DestroySystem);
                paper.Application.systemManager.registerBefore(editor.GizmosSystem, paper.DestroySystem);
            };
            return Editor;
        }());
        editor.Editor = Editor;
        __reflect(Editor.prototype, "paper.editor.Editor");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var DestroySystem = (function (_super) {
        __extends(DestroySystem, _super);
        function DestroySystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._bufferedComponents = [];
            _this._bufferedGameObjects = [];
            return _this;
        }
        /**
         * @inheritDoc
         */
        DestroySystem.prototype.onUpdate = function () {
            for (var _i = 0, _a = this._bufferedComponents; _i < _a.length; _i++) {
                var component = _a[_i];
                component.uninitialize();
            }
            this._bufferedComponents.length = 0;
            this._bufferedGameObjects.length = 0;
            //
            egret3d.InputManager.update(paper.Time.deltaTime);
            egret3d.Performance.endCounter("all" /* All */);
        };
        /**
         * @internal
         */
        DestroySystem.prototype.bufferComponent = function (component) {
            if (this._bufferedComponents.indexOf(component) >= 0) {
                return;
            }
            this._bufferedComponents.push(component);
        };
        /**
         * @internal
         */
        DestroySystem.prototype.bufferGameObject = function (gameObject) {
            if (this._bufferedGameObjects.indexOf(gameObject) >= 0) {
                return;
            }
            this._bufferedGameObjects.push(gameObject);
        };
        return DestroySystem;
    }(paper.BaseSystem));
    paper.DestroySystem = DestroySystem;
    __reflect(DestroySystem.prototype, "paper.DestroySystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    var _isCreate = false;
    var _deserializedObjects;
    /**
     * 反序列化
     * @param data 反序列化数据
     * @param expandMap 扩展的对象映射，此映射中存在的对象不需要重新序列化，直接使用即可（例如已经加载完成的资源文件）。
     */
    function deserialize(data, expandMap, isCreate) {
        if (isCreate === void 0) { isCreate = false; }
        _isCreate = isCreate;
        _deserializedObjects = {};
        for (var k in expandMap) {
            _deserializedObjects[k] = expandMap[k];
        }
        var root = null;
        for (var _i = 0, _a = data.objects; _i < _a.length; _i++) {
            var source = _a[_i];
            var k = source.hashCode || source.uuid; // hashCode 兼容。
            var target = void 0;
            if (k in _deserializedObjects) {
                target = _deserializedObjects[k];
            }
            else {
                var className = paper.serializeClassMap[source.class] || source.class;
                var clazz = egret.getDefinitionByName(className);
                if (clazz) {
                    target = new clazz();
                    _deserializedObjects[k] = target;
                }
                else {
                    target = new paper.MissingObject();
                    _deserializedObjects[k] = target;
                    console.error("Class " + source.class + " not defined.");
                }
            }
            root = root || target;
        }
        for (var _b = 0, _c = data.objects; _b < _c.length; _b++) {
            var source = _c[_b];
            var k = source.hashCode || source.uuid; // hashCode 兼容。
            if (k in expandMap) {
                continue;
            }
            var target = _deserializedObjects[k];
            _deserializeObject(source, target);
            if (target instanceof paper.GameObject) {
                for (var _d = 0, _e = target.components; _d < _e.length; _d++) {
                    var component = _e[_d];
                    component.gameObject = target; // TODO
                }
            }
        }
        for (var _f = 0, _g = data.objects; _f < _g.length; _f++) {
            var source = _g[_f];
            var k = source.hashCode || source.uuid; // hashCode 兼容。
            var target = _deserializedObjects[k];
            if (target instanceof paper.BaseComponent) {
                target.initialize();
                if (target.isActiveAndEnabled) {
                    paper.EventPool.dispatchEvent("__enabled__" /* Enabled */, target);
                }
            }
        }
        _deserializedObjects = null;
        return root;
    }
    paper.deserialize = deserialize;
    /**
     *
     */
    function getDeserializedObject(source) {
        var k = source.hashCode || source.uuid; // hashCode 兼容。
        return _deserializedObjects[k];
    }
    paper.getDeserializedObject = getDeserializedObject;
    function _deserializeObject(source, target) {
        if (target.constructor.prototype.hasOwnProperty("deserialize")) {
            var uuid = source.uuid; // TODO 字符串依赖。
            if (_isCreate) {
                delete source.uuid;
            }
            target.deserialize(source);
            if (_isCreate) {
                source.uuid = uuid;
            }
        }
        else {
            for (var k in source) {
                if (k === "hashCode" || k === "class") {
                    continue;
                }
                if (_isCreate && k === "uuid") {
                    continue;
                }
                if ("__deserializedIgnore" /* DeserializedIgnore */ in target &&
                    target["__deserializedIgnore" /* DeserializedIgnore */].indexOf(k) >= 0) {
                    continue;
                }
                target[k] = _deserializeChild(source[k], target[k]);
            }
        }
    }
    function _deserializeChild(source, target) {
        if (source === null || source === undefined) {
            return source;
        }
        switch (typeof source) {
            case "function":
                return undefined;
            case "object": {
                if (target) {
                    if (target.constructor.prototype.hasOwnProperty("deserialize")) {
                        // _deserializeObject(source, target);
                        target.deserialize(source);
                        return target;
                    }
                    else if (ArrayBuffer.isView(target)) {
                        for (var i = 0, l = Math.min(source.length, target.length); i < l; ++i) {
                            target[i] = source[i];
                        }
                        return target;
                    }
                    else if (Array.isArray(target) && target.length === 0) {
                        for (var i = 0, l = source.length; i < l; ++i) {
                            target[i] = _deserializeChild(source[i]);
                        }
                        return target;
                    }
                    else if (target instanceof paper.BaseComponent) {
                        _deserializeObject(source, target);
                        return target;
                    }
                    else {
                        // console.info("Deserialize can be optimized.");
                    }
                }
                if (Array.isArray(source)) {
                    target = [];
                    for (var i = 0, l = source.length; i < l; ++i) {
                        target[i] = _deserializeChild(source[i]);
                    }
                    return target;
                }
                var uuid = (source.hashCode || source.uuid); // TODO 字符串依赖， hashCode 兼容。
                var classCodeOrName = source.class; // TODO 字符串依赖。
                if (uuid) {
                    if (uuid in _deserializedObjects) {
                        return _deserializedObjects[uuid];
                    }
                    else if (classCodeOrName) {
                        if (classCodeOrName === paper.findClassCodeFrom(paper.Scene)) {
                            // TODO
                        }
                        else if (classCodeOrName === paper.findClassCodeFrom(paper.GameObject)) {
                            for (var _i = 0, _a = paper.Application.sceneManager.activeScene.gameObjects; _i < _a.length; _i++) {
                                var gameObject = _a[_i];
                                if (gameObject.uuid === uuid) {
                                    return gameObject;
                                }
                            }
                        }
                        else {
                            for (var _b = 0, _c = paper.Application.sceneManager.activeScene.gameObjects; _b < _c.length; _b++) {
                                var gameObject = _c[_b];
                                for (var _d = 0, _e = gameObject.components; _d < _e.length; _d++) {
                                    var component = _e[_d];
                                    if (component.uuid === uuid) {
                                        return component;
                                    }
                                }
                            }
                        }
                    }
                }
                else if (classCodeOrName) {
                    classCodeOrName = paper.serializeClassMap[classCodeOrName] || classCodeOrName;
                    var clazz = egret.getDefinitionByName(classCodeOrName);
                    if (clazz) {
                        target = new clazz();
                        _deserializeObject(source, target);
                        return target;
                    }
                }
                else {
                    target = {};
                    for (var k in source) {
                        target[k] = _deserializeChild(source[k]);
                    }
                    return target;
                }
                console.warn("Deserialize error.", source);
                return null;
            }
            default:
                return source;
        }
    }
})(paper || (paper = {}));
/// <reference path="./EventDispatcher.ts" />
var paper;
(function (paper_1) {
    var editor;
    (function (editor) {
        editor.context = new editor.EventDispatcher();
        var selectItemType;
        (function (selectItemType) {
            selectItemType[selectItemType["GAMEOBJECT"] = 0] = "GAMEOBJECT";
            selectItemType[selectItemType["ASSET"] = 1] = "ASSET";
        })(selectItemType = editor.selectItemType || (editor.selectItemType = {}));
        /**
         * 编辑模型事件
         */
        var EditorModelEvent = (function (_super) {
            __extends(EditorModelEvent, _super);
            function EditorModelEvent(type, data) {
                return _super.call(this, type, data) || this;
            }
            EditorModelEvent.ADD_GAMEOBJECTS = "addGameObject";
            EditorModelEvent.DELETE_GAMEOBJECTS = "deleteGameObject";
            EditorModelEvent.SELECT_GAMEOBJECTS = "selectGame";
            EditorModelEvent.CHANGE_PROPERTY = "changeProperty";
            EditorModelEvent.CHANGE_EDIT_MODE = "changeEditMode";
            EditorModelEvent.CHANGE_EDIT_TYPE = "changeEditType";
            EditorModelEvent.CHANGE_SCENE = "changeScene";
            EditorModelEvent.ADD_COMPONENT = "addComponent";
            EditorModelEvent.REMOVE_COMPONENT = "removeComponent";
            EditorModelEvent.UPDATE_PARENT = "updateParent";
            return EditorModelEvent;
        }(editor.BaseEvent));
        editor.EditorModelEvent = EditorModelEvent;
        __reflect(EditorModelEvent.prototype, "paper.editor.EditorModelEvent");
        var ModifyObjectType;
        (function (ModifyObjectType) {
            ModifyObjectType[ModifyObjectType["GAMEOBJECT"] = 0] = "GAMEOBJECT";
            ModifyObjectType[ModifyObjectType["BASECOMPONENT"] = 1] = "BASECOMPONENT";
        })(ModifyObjectType = editor.ModifyObjectType || (editor.ModifyObjectType = {}));
        var CmdType = (function () {
            function CmdType() {
            }
            /**更改游戏对象基础属性 */
            CmdType.MODIFY_OBJECT_PROPERTY = "MODIFY_OBJECT_PROPERTY";
            /**修改transform属性 */
            CmdType.MODIFY_COMPONENT_PROPERTY = "MODIFY_COMPONENT_PROPERTY";
            /**选中游戏对象 */
            CmdType.SELECT_GAMEOBJECT = "SELECT_GAMEOBJECT";
            /**添加游戏对象 */
            CmdType.ADD_GAMEOBJECT = "ADD_GAMEOBJECT";
            /**移除游戏对象 */
            CmdType.REMOVE_GAMEOBJECTS = "REMOVE_GAMEOBJECTS";
            /**克隆游戏对象 */
            CmdType.DUPLICATE_GAMEOBJECTS = "DUPLICATE_GAMEOBJECTS";
            /**粘贴游戏对象 */
            CmdType.PASTE_GAMEOBJECTS = "PASTE_GAMEOBJECTS";
            /**添加组件 */
            CmdType.ADD_COMPONENT = "ADD_COMPONENT";
            /**移除组件 */
            CmdType.REMOVE_COMPONENT = "REMOVE_COMPONENT";
            /**更改parent */
            CmdType.UPDATE_PARENT = "UPDATE_PARENT";
            /**修改预制体游戏对象属性 */
            CmdType.MODIFY_PREFAB_GAMEOBJECT_PROPERTY = "MODIFY_PREFAB_GAMEOBJECT_PROPERTY";
            /**修改预制体组件属性 */
            CmdType.MODIFY_PREFAB_COMPONENT_PROPERTY = "MODIFY_PREFAB_COMPONENT_PROPERTY";
            /**添加组件 */
            CmdType.ADD_PREFAB_COMPONENT = "ADD_PREFAB_COMPONENT";
            /**移除组件 */
            CmdType.REMOVE_PREFAB_COMPONENT = "REMOVE_PREFAB_COMPONENT";
            /**修改asset属性 */
            CmdType.MODIFY_ASSET_PROPERTY = "MODIFY_ASSET_PROPERTY";
            /**创建prefab */
            CmdType.CREATE_PREFAB = "CREATE_PREFAB";
            return CmdType;
        }());
        editor.CmdType = CmdType;
        __reflect(CmdType.prototype, "paper.editor.CmdType");
        /**
         * 编辑模型
         */
        var EditorModel = (function (_super) {
            __extends(EditorModel, _super);
            function EditorModel() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.undo = function () {
                    _this.paperHistory.back();
                };
                _this.redo = function () {
                    _this.paperHistory.forward();
                };
                return _this;
            }
            /**
             * 初始化
             */
            EditorModel.prototype.init = function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, RES.loadConfig("resource/default.res.json", "resource/")];
                            case 1:
                                _a.sent();
                                this.initHistory();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            EditorModel.prototype.initHistory = function () {
                this.paperHistory = new editor.History();
            };
            EditorModel.prototype.setBackRuntime = function (back) {
                this.backRunTime = back;
            };
            EditorModel.prototype.addState = function (state) {
                state && this.paperHistory && this.paperHistory.add(state);
            };
            EditorModel.prototype.getEditType = function (propName, target) {
                var editInfoList = editor.getEditInfo(target);
                for (var index = 0; index < editInfoList.length; index++) {
                    var element = editInfoList[index];
                    if (element.name === propName) {
                        return element.editType;
                    }
                }
                var extraInfoList = editor.getExtraInfo(target);
                for (var index = 0; index < extraInfoList.length; index++) {
                    var element = extraInfoList[index];
                    if (element.name === propName) {
                        return element.editType;
                    }
                }
                return null;
            };
            EditorModel.prototype.setProperty = function (propName, propValue, target) {
                var editType = this.getEditType(propName, target);
                if (editType === null) {
                    return false;
                }
                if (target instanceof paper_1.GameObject) {
                    this.createModifyGameObjectPropertyState(propName, propValue, target, editType);
                }
                else if (target instanceof paper_1.BaseComponent) {
                    this.createModifyComponent(propName, propValue, target, editType);
                }
                return true;
            };
            EditorModel.prototype.createModifyGameObjectPropertyState = function (propName, propValue, target, editType, add) {
                if (add === void 0) { add = true; }
                var preValue = this.serializeProperty(target[propName], editType);
                var newValue = this.serializeProperty(propValue, editType);
                var uuid = target.uuid;
                var data = {
                    cmdType: CmdType.MODIFY_OBJECT_PROPERTY,
                    propName: propName,
                    newValue: newValue,
                    preValue: preValue,
                    uuid: uuid,
                    editType: editType
                };
                var state = editor.ModifyGameObjectPropertyState.create(data);
                add && this.addState(state);
                return state;
            };
            EditorModel.prototype.createModifyComponent = function (propName, propValue, target, editType, add) {
                if (add === void 0) { add = true; }
                var preValue = this.serializeProperty(target[propName], editType);
                var newValue = this.serializeProperty(propValue, editType);
                var componentUUid = target.uuid;
                var gameObjectUUid = target.gameObject.uuid;
                var data = {
                    cmdType: CmdType.MODIFY_COMPONENT_PROPERTY,
                    propName: propName,
                    newValue: newValue,
                    preValue: preValue,
                    editType: editType,
                    componentUUid: componentUUid,
                    gameObjectUUid: gameObjectUUid,
                };
                var state = editor.ModifyComponentPropertyState.create(target, propName, propValue, data);
                add && this.addState(state);
                return state;
            };
            EditorModel.prototype.createModifyPrefabGameObjectPropertyState = function (gameObjectUUid, newValueList, preValueCopylist) {
                var data = {
                    cmdType: CmdType.MODIFY_PREFAB_GAMEOBJECT_PROPERTY,
                    gameObjectUUid: gameObjectUUid,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                var state = editor.ModifyPrefabGameObjectPropertyState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.createModifyPrefabComponentPropertyState = function (gameObjUUid, componentUUid, newValueList, preValueCopylist) {
                var data = {
                    cmdType: CmdType.MODIFY_PREFAB_COMPONENT_PROPERTY,
                    gameObjUUid: gameObjUUid,
                    componentUUid: componentUUid,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                var state = editor.ModifyPrefabComponentPropertyState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.createRemoveComponentFromPrefab = function (stateData) {
                var data = __assign({ cmdType: CmdType.REMOVE_PREFAB_COMPONENT }, stateData);
                var state = editor.RemovePrefabComponentState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.createAddComponentToPrefab = function (stateData) {
                var data = __assign({ cmdType: CmdType.ADD_PREFAB_COMPONENT }, stateData);
                var state = editor.AddPrefabComponentState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.createModifyAssetPropertyState = function (assetUrl, newValueList, preValueCopylist) {
                var data = {
                    cmdType: CmdType.MODIFY_ASSET_PROPERTY,
                    assetUrl: assetUrl,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                var state = editor.ModifyAssetPropertyState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.createPrefabState = function (prefab, selectIds) {
                var data = {
                    cmdType: CmdType.CREATE_PREFAB,
                    prefab: prefab,
                    selectIds: selectIds
                };
                var state = editor.CreatePrefabState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.serializeProperty = function (value, editType) {
                switch (editType) {
                    case editor.EditType.NUMBER:
                    case editor.EditType.TEXT:
                    case editor.EditType.CHECKBOX:
                        return value;
                    case editor.EditType.VECTOR2:
                    case editor.EditType.VECTOR3:
                    case editor.EditType.VECTOR4:
                    case editor.EditType.QUATERNION:
                    case editor.EditType.COLOR:
                    case editor.EditType.RECT:
                        var className = egret.getQualifiedClassName(value);
                        var serializeData = paper_1.serialize(value);
                        return { className: className, serializeData: serializeData };
                    case editor.EditType.SHADER:
                        return value.url;
                    case editor.EditType.LIST:
                        return value;
                    case editor.EditType.MATERIAL_ARRAY:
                        var data = value.map(function (item) {
                            var url = item.url.substr(RES.config.config.resourceRoot.length, item.url.length);
                            return { name: url, url: url };
                        });
                        return data;
                    case editor.EditType.MESH:
                        var url = value.glTFAsset.url;
                        url = url.substr(RES.config.config.resourceRoot.length, url.length);
                        return url;
                    case editor.EditType.MATERIAL:
                    case editor.EditType.GAMEOBJECT:
                    case editor.EditType.TRANSFROM:
                    case editor.EditType.SOUND:
                    case editor.EditType.ARRAY:
                        //TODO
                        console.error("not supported!");
                        break;
                    default:
                        break;
                }
            };
            EditorModel.prototype.deserializeProperty = function (serializeData, editType) {
                return __awaiter(this, void 0, void 0, function () {
                    var _a, clazz, target, url, asset, materials, _i, serializeData_1, matrial, asset_1, meshAsset, mesh;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _a = editType;
                                switch (_a) {
                                    case editor.EditType.NUMBER: return [3 /*break*/, 1];
                                    case editor.EditType.TEXT: return [3 /*break*/, 1];
                                    case editor.EditType.CHECKBOX: return [3 /*break*/, 1];
                                    case editor.EditType.VECTOR2: return [3 /*break*/, 2];
                                    case editor.EditType.VECTOR3: return [3 /*break*/, 2];
                                    case editor.EditType.VECTOR4: return [3 /*break*/, 2];
                                    case editor.EditType.QUATERNION: return [3 /*break*/, 2];
                                    case editor.EditType.COLOR: return [3 /*break*/, 2];
                                    case editor.EditType.RECT: return [3 /*break*/, 2];
                                    case editor.EditType.SHADER: return [3 /*break*/, 3];
                                    case editor.EditType.LIST: return [3 /*break*/, 5];
                                    case editor.EditType.MATERIAL_ARRAY: return [3 /*break*/, 6];
                                    case editor.EditType.MESH: return [3 /*break*/, 11];
                                    case editor.EditType.MATERIAL: return [3 /*break*/, 13];
                                    case editor.EditType.GAMEOBJECT: return [3 /*break*/, 13];
                                    case editor.EditType.TRANSFROM: return [3 /*break*/, 13];
                                    case editor.EditType.SOUND: return [3 /*break*/, 13];
                                    case editor.EditType.ARRAY: return [3 /*break*/, 13];
                                }
                                return [3 /*break*/, 14];
                            case 1: return [2 /*return*/, serializeData];
                            case 2:
                                clazz = egret.getDefinitionByName(serializeData.className);
                                target = null;
                                if (clazz) {
                                    target = new clazz();
                                    target.deserialize(serializeData.serializeData.objects[0]);
                                }
                                return [2 /*return*/, target];
                            case 3:
                                url = serializeData;
                                return [4 /*yield*/, RES.getResAsync(url)];
                            case 4:
                                asset = _b.sent();
                                return [2 /*return*/, asset];
                            case 5: return [2 /*return*/, serializeData];
                            case 6:
                                materials = [];
                                _i = 0, serializeData_1 = serializeData;
                                _b.label = 7;
                            case 7:
                                if (!(_i < serializeData_1.length)) return [3 /*break*/, 10];
                                matrial = serializeData_1[_i];
                                return [4 /*yield*/, RES.getResAsync(matrial.url)];
                            case 8:
                                asset_1 = _b.sent();
                                materials.push(asset_1);
                                _b.label = 9;
                            case 9:
                                _i++;
                                return [3 /*break*/, 7];
                            case 10: return [2 /*return*/, materials];
                            case 11: return [4 /*yield*/, RES.getResAsync(serializeData)];
                            case 12:
                                meshAsset = _b.sent();
                                mesh = new egret3d.Mesh(meshAsset, 0);
                                return [2 /*return*/, mesh];
                            case 13:
                                //TODO
                                console.error("not supported!");
                                return [2 /*return*/, null];
                            case 14: return [3 /*break*/, 15];
                            case 15: return [2 /*return*/];
                        }
                    });
                });
            };
            EditorModel.prototype.createGameObject = function (parentUUids) {
                var datas = [];
                for (var index = 0; index < parentUUids.length; index++) {
                    var parentUUid = parentUUids[index];
                    datas.push({ parentUUid: parentUUid });
                }
                var data = {
                    cmdType: CmdType.ADD_GAMEOBJECT,
                    datas: datas,
                };
                var state = editor.AddGameObjectState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.addComponent = function (gameObjectUUid, compClzName) {
                var data = {
                    cmdType: CmdType.ADD_COMPONENT,
                    gameObjectUUid: gameObjectUUid,
                    compClzName: compClzName
                };
                var state = editor.AddComponentState.create(data);
                this.addState(state);
            };
            /**
            *  TODO:因gameobject未提供通过组件实例添加组件的方法，暂时这样处理
            * @param gameObject
            * @param component
            */
            EditorModel.prototype.addComponentToGameObject = function (gameObject, component) {
                var components = gameObject.components;
                components.push(component);
                component.initialize();
                if (component.isActiveAndEnabled) {
                    paper.EventPool.dispatchEvent("__enabled__" /* Enabled */, component);
                }
            };
            EditorModel.prototype.removeComponent = function (gameObjectUUid, componentUUid) {
                var obj = this.getGameObjectByUUid(gameObjectUUid);
                if (!obj) {
                    return;
                }
                var removeComponent = this.getComponentById(obj, componentUUid);
                if (!removeComponent) {
                    return;
                }
                var serializeData = paper_1.serialize(removeComponent);
                var assetsMap = {};
                if (serializeData["assets"]) {
                    serializeData["assets"].forEach(function (item) {
                        assetsMap[item.uuid] = paper_1.Asset.find(item["url"]);
                    });
                }
                var data = {
                    cmdType: CmdType.REMOVE_COMPONENT,
                    gameObjectUUid: gameObjectUUid,
                    componentUUid: componentUUid,
                    serializeData: serializeData,
                    assetsMap: assetsMap
                };
                var state = editor.RemoveComponentState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.getComponentById = function (gameObject, componentId) {
                for (var i = 0; i < gameObject.components.length; i++) {
                    var comp = gameObject.components[i];
                    if (comp.uuid === componentId) {
                        return comp;
                    }
                }
                return null;
            };
            EditorModel.prototype.getComponentByAssetId = function (gameObject, assetId) {
                for (var i = 0; i < gameObject.components.length; i++) {
                    var comp = gameObject.components[i];
                    if (comp.assetUUid === assetId) {
                        return comp;
                    }
                }
                return null;
                ;
            };
            EditorModel.prototype.pasteGameObject = function (target) {
                if (target === void 0) { target = null; }
                var clipboard = __global.runtimeModule.getClipborad();
                var msg = clipboard.readText("paper");
                var content = JSON.parse(msg);
                var gameObjects = [];
                var ids = content.map(function (obj, index) { return (obj.uuid); });
                gameObjects = this.getGameObjectsByUUids(ids);
                this.unique(gameObjects);
                var datas = [];
                for (var index = 0; index < gameObjects.length; index++) {
                    var element = gameObjects[index];
                    var data_1 = {};
                    var gameObj = element;
                    data_1["parentUUid"] = gameObj.uuid;
                    datas.push(data_1);
                }
                var prefabData = this.getPrefabDataForDuplicate(gameObjects);
                var data = {
                    cmdType: CmdType.PASTE_GAMEOBJECTS,
                    datas: datas,
                    target: target,
                    prefabData: prefabData,
                    selectIds: ids
                };
                var state = editor.PasteGameObjectsState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.duplicateGameObjects = function (gameObjects) {
                var selectIds = gameObjects.map(function (gameObj) { return gameObj.uuid; });
                this.unique(gameObjects);
                var datas = [];
                for (var index = 0; index < gameObjects.length; index++) {
                    var element = gameObjects[index];
                    var one = {};
                    one["duplicateUUid"] = element.uuid;
                    datas.push(one);
                }
                var prefabData = this.getPrefabDataForDuplicate(gameObjects);
                var data = {
                    cmdType: CmdType.DUPLICATE_GAMEOBJECTS,
                    datas: datas,
                    prefabData: prefabData,
                    selectIds: selectIds,
                };
                var state = editor.DuplicateGameObjectsState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.getPrefabDataForDuplicate = function (gameObjects) {
                var prefabData = [];
                for (var index = 0; index < gameObjects.length; index++) {
                    var element = gameObjects[index];
                    var uniqueIndex = 0;
                    var prefabstru = {};
                    var allRootObjsUUid = [];
                    this.getPrefabRootObjsUUidFromGameObject(element, allRootObjsUUid);
                    this.getPrefabDataFromGameObject(element, uniqueIndex, prefabstru, allRootObjsUUid);
                    prefabData.push(prefabstru);
                }
                return prefabData;
            };
            /**
             * 设置克隆对象的prefab信息
             * @param gameObj
             * @param prefabData
             * @param uniqueIndex
             */
            EditorModel.prototype.duplicatePrefabDataToGameObject = function (gameObj, prefabData, uniqueIndex) {
                if (!gameObj)
                    return;
                if (prefabData[uniqueIndex]) {
                    var _a = prefabData[uniqueIndex], url = _a.url, isPrefabRoot = _a.isPrefabRoot;
                    var prefab = paper_1.Asset.find(url);
                    gameObj.prefab = prefab;
                    if (isPrefabRoot) {
                        gameObj.prefabEditInfo = true;
                    }
                    else {
                        var rootObj = this.getPrefabRootObjByChild(gameObj);
                        if (rootObj !== null) {
                            gameObj.prefabEditInfo = rootObj.uuid;
                        }
                    }
                }
                else {
                    gameObj.prefab = null;
                    gameObj.prefabEditInfo = null;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    uniqueIndex++;
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    this.duplicatePrefabDataToGameObject(obj, prefabData, uniqueIndex);
                }
            };
            /**
             * 收集prefab信息，用于duplicate或者paste后设置新对象的prefab信息
             * @param gameObject
             * @param index
             * @param prefabData
             */
            EditorModel.prototype.getPrefabDataFromGameObject = function (gameObj, uniqueIndex, prefabData, allRootObjsUUid) {
                if (!gameObj)
                    return;
                if ((editor.Editor.editorModel.isPrefabRoot(gameObj) && allRootObjsUUid.indexOf(gameObj.uuid) >= 0)
                    || (editor.Editor.editorModel.isPrefabChild(gameObj) && allRootObjsUUid.indexOf(gameObj.prefabEditInfo) >= 0)) {
                    var isPrefabRoot = editor.Editor.editorModel.isPrefabRoot(gameObj);
                    var url = gameObj.prefab.url;
                    prefabData[uniqueIndex] = { gameObj: gameObj, isPrefabRoot: isPrefabRoot, url: url };
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    uniqueIndex++;
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    this.getPrefabDataFromGameObject(obj, uniqueIndex, prefabData, allRootObjsUUid);
                }
            };
            /**
             * 获取某个游戏对象下所有预制体实例的根对象uuid,用于确定duplicate时选中的对象是否属于一个完整的预制体
             * @param gameObj
             * @param rootObjs
             */
            EditorModel.prototype.getPrefabRootObjsUUidFromGameObject = function (gameObj, rootObjsUUids) {
                if (!gameObj) {
                    return;
                }
                if (editor.Editor.editorModel.isPrefabRoot(gameObj)) {
                    rootObjsUUids.push(gameObj.uuid);
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    this.getPrefabRootObjsUUidFromGameObject(obj, rootObjsUUids);
                }
            };
            EditorModel.prototype.getPrefabRootObjByChild = function (gameObj) {
                var parent = gameObj.transform.parent;
                var findObj;
                while (parent) {
                    findObj = parent.gameObject;
                    if (editor.Editor.editorModel.isPrefabRoot(findObj)) {
                        return findObj;
                    }
                    parent = parent.parent;
                }
                return null;
            };
            EditorModel.prototype.deleteGameObject = function (gameObjects, prefabRootMap) {
                var selectIds = gameObjects.map(function (gameObj) { return gameObj.uuid; });
                this.unique(gameObjects);
                var datas = [];
                var indexData = [];
                var _loop_1 = function (index) {
                    var element = gameObjects[index];
                    var one = {};
                    var gameObj = element;
                    var serializeData = paper_1.serialize(gameObj);
                    one["deleteuuid"] = gameObj.uuid;
                    if (gameObj.transform.parent) {
                        one["parentUUid"] = gameObj.transform.parent.gameObject.uuid;
                        one["preIndex"] = gameObj.transform.parent.children.indexOf(gameObj.transform);
                        this_1.getAllRootIndexsFromGameObject(gameObj, indexData);
                    }
                    else {
                        this_1.getAllRootIndexsFromGameObject(gameObj, indexData);
                    }
                    one["serializeData"] = serializeData;
                    var assetsMap = {};
                    if (serializeData["assets"]) {
                        serializeData["assets"].forEach(function (item) {
                            assetsMap[item.uuid] = paper_1.Asset.find(item["url"]); // 获取资源引用
                        });
                    }
                    one["assetsMap"] = assetsMap;
                    datas.push(one);
                };
                var this_1 = this;
                for (var index = 0; index < gameObjects.length; index++) {
                    _loop_1(index);
                }
                indexData.sort(function (a, b) { return a.preIndex - b.preIndex; });
                var prefabData = {};
                for (var key in prefabRootMap) {
                    var rootObj = this.getGameObjectByUUid(prefabRootMap[key]);
                    if (rootObj) {
                        var url = rootObj.prefab.url;
                        var rootId = prefabRootMap[key];
                        var prefabIds = [];
                        this.getAllIdsFromPrefabInstance(rootObj, prefabIds, rootObj);
                        prefabData[key] = { url: url, rootId: rootId, prefabIds: prefabIds };
                    }
                }
                var data = {
                    cmdType: CmdType.REMOVE_GAMEOBJECTS,
                    datas: datas,
                    prefabData: prefabData,
                    selectIds: selectIds,
                    indexData: indexData
                };
                var state = editor.DeleteGameObjectsState.create(data);
                this.addState(state);
            };
            EditorModel.prototype._deleteGameObject = function (gameObjects) {
                for (var index = 0; index < gameObjects.length; index++) {
                    var element = gameObjects[index];
                    element.destroy();
                }
            };
            EditorModel.prototype.updateParent = function (gameObjectUUids, targetUUid, prefabRootMap) {
                var objs = this.getGameObjectsByUUids(gameObjectUUids);
                var originParentIds = [];
                for (var index = 0; index < objs.length; index++) {
                    var gameObj = objs[index];
                    var parentId = gameObj.transform.parent ? gameObj.transform.parent.gameObject.uuid : null;
                    originParentIds.push(parentId);
                }
                var prefabData = {};
                for (var key in prefabRootMap) {
                    var rootObj = this.getGameObjectByUUid(prefabRootMap[key]);
                    if (rootObj) {
                        var url = rootObj.prefab.url;
                        var rootId = prefabRootMap[key];
                        var prefabIds = [];
                        this.getAllIdsFromPrefabInstance(rootObj, prefabIds, rootObj);
                        prefabData[key] = { url: url, rootId: rootId, prefabIds: prefabIds };
                    }
                }
                var data = {
                    cmdType: CmdType.UPDATE_PARENT,
                    gameObjectUUids: gameObjectUUids,
                    targetUUid: targetUUid,
                    originParentIds: originParentIds,
                    prefabData: prefabData
                };
                var state = editor.UpdateParentState.create(data);
                this.addState(state);
            };
            /**
             * 清除预制体里游戏对象的prefab引用,root或者持有此root引用的游戏对象
             * @param rootId 预制体的根id
             */
            EditorModel.prototype.clearRootPrefabInstance = function (gameObj, rootObj) {
                if (!gameObj) {
                    return;
                }
                if (gameObj == rootObj || (this.isPrefabChild(gameObj))) {
                    gameObj.prefabEditInfo = null;
                    gameObj.prefab = null;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    this.clearRootPrefabInstance(obj, rootObj);
                }
            };
            /**
             * 还原prefab
             * @param rootObj
             * @param prefab
             */
            EditorModel.prototype.resetPrefabbyRootId = function (rootObj, prefab, prefabIds) {
                for (var index = 0; index < prefabIds.length; index++) {
                    var element = prefabIds[index];
                    if (element === rootObj.uuid) {
                        rootObj.prefabEditInfo = true;
                        rootObj.prefab = prefab;
                    }
                    else {
                        var gameObj = this.getGameObjectByUUid(element);
                        if (gameObj) {
                            gameObj.prefabEditInfo = rootObj.uuid;
                            gameObj.prefab = prefab;
                        }
                    }
                }
            };
            /**
             * 获取预制体实例包含的所有游戏对象id
             * @param rootObj
             * @param ids
             */
            EditorModel.prototype.getAllIdsFromPrefabInstance = function (gameObj, ids, rootObj) {
                if (!gameObj) {
                    return;
                }
                if (gameObj == rootObj || (this.isPrefabChild(gameObj) && gameObj.prefabEditInfo == rootObj.uuid)) {
                    ids.push(gameObj.uuid);
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    this.getAllIdsFromPrefabInstance(obj, ids, rootObj);
                }
            };
            /**
             * 去重
             * @param gameObjects
             */
            EditorModel.prototype.unique = function (gameObjects) {
                var findParent = false;
                var parent = null;
                for (var index = gameObjects.length - 1; index >= 0; index--) {
                    var element = gameObjects[index];
                    findParent = false;
                    parent = element.transform.parent;
                    while (parent) {
                        for (var i = 0; i < gameObjects.length; i++) {
                            var element_1 = gameObjects[i];
                            if (element_1.transform === parent) {
                                gameObjects.splice(index, 1);
                                findParent = true;
                                break;
                            }
                        }
                        if (findParent) {
                            break;
                        }
                        parent = parent.parent;
                    }
                }
            };
            EditorModel.prototype.getGameObjectByUUid = function (uuid) {
                var paper = this.backRunTime.paper;
                var objects = paper.Application.sceneManager.activeScene.gameObjects;
                for (var i = 0; i < objects.length; i++) {
                    if (objects[i].uuid === uuid) {
                        return objects[i];
                    }
                }
                paper = __global['paper'];
                objects = paper.Application.sceneManager.activeScene.gameObjects;
                for (var i = 0; i < objects.length; i++) {
                    if (objects[i].uuid === uuid) {
                        return objects[i];
                    }
                }
                return null;
            };
            EditorModel.prototype.getAssetByAssetUrl = function (url) {
                return __awaiter(this, void 0, void 0, function () {
                    var RES, asset;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                RES = this.backRunTime.RES;
                                return [4 /*yield*/, RES.getResAsync(url)];
                            case 1:
                                asset = _a.sent();
                                if (asset) {
                                    return [2 /*return*/, asset];
                                }
                                return [2 /*return*/, null];
                        }
                    });
                });
            };
            /**
             *
             * @param uuids unique id
             */
            EditorModel.prototype.getGameObjectsByUUids = function (uuids) {
                var objects = paper_1.Application.sceneManager.activeScene.gameObjects;
                var obj;
                var result = [];
                var idIndex;
                var cloneIds = uuids.concat();
                for (var i = 0; i < objects.length; i++) {
                    if (cloneIds.length == 0) {
                        return result;
                    }
                    obj = objects[i];
                    idIndex = cloneIds.indexOf(obj.uuid);
                    if (idIndex != -1) {
                        result.push(obj);
                        cloneIds.splice(idIndex, 1);
                    }
                }
                return result;
            };
            EditorModel.prototype.getAllRootIndexsFromGameObject = function (gameObject, indexData) {
                var objs = paper.Application.sceneManager.getActiveScene().gameObjects;
                indexData.push({ preIndex: objs.indexOf(gameObject), uuid: gameObject.uuid });
                for (var index = 0; index < gameObject.transform.children.length; index++) {
                    var element = gameObject.transform.children[index];
                    var obj = element.gameObject;
                    this.getAllRootIndexsFromGameObject(obj, indexData);
                }
            };
            EditorModel.prototype.getAllComponentUUidFromGameObject = function (gameObject, uuids) {
                for (var i = 0; i < gameObject.components.length; i++) {
                    var comp = gameObject.components[i];
                    uuids.push(comp.uuid);
                }
                for (var index = 0; index < gameObject.transform.children.length; index++) {
                    var element = gameObject.transform.children[index];
                    var obj = element.gameObject;
                    this.getAllComponentUUidFromGameObject(obj, uuids);
                }
            };
            /**
             * call after duplicate/create/paste
             * @param instance
             */
            EditorModel.prototype.generateGameobjectUUids = function (instance) {
                instance.uuid = editor.generateUuid();
                instance.components.forEach(function (component) {
                    component.uuid = editor.generateUuid();
                });
                for (var index = 0; index < instance.transform.children.length; index++) {
                    var element = instance.transform.children[index];
                    var obj = element.gameObject;
                    this.generateGameobjectUUids(obj);
                }
            };
            EditorModel.prototype.findOptionSetName = function (propName, target) {
                var editInfoList = editor.getEditInfo(target);
                for (var index = 0; index < editInfoList.length; index++) {
                    var element = editInfoList[index];
                    if (element.name === propName && element.option && element.option.set) {
                        return element.option.set;
                    }
                }
                var extraInfoList = editor.getExtraInfo(target);
                for (var index = 0; index < extraInfoList.length; index++) {
                    var element = extraInfoList[index];
                    if (element.name === propName && element.option && element.option.set) {
                        return element.option.set;
                    }
                }
                return null;
            };
            EditorModel.prototype.setTargetProperty = function (propName, target, value) {
                var setFunName = this.findOptionSetName(propName, target);
                if (setFunName !== null && target[setFunName]) {
                    target[setFunName].call(target, value);
                }
                else {
                    target[propName] = value;
                }
            };
            EditorModel.prototype.selectGameObject = function (selectObj, options) {
                if (selectObj[selectItemType.GAMEOBJECT] && options && options.addHistory && options.preIds) {
                    var selectUUids = selectObj[selectItemType.GAMEOBJECT];
                    var state = editor.SelectGameObjectesState.create({ cmdType: CmdType.SELECT_GAMEOBJECT, prevalue: options.preIds, newvalue: selectUUids });
                    this.paperHistory.add(state);
                }
                else {
                    this.dispatchEvent(new EditorModelEvent(EditorModelEvent.SELECT_GAMEOBJECTS, selectObj));
                }
            };
            // 切换场景，参数是场景编号
            EditorModel.prototype.switchScene = function (url) {
                var _this = this;
                paper_1.Application.sceneManager.unloadAllScene();
                paper_1.Application.callLater(function () {
                    _this.loadEditScene(url).then(function () {
                        _this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_SCENE, url));
                    });
                });
            };
            EditorModel.prototype.resetHistory = function (data) {
                var history = editor.HistoryUtil.deserialize(JSON.parse(data));
                this.paperHistory = history;
            };
            EditorModel.prototype.loadEditScene = function (url) {
                return __awaiter(this, void 0, void 0, function () {
                    var res, camera, script, pickScript;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, RES.getResAsync(url)];
                            case 1:
                                res = _a.sent();
                                paper_1.Application.sceneManager.loadScene(res.url);
                                camera = paper_1.GameObject.findWithTag("EditorCamera");
                                if (camera) {
                                    this._editCamera = camera;
                                }
                                else {
                                    this._editCamera = this.createEditCamera();
                                }
                                this.geoController = new editor.GeoController(this);
                                // 开启几何画板
                                editor.Gizmo.Enabled(this._editCamera);
                                script = this._editCamera.addComponent(editor.EditorCameraScript);
                                script.editorModel = this;
                                script.moveSpeed = 10;
                                script.rotateSpeed = 0.5;
                                pickScript = this._editCamera.addComponent(editor.PickGameObjectScript);
                                pickScript.editorModel = this;
                                this.geoController.cameraScript = script;
                                return [2 /*return*/];
                        }
                    });
                });
            };
            EditorModel.prototype.createEditCamera = function () {
                var cameraObject = new paper_1.GameObject();
                cameraObject.name = "EditorCamera";
                cameraObject.tag = "EditorCamera";
                var camera = cameraObject.addComponent(egret3d.Camera);
                camera.near = 0.1;
                camera.far = 100;
                camera.backgroundColor = new egret3d.Color(0.13, 0.28, 0.51, 1);
                cameraObject.transform.setLocalPosition(0, 10, -10);
                cameraObject.transform.lookAt(new egret3d.Vector3(0, 0, 0));
                return cameraObject;
            };
            /**
             * 切换编辑模式
             */
            EditorModel.prototype.changeEditMode = function (mode) {
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_EDIT_MODE, mode));
            };
            /**
             * 切换编辑类型
             */
            EditorModel.prototype.changeEditType = function (type) {
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_EDIT_TYPE, type));
            };
            /**
             * 序列化场景
             */
            EditorModel.prototype.serializeActiveScene = function () {
                var scene = paper_1.Application.sceneManager.activeScene;
                if (this._editCamera) {
                    scene._removeGameObject(this._editCamera);
                }
                var len = this.geoController.controllerPool.length;
                if (len > 0) {
                    for (var i = 0; i < len; i++) {
                        scene._removeGameObject(this.geoController.controllerPool[i]);
                    }
                }
                var data = paper_1.serialize(scene);
                if (len > 0) {
                    for (var i = 0; i < len; i++) {
                        scene._addGameObject(this.geoController.controllerPool[i]);
                    }
                }
                if (this._editCamera) {
                    scene._addGameObject(this._editCamera);
                }
                var jsonData = JSON.stringify(data);
                return jsonData;
            };
            EditorModel.prototype.createAssetMap = function (serializeData) {
                var assetsMap = {};
                if (serializeData["assets"]) {
                    serializeData["assets"].forEach(function (item) {
                        assetsMap[item.uuid] = paper_1.Asset.find(item["url"]);
                    });
                }
                return assetsMap;
            };
            EditorModel.prototype.isPrefabRoot = function (gameObj) {
                var prefabInfo = gameObj.prefabEditInfo;
                if (typeof (prefabInfo) == "boolean" && prefabInfo === true) {
                    return true;
                }
                return false;
            };
            EditorModel.prototype.isPrefabChild = function (gameObj) {
                var prefabInfo = gameObj.prefabEditInfo;
                if (typeof (prefabInfo) == "string") {
                    return true;
                }
                return false;
            };
            EditorModel.prototype.serializeHistory = function () {
                var historyData = editor.HistoryUtil.serialize(this.paperHistory);
                return JSON.stringify(historyData);
            };
            /**
    * 从一个预置体文件创建实例
    * @param prefabPath 预置体资源路径
    */
            EditorModel.prototype.createGameObjectFromPrefab = function (prefabPath, paper, RES) {
                return __awaiter(this, void 0, void 0, function () {
                    var prefab, instance;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, RES.getResAsync(prefabPath)];
                            case 1:
                                prefab = _a.sent();
                                if (prefab) {
                                    instance = prefab.createInstance();
                                    instance.prefabEditInfo = true;
                                    this.setGameObjectPrefab(instance, prefab, instance);
                                    return [2 /*return*/, instance];
                                }
                                return [2 /*return*/, null];
                        }
                    });
                });
            };
            /**
         * 设置children prefab属性
         * @param gameObj
         * @param prefab
         */
            EditorModel.prototype.setGameObjectPrefab = function (gameObj, prefab, rootObj) {
                if (!gameObj) {
                    return;
                }
                gameObj.prefab = prefab;
                if (gameObj != rootObj) {
                    gameObj.prefabEditInfo = rootObj.uuid;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    this.setGameObjectPrefab(obj, prefab, rootObj);
                }
            };
            return EditorModel;
        }(editor.EventDispatcher));
        editor.EditorModel = EditorModel;
        __reflect(EditorModel.prototype, "paper.editor.EditorModel");
    })(editor = paper_1.editor || (paper_1.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var helpVec3_1 = new egret3d.Vector3();
        var helpVec3_2 = new egret3d.Vector3();
        var helpVec3_3 = new egret3d.Vector3();
        var helpQuat_1 = new egret3d.Quaternion();
        var helpQuat_2 = new egret3d.Quaternion();
        var forward = new egret3d.Vector3(0, 0, 1);
        var up = new egret3d.Vector3(0, 1, 0);
        var right = new egret3d.Vector3(1, 0, 0);
        var DRAG_MODE;
        (function (DRAG_MODE) {
            DRAG_MODE[DRAG_MODE["NONE"] = 0] = "NONE";
            DRAG_MODE[DRAG_MODE["BALL"] = 1] = "BALL";
            DRAG_MODE[DRAG_MODE["X"] = 2] = "X";
            DRAG_MODE[DRAG_MODE["Y"] = 3] = "Y";
            DRAG_MODE[DRAG_MODE["Z"] = 4] = "Z";
            DRAG_MODE[DRAG_MODE["RotX"] = 5] = "RotX";
            DRAG_MODE[DRAG_MODE["RotY"] = 6] = "RotY";
            DRAG_MODE[DRAG_MODE["RotZ"] = 7] = "RotZ";
            DRAG_MODE[DRAG_MODE["ScaX"] = 8] = "ScaX";
            DRAG_MODE[DRAG_MODE["ScaY"] = 9] = "ScaY";
            DRAG_MODE[DRAG_MODE["ScaZ"] = 10] = "ScaZ";
        })(DRAG_MODE || (DRAG_MODE = {}));
        var GeoController = (function () {
            function GeoController(editorModel) {
                this.selectedGameObjs = [];
                this._isEditing = false;
                this._geoCtrlMode = "local";
                this._modeCanChange = true;
                this._geoCtrlType = "position";
                /**
                 * 几何操作逻辑
                 */
                this._dragMode = DRAG_MODE.NONE;
                this._dragOffset = new egret3d.Vector3();
                this._delta = new egret3d.Vector3();
                this._newPosition = new egret3d.Vector3();
                this._ctrlPos = new egret3d.Vector3();
                this._ctrlRot = new egret3d.Quaternion();
                this._dragPlanePoint = new egret3d.Vector3();
                this._dragPlaneNormal = new egret3d.Vector3();
                this._initRotation = new egret3d.Quaternion();
                this._oldLocalScale = new egret3d.Vector3();
                this.selectGameObjects = this._selectGameObjects.bind(this);
                this.changeProperty = this._changeProperty.bind(this);
                this.changeEditMode = this._changeEditMode.bind(this);
                this.changeEditType = this._changeEditType.bind(this);
                this.controllerPool = [];
                this.editorModel = editorModel;
                this._addGizmoController();
                this._addEventListener();
                this.bindMouse = egret3d.InputManager.mouse;
                this.bindKeyboard = egret3d.InputManager.keyboard;
            }
            Object.defineProperty(GeoController.prototype, "geoCtrlMode", {
                get: function () {
                    return this._geoCtrlMode;
                },
                set: function (value) {
                    this._geoCtrlMode = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(GeoController.prototype, "geoCtrlType", {
                get: function () {
                    return this._geoCtrlType;
                },
                set: function (value) {
                    this._geoCtrlType = value;
                },
                enumerable: true,
                configurable: true
            });
            GeoController.prototype.update = function () {
                // console.log(this.pCtrl);
                var len = this.selectedGameObjs.length;
                if (this.selectedGameObjs.length > 0) {
                    editor.Gizmo.DrawArrowXYZ(this.controller.transform);
                    if (this.bindKeyboard.wasPressed('DELETE')) {
                        this.editorModel.deleteGameObject(this.selectedGameObjs);
                        // EditorMessage.instance.DeleteGameObject(this._bindedGameObject);
                    }
                    if (this.selectedGameObjs.length == 1 && this.selectedGameObjs[0].getComponent(egret3d.Camera)) {
                        editor.Gizmo.DrawCameraSquare(this.selectedGameObjs[0], [1.0, 0.0, 1.0, 1.0]);
                    }
                }
                this.inputUpdate();
                if (this._isEditing) {
                    (this.geoCtrlMode == "world" || this.selectedGameObjs.length > 1) ? this.updateInWorldMode() : this.updateInLocalMode();
                }
                if (this.bindMouse.wasReleased(0)) {
                    this._dragMode = DRAG_MODE.NONE;
                    //this.cameraScript.enabled = true;
                    egret3d.Vector3.set(0, 0, 0, this._dragOffset);
                    egret3d.Vector3.set(0, 0, 0, this._dragPlanePoint);
                    egret3d.Vector3.set(0, 0, 0, this._dragPlaneNormal);
                    this.xScl.transform.setLocalPosition(2, 0, 0);
                    this.yScl.transform.setLocalPosition(0, 2, 0);
                    this.zScl.transform.setLocalPosition(0, 0, 2);
                }
            };
            GeoController.prototype.updateInLocalMode = function () {
                var _this = this;
                var len = this.selectedGameObjs.length;
                if (len <= 0)
                    return;
                var cameraObject = this.cameraScript.gameObject;
                var camera = cameraObject.getComponent(egret3d.Camera);
                var worldRotation = this.selectedGameObjs[0].transform.getRotation();
                var worldPosition = this.selectedGameObjs[0].transform.getPosition();
                if (this.bindMouse.wasPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                    //worldPosition = this.selectedGameObj.transform.getPosition();
                    //worldRotation = this.selectedGameObj.transform.getRotation();
                    var ray_1 = camera.createRayByScreen(this.bindMouse.position.x, this.bindMouse.position.y);
                    var pickInfoArray = egret3d.Ray.raycastAll(ray_1, true);
                    if (pickInfoArray && pickInfoArray.length > 0) {
                        pickInfoArray.forEach(function (pickInfo) {
                            var picked = pickInfo.transform.gameObject;
                            if (_this.geoCtrlType == "position" && (picked == _this.ball || picked == _this.xAxis || picked == _this.yAxis || picked == _this.zAxis)) {
                                egret3d.Vector3.copy(worldPosition, _this._dragPlanePoint);
                                if (picked == _this.ball) {
                                    _this._dragMode = DRAG_MODE.BALL;
                                    cameraObject.transform.getForward(_this._dragPlaneNormal);
                                }
                                else if (picked == _this.xAxis) {
                                    _this._dragMode = DRAG_MODE.X;
                                    egret3d.Quaternion.transformVector3(worldRotation, up, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.yAxis) {
                                    _this._dragMode = DRAG_MODE.Y;
                                    egret3d.Quaternion.transformVector3(worldRotation, forward, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.zAxis) {
                                    _this._dragMode = DRAG_MODE.Z;
                                    egret3d.Quaternion.transformVector3(worldRotation, up, _this._dragPlaneNormal);
                                }
                                _this._dragOffset = ray_1.intersectPlane(_this._dragPlanePoint, _this._dragPlaneNormal);
                                egret3d.Vector3.subtract(_this._dragOffset, worldPosition, _this._dragOffset);
                            }
                            else if (_this.geoCtrlType == "rotation" && (picked == _this.xRot || picked == _this.yRot || picked == _this.zRot)) {
                                egret3d.Vector3.copy(worldPosition, _this._dragPlanePoint);
                                if (picked == _this.xRot) {
                                    _this._dragMode = DRAG_MODE.RotX;
                                    egret3d.Quaternion.transformVector3(worldRotation, right, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.yRot) {
                                    _this._dragMode = DRAG_MODE.RotY;
                                    egret3d.Quaternion.transformVector3(worldRotation, up, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.zRot) {
                                    _this._dragMode = DRAG_MODE.RotY;
                                    egret3d.Quaternion.transformVector3(worldRotation, forward, _this._dragPlaneNormal);
                                }
                                _this._dragOffset = ray_1.intersectPlane(_this._dragPlanePoint, _this._dragPlaneNormal);
                                egret3d.Vector3.subtract(_this._dragOffset, worldPosition, _this._dragOffset);
                                egret3d.Quaternion.copy(worldRotation, _this._initRotation);
                            }
                            else if (_this.geoCtrlType == "scale" && (picked == _this.xScl || picked == _this.yScl || picked == _this.zScl)) {
                                egret3d.Vector3.copy(worldPosition, _this._dragPlanePoint);
                                if (picked == _this.xScl) {
                                    _this._dragMode = DRAG_MODE.ScaX;
                                    egret3d.Quaternion.transformVector3(worldRotation, up, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.yScl) {
                                    _this._dragMode = DRAG_MODE.ScaY;
                                    egret3d.Quaternion.transformVector3(worldRotation, forward, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.zScl) {
                                    _this._dragMode = DRAG_MODE.ScaZ;
                                    egret3d.Quaternion.transformVector3(worldRotation, up, _this._dragPlaneNormal);
                                }
                                egret3d.Vector3.copy(_this.selectedGameObjs[0].transform.getLocalScale(), _this._oldLocalScale);
                                _this._dragOffset = ray_1.intersectPlane(_this._dragPlanePoint, _this._dragPlaneNormal);
                                egret3d.Vector3.subtract(_this._dragOffset, worldPosition, _this._dragOffset);
                            }
                        });
                    }
                }
                if (this.bindMouse.isPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                    if (this.geoCtrlType == "position" && this._dragMode != DRAG_MODE.NONE) {
                        var screenPosition = this.bindMouse.position;
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                        egret3d.Vector3.subtract(hit, this._dragOffset, hit);
                        if (this._dragMode == DRAG_MODE.BALL) {
                            this.editorModel.setProperty("position", hit, this.selectedGameObjs[0].transform);
                            egret3d.Vector3.copy(hit, this._ctrlPos);
                            //this.selectedGameObj.transform.setPosition(hit);
                        }
                        else {
                            egret3d.Vector3.subtract(hit, worldPosition, hit);
                            var worldOffset = void 0;
                            if (this._dragMode == DRAG_MODE.X) {
                                worldOffset = egret3d.Quaternion.transformVector3(worldRotation, right, helpVec3_1);
                            }
                            else if (this._dragMode == DRAG_MODE.Y) {
                                worldOffset = egret3d.Quaternion.transformVector3(worldRotation, up, helpVec3_1);
                            }
                            else if (this._dragMode == DRAG_MODE.Z) {
                                worldOffset = egret3d.Quaternion.transformVector3(worldRotation, forward, helpVec3_1);
                            }
                            var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                            egret3d.Vector3.scale(worldOffset, cosHit);
                            var position = egret3d.Vector3.add(worldPosition, worldOffset, helpVec3_2);
                            egret3d.Vector3.copy(position, this._ctrlPos);
                            this.editorModel.setProperty("position", position, this.selectedGameObjs[0].transform);
                        }
                    }
                    else if (this.geoCtrlType == "rotation" && this._dragMode != DRAG_MODE.NONE) {
                        var screenPosition = this.bindMouse.position;
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                        egret3d.Vector3.subtract(hit, worldPosition, hit);
                        var cosHitOffset = egret3d.Vector3.dot(egret3d.Vector3.normalize(hit), egret3d.Vector3.normalize(this._dragOffset));
                        egret3d.Vector3.cross(this._dragOffset, hit, helpVec3_1);
                        var theta = egret3d.Vector3.dot(helpVec3_1, this._dragPlaneNormal) >= 0 ? Math.acos(cosHitOffset) : -Math.acos(cosHitOffset);
                        var cos = Math.cos(theta * 0.5), sin = Math.sin(theta * 0.5);
                        egret3d.Quaternion.set(this._dragPlaneNormal.x * sin, this._dragPlaneNormal.y * sin, this._dragPlaneNormal.z * sin, cos, helpQuat_1);
                        egret3d.Quaternion.multiply(helpQuat_1, this._initRotation, helpQuat_2);
                        egret3d.Quaternion.copy(helpQuat_2, this._ctrlRot);
                        this.editorModel.setProperty("rotation", helpQuat_2, this.selectedGameObjs[0].transform);
                    }
                    else if (this.geoCtrlType == "scale" && this._dragMode != DRAG_MODE.NONE) {
                        var screenPosition = this.bindMouse.position;
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                        egret3d.Vector3.subtract(hit, worldPosition, hit);
                        var worldOffset = void 0;
                        var scale = void 0;
                        if (this._dragMode == DRAG_MODE.ScaX) {
                            worldOffset = egret3d.Quaternion.transformVector3(worldRotation, right, helpVec3_1);
                            var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                            var len_1 = egret3d.Vector3.dot(this._dragOffset, worldOffset);
                            this.xScl.transform.setLocalPosition(cosHit / len_1 * 2, 0, 0);
                        }
                        else if (this._dragMode == DRAG_MODE.ScaY) {
                            worldOffset = egret3d.Quaternion.transformVector3(worldRotation, up, helpVec3_1);
                            var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                            var len_2 = egret3d.Vector3.dot(this._dragOffset, worldOffset);
                            this.yScl.transform.setLocalPosition(0, cosHit / len_2 * 2, 0);
                        }
                        else if (this._dragMode == DRAG_MODE.ScaZ) {
                            worldOffset = egret3d.Quaternion.transformVector3(worldRotation, forward, helpVec3_1);
                            var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                            var len_3 = egret3d.Vector3.dot(this._dragOffset, worldOffset);
                            this.zScl.transform.setLocalPosition(0, 0, cosHit / len_3 * 2);
                        }
                        var oldScale = this._oldLocalScale;
                        var sx = this.xScl.transform.getLocalPosition().x / 2;
                        var sy = this.yScl.transform.getLocalPosition().y / 2;
                        var sz = this.zScl.transform.getLocalPosition().z / 2;
                        scale = egret3d.Vector3.set(oldScale.x * sx, oldScale.y * sy, oldScale.z * sz, helpVec3_2);
                        this.editorModel.setProperty("localScale", scale, this.selectedGameObjs[0].transform);
                    }
                }
            };
            GeoController.prototype.updateInWorldMode = function () {
                var _this = this;
                var len = this.selectedGameObjs.length;
                if (len <= 0)
                    return;
                var cameraObject = this.cameraScript.gameObject;
                var camera = cameraObject.getComponent(egret3d.Camera);
                if (this.bindMouse.wasPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                    var ctrlPos_1 = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                    for (var i = 0; i < len; i++) {
                        var obj = this.selectedGameObjs[i];
                        egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos_1, ctrlPos_1);
                    }
                    ctrlPos_1 = egret3d.Vector3.scale(ctrlPos_1, 1 / len);
                    var ctrlRot_1 = this.controller.transform.getRotation();
                    this._ctrlRot = ctrlRot_1;
                    var ray_2 = camera.createRayByScreen(this.bindMouse.position.x, this.bindMouse.position.y);
                    var pickInfoArray = egret3d.Ray.raycastAll(ray_2, true);
                    if (pickInfoArray && pickInfoArray.length > 0) {
                        pickInfoArray.forEach(function (pickInfo) {
                            var picked = pickInfo.transform.gameObject;
                            if (_this.geoCtrlType == "position" && (picked == _this.ball || picked == _this.xAxis || picked == _this.yAxis || picked == _this.zAxis)) {
                                egret3d.Vector3.copy(ctrlPos_1, _this._dragPlanePoint);
                                if (picked == _this.ball) {
                                    _this._dragMode = DRAG_MODE.BALL;
                                    cameraObject.transform.getForward(_this._dragPlaneNormal);
                                }
                                else if (picked == _this.xAxis) {
                                    _this._dragMode = DRAG_MODE.X;
                                    egret3d.Vector3.copy(up, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.yAxis) {
                                    _this._dragMode = DRAG_MODE.Y;
                                    egret3d.Vector3.copy(forward, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.zAxis) {
                                    _this._dragMode = DRAG_MODE.Z;
                                    egret3d.Vector3.copy(up, _this._dragPlaneNormal);
                                }
                                _this._dragOffset = ray_2.intersectPlane(_this._dragPlanePoint, _this._dragPlaneNormal);
                            }
                            else if (_this.geoCtrlType == "rotation" && (picked == _this.xRot || picked == _this.yRot || picked == _this.zRot)) {
                                egret3d.Vector3.copy(ctrlPos_1, _this._dragPlanePoint);
                                //let ctrlRot = this.controller.transform.getRotation();
                                //this._ctrlRot = ctrlRot;
                                if (picked == _this.xRot) {
                                    _this._dragMode = DRAG_MODE.RotX;
                                    egret3d.Quaternion.transformVector3(ctrlRot_1, right, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.yRot) {
                                    _this._dragMode = DRAG_MODE.RotY;
                                    egret3d.Quaternion.transformVector3(ctrlRot_1, up, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.zRot) {
                                    _this._dragMode = DRAG_MODE.RotZ;
                                    egret3d.Quaternion.transformVector3(ctrlRot_1, forward, _this._dragPlaneNormal);
                                }
                                _this._dragOffset = ray_2.intersectPlane(_this._dragPlanePoint, _this._dragPlaneNormal);
                                egret3d.Vector3.subtract(_this._dragOffset, _this._ctrlPos, _this._dragOffset);
                                egret3d.Vector3.normalize(_this._dragOffset);
                            }
                            else if (_this.geoCtrlType == "scale" && (picked == _this.xScl || picked == _this.yScl || picked == _this.zScl)) {
                                egret3d.Vector3.copy(ctrlPos_1, _this._dragPlanePoint);
                                if (picked == _this.xScl) {
                                    _this._dragMode = DRAG_MODE.ScaX;
                                    egret3d.Quaternion.transformVector3(ctrlRot_1, up, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.yScl) {
                                    _this._dragMode = DRAG_MODE.ScaY;
                                    egret3d.Quaternion.transformVector3(ctrlRot_1, forward, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.zScl) {
                                    _this._dragMode = DRAG_MODE.ScaZ;
                                    egret3d.Quaternion.transformVector3(ctrlRot_1, up, _this._dragPlaneNormal);
                                }
                                _this._dragOffset = ray_2.intersectPlane(_this._dragPlanePoint, _this._dragPlaneNormal);
                            }
                        });
                    }
                }
                if (this.bindMouse.isPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                    if (this.geoCtrlType == "position" && this._dragMode != DRAG_MODE.NONE) {
                        var screenPosition = this.bindMouse.position;
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                        egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                        var worldOffset = void 0;
                        if (this._dragMode == DRAG_MODE.BALL) {
                            worldOffset = egret3d.Vector3.copy(this._delta, helpVec3_1);
                        }
                        else {
                            if (this._dragMode == DRAG_MODE.X) {
                                worldOffset = egret3d.Vector3.copy(right, helpVec3_1);
                            }
                            else if (this._dragMode == DRAG_MODE.Y) {
                                worldOffset = egret3d.Vector3.copy(up, helpVec3_1);
                            }
                            else if (this._dragMode == DRAG_MODE.Z) {
                                worldOffset = egret3d.Vector3.copy(forward, helpVec3_1);
                            }
                            var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                            egret3d.Vector3.scale(worldOffset, cosHit);
                        }
                        egret3d.Vector3.add(this._ctrlPos, worldOffset, this._ctrlPos);
                        for (var i = 0; i < len; i++) {
                            var obj = this.selectedGameObjs[i];
                            var lastPos = obj.transform.getPosition();
                            egret3d.Vector3.add(lastPos, worldOffset, this._newPosition);
                            this.editorModel.setProperty("position", this._newPosition, obj.transform);
                        }
                        egret3d.Vector3.copy(hit, this._dragOffset);
                    }
                    else if (this.geoCtrlType == "rotation" && this._dragMode != DRAG_MODE.NONE) {
                        var screenPosition = this.bindMouse.position;
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                        egret3d.Vector3.subtract(hit, this._ctrlPos, hit);
                        egret3d.Vector3.normalize(hit);
                        var cosHitOffset = egret3d.Vector3.dot(hit, this._dragOffset);
                        cosHitOffset = egret3d.floatClamp(cosHitOffset, -1, 1);
                        egret3d.Vector3.cross(this._dragOffset, hit, helpVec3_1);
                        var theta = egret3d.Vector3.dot(helpVec3_1, this._dragPlaneNormal) >= 0 ? Math.acos(cosHitOffset) : -Math.acos(cosHitOffset);
                        var cos = Math.cos(theta * 0.5), sin = Math.sin(theta * 0.5);
                        egret3d.Quaternion.set(this._dragPlaneNormal.x * sin, this._dragPlaneNormal.y * sin, this._dragPlaneNormal.z * sin, cos, helpQuat_1);
                        egret3d.Quaternion.multiply(helpQuat_1, this._ctrlRot, this._ctrlRot);
                        for (var i = 0; i < len; i++) {
                            var obj = this.selectedGameObjs[i];
                            var lastPos = obj.transform.getPosition();
                            var lastRot = obj.transform.getRotation();
                            egret3d.Quaternion.multiply(helpQuat_1, lastRot, helpQuat_2);
                            egret3d.Vector3.subtract(lastPos, this._ctrlPos, lastPos);
                            egret3d.Quaternion.transformVector3(helpQuat_1, lastPos, lastPos);
                            egret3d.Vector3.add(lastPos, this._ctrlPos, lastPos);
                            this.editorModel.setProperty("rotation", helpQuat_2, obj.transform);
                            this.editorModel.setProperty("position", lastPos, obj.transform);
                        }
                        egret3d.Vector3.copy(hit, this._dragOffset);
                    }
                    else if (this.geoCtrlType == "scale" && this._dragMode != DRAG_MODE.NONE) {
                        var screenPosition = this.bindMouse.position;
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                        egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                        var worldOffset = void 0;
                        var scale = void 0;
                        if (this._dragMode == DRAG_MODE.ScaX) {
                            worldOffset = egret3d.Quaternion.transformVector3(this._ctrlRot, right, helpVec3_1);
                            var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                            var src = this.xScl.transform.getLocalPosition().x;
                            this.xScl.transform.setLocalPosition(cosHit + src, 0, 0);
                            var s = cosHit / src + 1;
                            for (var i = 0; i < len; i++) {
                                var lastSca = this.selectedGameObjs[i].transform.getLocalScale();
                                scale = egret3d.Vector3.set(lastSca.x * s, lastSca.y, lastSca.z, helpVec3_2);
                                this.editorModel.setProperty("localScale", scale, this.selectedGameObjs[i].transform);
                                var pos = this.selectedGameObjs[i].transform.getPosition();
                                var sub = egret3d.Vector3.subtract(pos, this._ctrlPos, helpVec3_2);
                                egret3d.Quaternion.transformVector3(this.controller.transform.getRotation(), right, helpVec3_3);
                                var cos = egret3d.Vector3.dot(sub, helpVec3_3);
                                egret3d.Vector3.scale(helpVec3_3, cos * (s - 1));
                                egret3d.Vector3.add(pos, helpVec3_3, pos);
                                this.editorModel.setProperty("position", pos, this.selectedGameObjs[i].transform);
                            }
                        }
                        else if (this._dragMode == DRAG_MODE.ScaY) {
                            worldOffset = egret3d.Quaternion.transformVector3(this._ctrlRot, up, helpVec3_1);
                            var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                            var src = this.yScl.transform.getLocalPosition().y;
                            this.yScl.transform.setLocalPosition(0, cosHit + src, 0);
                            var s = cosHit / src + 1;
                            for (var i = 0; i < len; i++) {
                                var lastSca = this.selectedGameObjs[i].transform.getLocalScale();
                                scale = egret3d.Vector3.set(lastSca.x, lastSca.y * s, lastSca.z, helpVec3_2);
                                this.editorModel.setProperty("localScale", scale, this.selectedGameObjs[i].transform);
                                var pos = this.selectedGameObjs[i].transform.getPosition();
                                var sub = egret3d.Vector3.subtract(pos, this._ctrlPos, helpVec3_2);
                                egret3d.Quaternion.transformVector3(this.controller.transform.getRotation(), up, helpVec3_3);
                                var cos = egret3d.Vector3.dot(sub, helpVec3_3);
                                egret3d.Vector3.scale(helpVec3_3, cos * (s - 1));
                                egret3d.Vector3.add(pos, helpVec3_3, pos);
                                this.editorModel.setProperty("position", pos, this.selectedGameObjs[i].transform);
                            }
                        }
                        else if (this._dragMode == DRAG_MODE.ScaZ) {
                            worldOffset = egret3d.Quaternion.transformVector3(this._ctrlRot, forward, helpVec3_1);
                            var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                            var src = this.zScl.transform.getLocalPosition().z;
                            this.zScl.transform.setLocalPosition(0, 0, cosHit + src);
                            var s = cosHit / src + 1;
                            for (var i = 0; i < len; i++) {
                                var lastSca = this.selectedGameObjs[i].transform.getLocalScale();
                                scale = egret3d.Vector3.set(lastSca.x, lastSca.y, lastSca.z * s, helpVec3_2);
                                this.editorModel.setProperty("localScale", scale, this.selectedGameObjs[i].transform);
                                var pos = this.selectedGameObjs[i].transform.getPosition();
                                var sub = egret3d.Vector3.subtract(pos, this._ctrlPos, helpVec3_2);
                                egret3d.Quaternion.transformVector3(this.controller.transform.getRotation(), forward, helpVec3_3);
                                var cos = egret3d.Vector3.dot(sub, helpVec3_3);
                                egret3d.Vector3.scale(helpVec3_3, cos * (s - 1));
                                egret3d.Vector3.add(pos, helpVec3_3, pos);
                                this.editorModel.setProperty("position", pos, this.selectedGameObjs[i].transform);
                            }
                        }
                        egret3d.Vector3.copy(hit, this._dragOffset);
                    }
                }
            };
            /**
             * 输入监听
             */
            GeoController.prototype.inputUpdate = function () {
                var mouse = this.bindMouse;
                var keyboard = this.bindKeyboard;
                if (keyboard.wasPressed("Q")) {
                    if (this.geoCtrlMode == "local") {
                        this.editorModel.changeEditMode("world");
                    }
                    else {
                        this.editorModel.changeEditMode("local");
                    }
                }
                if (keyboard.wasPressed("W")) {
                    this.editorModel.changeEditType("position");
                }
                if (keyboard.wasPressed("E")) {
                    this.editorModel.changeEditType("rotation");
                }
                if (keyboard.wasPressed("R")) {
                    this.editorModel.changeEditType("scale");
                }
                // 复制粘贴
                if (this.bindKeyboard.isPressed('CONTROL') && this.bindKeyboard.wasPressed('C')) {
                    var clipboard = __global.runtimeModule.getClipborad();
                    var content = [];
                    for (var i = 0, l = this.selectedGameObjs.length; i < l; i++) {
                        content.push({
                            type: "gameObject",
                            uuid: this.selectedGameObjs[i].uuid
                        });
                    }
                    var str = JSON.stringify(content);
                    clipboard.writeText(str, "paper");
                    console.log("copy");
                }
                if (this.bindKeyboard.isPressed('CONTROL') && this.bindKeyboard.wasPressed('V')) {
                    var parent_3 = this.selectedGameObjs.length > 0 ? this.selectedGameObjs[0].transform.parent : null;
                    this.editorModel.pasteGameObject(parent_3);
                }
                if (this.bindKeyboard.isPressed('CONTROL') && this.bindKeyboard.wasPressed('M')) {
                    this.editorModel.duplicateGameObjects(this.selectedGameObjs);
                }
            };
            /**
             * 添加监听事件
             */
            GeoController.prototype._addEventListener = function () {
                var _this = this;
                this.editorModel.addEventListener(editor.EditorModelEvent.SELECT_GAMEOBJECTS, function (e) { return _this.selectGameObjects(e.data); }, this);
                this.editorModel.addEventListener(editor.EditorModelEvent.CHANGE_EDIT_MODE, function (e) { return _this.changeEditMode(e.data); }, this);
                this.editorModel.addEventListener(editor.EditorModelEvent.CHANGE_EDIT_TYPE, function (e) { return _this.changeEditType(e.data); }, this);
                this.editorModel.addEventListener(editor.EditorModelEvent.CHANGE_PROPERTY, function (e) { return _this.changeProperty(e.data); }, this);
            };
            GeoController.prototype._selectGameObjects = function (selectObj) {
                var selectIds;
                if (selectObj[editor.selectItemType.GAMEOBJECT]) {
                    selectIds = selectObj[editor.selectItemType.GAMEOBJECT];
                }
                else {
                    selectIds = [];
                }
                this.selectedGameObjs = this.editorModel.getGameObjectsByUUids(selectIds);
                var len = this.selectedGameObjs.length;
                this._modeCanChange = true;
                if (len > 0) {
                    this._isEditing = true;
                    this.geoCtrlType = "position";
                    this.pCtrl.activeSelf = true;
                    this.rCtrl.activeSelf = false;
                    this.sCtrl.activeSelf = false;
                    this.controller.activeSelf = true;
                    if (len == 1) {
                        // console.log("select: " + this.selectedGameObjs[0].name);
                        this.controller.transform.setPosition(this.selectedGameObjs[0].transform.getPosition());
                        if (this.geoCtrlMode == "local") {
                            this.controller.transform.setRotation(this.selectedGameObjs[0].transform.getRotation());
                        }
                        else if (this.geoCtrlMode == "world") {
                            this.controller.transform.setRotation(0, 0, 0, 1);
                        }
                    }
                    else {
                        var ctrlPos = egret3d.Vector3.set(0, 0, 0, helpVec3_3);
                        for (var i = 0; i < len; i++) {
                            // console.log("select: " + i + " " + this.selectedGameObjs[i].name);
                            var obj = this.selectedGameObjs[i];
                            egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                        }
                        ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                        this.controller.transform.setPosition(ctrlPos);
                        this.controller.transform.setRotation(0, 0, 0, 1);
                        this.geoCtrlMode = "world";
                        this._modeCanChange = false;
                    }
                }
                else {
                    this._isEditing = false;
                    // console.log("select: null");
                    this.controller.activeSelf = false;
                }
            };
            GeoController.prototype._changeProperty = function (data) {
                if ((data.target instanceof egret3d.Transform) && data.propName && this.selectedGameObjs.length > 0) {
                    var propName = data.propName;
                    var target = data.target;
                    switch (propName) {
                        case "position":
                            this.controller.transform.setPosition(this._ctrlPos);
                            break;
                        case "rotation":
                            this.controller.transform.setRotation(this._ctrlRot);
                            break;
                        case "localPosition":
                            this._ctrlPos = this.selectedGameObjs[0].transform.getPosition();
                            this.controller.transform.setPosition(this._ctrlPos);
                            break;
                        case "localRotation":
                            this._ctrlRot = this.selectedGameObjs[0].transform.getRotation();
                            this.controller.transform.setRotation(this._ctrlRot);
                            break;
                        default:
                            break;
                    }
                }
                if (data.target instanceof paper.GameObject) {
                    var propName = data.propName;
                    console.log(propName);
                }
            };
            GeoController.prototype._changeEditMode = function (mode) {
                if (!this._modeCanChange) {
                    console.log("current mode: " + this.geoCtrlMode);
                    return;
                }
                this.geoCtrlMode = mode;
                var len = this.selectedGameObjs.length;
                if (len < 1)
                    return;
                if (this.geoCtrlType != "scale") {
                    switch (mode) {
                        case "local":
                            this.controller.transform.setRotation(this.selectedGameObjs[0].transform.getRotation());
                            break;
                        case "world":
                            this.controller.transform.setRotation(0, 0, 0, 1);
                            break;
                        default:
                            break;
                    }
                }
                console.log("current mode: " + this.geoCtrlMode);
            };
            GeoController.prototype._changeEditType = function (type) {
                if (this.geoCtrlType == type)
                    return;
                this.geoCtrlType = type;
                var len = this.selectedGameObjs.length;
                if (len < 1)
                    return;
                switch (type) {
                    case "position":
                        this.geoCtrlMode == "local" ? this.controller.transform.setRotation(this.selectedGameObjs[0].transform.getRotation()) : this.controller.transform.setRotation(this.controller.transform.getRotation());
                        this.pCtrl.activeSelf = true;
                        this.rCtrl.activeSelf = false;
                        this.sCtrl.activeSelf = false;
                        break;
                    case "rotation":
                        this.geoCtrlMode == "local" ? this.controller.transform.setRotation(this.selectedGameObjs[0].transform.getRotation()) : this.controller.transform.setRotation(this.controller.transform.getRotation());
                        this.pCtrl.activeSelf = false;
                        this.rCtrl.activeSelf = true;
                        this.sCtrl.activeSelf = false;
                        break;
                    case "scale":
                        if (len == 1) {
                            this.controller.transform.setRotation(this.selectedGameObjs[0].transform.getRotation());
                        }
                        else {
                            this.controller.transform.setRotation(this.controller.transform.getRotation());
                        }
                        this.pCtrl.activeSelf = false;
                        this.rCtrl.activeSelf = false;
                        this.sCtrl.activeSelf = true;
                        break;
                    default:
                        break;
                }
                console.log("current type: " + this.geoCtrlType);
            };
            GeoController.prototype._addGizmoController = function () {
                var controller = new paper.GameObject();
                controller.activeSelf = false;
                controller.name = "GizmoController";
                controller.tag = "Editor";
                var pcontroller = new paper.GameObject();
                pcontroller.activeSelf = true;
                pcontroller.name = "GizmoController_Position";
                pcontroller.tag = "Editor";
                pcontroller.transform.setParent(controller.transform);
                var rcontroller = new paper.GameObject();
                rcontroller.activeSelf = false;
                rcontroller.name = "GizmoController_Rotation";
                rcontroller.tag = "Editor";
                rcontroller.transform.setParent(controller.transform);
                var scontroller = new paper.GameObject();
                scontroller.activeSelf = false;
                scontroller.name = "GizmoController_Scale";
                scontroller.tag = "Editor";
                scontroller.transform.setParent(controller.transform);
                var ball = new paper.GameObject();
                ball.name = "GizmoController_Ball";
                ball.tag = "Editor";
                ball.transform.setParent(pcontroller.transform);
                ball.transform.setLocalScale(0.3, 0.3, 0.3);
                var mesh = ball.addComponent(egret3d.MeshFilter);
                mesh.mesh = egret3d.DefaultMeshes.SPHERE;
                var renderer = ball.addComponent(egret3d.MeshRenderer);
                var mat = new egret3d.Material();
                mat.setShader(egret3d.DefaultShaders.GIZMOS_COLOR);
                mat.setVector4v("_Color", [0.8, 0.8, 0.4, 0.1]);
                renderer.materials = [mat];
                var xAxis = this._createAxis(new egret3d.Vector4(0.8, 0.0, 0.0, 0.2), 0);
                xAxis.name = "GizmoController_X";
                xAxis.tag = "Editor";
                xAxis.transform.setParent(pcontroller.transform);
                xAxis.transform.setLocalScale(0.1, 2, 0.1);
                xAxis.transform.setLocalEulerAngles(0, 0, 90);
                xAxis.transform.setLocalPosition(1, 0, 0);
                var yAxis = this._createAxis(new egret3d.Vector4(0.0, 0.8, 0.0, 0.2), 0);
                yAxis.name = "GizmoController_Y";
                yAxis.tag = "Editor";
                yAxis.transform.setParent(pcontroller.transform);
                yAxis.transform.setLocalScale(0.1, 2, 0.1);
                yAxis.transform.setLocalEulerAngles(0, 0, 0);
                yAxis.transform.setLocalPosition(0, 1, 0);
                var zAxis = this._createAxis(new egret3d.Vector4(0.0, 0.0, 0.8, 0.2), 0);
                zAxis.name = "GizmoController_Z";
                zAxis.tag = "Editor";
                zAxis.transform.setParent(pcontroller.transform);
                zAxis.transform.setLocalScale(0.1, 2, 0.1);
                zAxis.transform.setLocalEulerAngles(90, 0, 0);
                zAxis.transform.setLocalPosition(0, 0, 1);
                var xRotate = this._createAxis(new egret3d.Vector4(0.8, 0.0, 0.0, 0.2), 1);
                xRotate.name = "GizmoController_Rotate_X";
                xRotate.tag = "Editor";
                xRotate.transform.setParent(rcontroller.transform);
                xRotate.transform.setLocalScale(3, 0.05, 3);
                xRotate.transform.setLocalEulerAngles(0, 0, -90);
                var yRotate = this._createAxis(new egret3d.Vector4(0.0, 0.8, 0.0, 0.2), 1);
                yRotate.name = "GizmoController_Rotate_Y";
                yRotate.tag = "Editor";
                yRotate.transform.setParent(rcontroller.transform);
                yRotate.transform.setLocalScale(3, 0.05, 3);
                yRotate.transform.setLocalEulerAngles(0, 0, 0);
                var zRotate = this._createAxis(new egret3d.Vector4(0.0, 0.0, 0.8, 0.2), 1);
                zRotate.name = "GizmoController_Rotate_Z";
                zRotate.tag = "Editor";
                zRotate.transform.setParent(rcontroller.transform);
                zRotate.transform.setLocalEulerAngles(90, 0, 0);
                zRotate.transform.setLocalScale(3, 0.05, 3);
                var xScale = this._createAxis(new egret3d.Vector4(0.8, 0.0, 0.0, 0.2), 2);
                xScale.name = "GizmoController_Scale_X";
                xScale.tag = "Editor";
                xScale.transform.setParent(scontroller.transform);
                xScale.transform.setLocalScale(0.2, 0.2, 0.2);
                xScale.transform.setLocalPosition(2, 0, 0);
                var yScale = this._createAxis(new egret3d.Vector4(0.0, 0.8, 0.0, 0.2), 2);
                yScale.name = "GizmoController_Scale_Y";
                yScale.tag = "Editor";
                yScale.transform.setParent(scontroller.transform);
                yScale.transform.setLocalScale(0.2, 0.2, 0.2);
                yScale.transform.setLocalPosition(0, 2, 0);
                var zScale = this._createAxis(new egret3d.Vector4(0.0, 0.0, 0.8, 0.2), 2);
                zScale.name = "GizmoController_Scale_Z";
                zScale.tag = "Editor";
                zScale.transform.setParent(scontroller.transform);
                zScale.transform.setLocalScale(0.2, 0.2, 0.2);
                zScale.transform.setLocalPosition(0, 0, 2);
                this.ball = ball;
                this.xAxis = xAxis;
                this.yAxis = yAxis;
                this.zAxis = zAxis;
                this.xRot = xRotate;
                this.yRot = yRotate;
                this.zRot = zRotate;
                this.xScl = xScale;
                this.yScl = yScale;
                this.zScl = zScale;
                this.pCtrl = pcontroller;
                this.rCtrl = rcontroller;
                this.sCtrl = scontroller;
                this.controller = controller;
                this.controllerPool = [controller, scontroller, rcontroller, pcontroller, zScale, yScale, xScale, zRotate, yRotate, xRotate, zAxis, yAxis, xAxis, ball];
            };
            /**
             * type 0:控制位置 1:控制旋转
             */
            GeoController.prototype._createAxis = function (color, type) {
                var gizmoAxis = new paper.GameObject();
                var mesh = gizmoAxis.addComponent(egret3d.MeshFilter);
                switch (type) {
                    case 0:
                        mesh.mesh = egret3d.DefaultMeshes.CYLINDER;
                        break;
                    case 1:
                        mesh.mesh = egret3d.DefaultMeshes.CYLINDER;
                        break;
                    case 2:
                        mesh.mesh = egret3d.DefaultMeshes.SPHERE;
                        break;
                }
                var renderer = gizmoAxis.addComponent(egret3d.MeshRenderer);
                var mat = new egret3d.Material();
                mat.setShader(egret3d.DefaultShaders.GIZMOS_COLOR);
                mat.setVector4v("_Color", [color.x, color.y, color.z, color.w]);
                renderer.materials = [mat];
                return gizmoAxis;
            };
            GeoController.prototype._removeGizmoController = function () {
                var gameObject = paper.GameObject.find("GizmoController");
                this.controller = null;
            };
            return GeoController;
        }());
        editor.GeoController = GeoController;
        __reflect(GeoController.prototype, "paper.editor.GeoController");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        editor.EventType = {
            HistoryState: "HistoryState",
            HistoryAdd: "HistoryAdd",
            HistoryFree: "HistoryFree"
        };
        var History = (function () {
            function History(serializeData) {
                this.dispatcher = null;
                this._locked = 0;
                this._index = -1;
                this._batchIndex = 0;
                this._states = [];
                this._batchStates = [];
                this._events = [];
                this._index = serializeData ? serializeData.index : -1;
                this._locked = serializeData ? serializeData.locked : 0;
                this._batchIndex = serializeData ? serializeData.batchIndex : 0;
                this._states = serializeData ? serializeData.states : [];
            }
            History.toString = function () {
                return "[class common.History]";
            };
            History.prototype._free = function () {
                if (this._states.length > this._index + 1) {
                    this._states.length = this._index + 1; // TODO release.
                    if (this.dispatcher) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryFree, null));
                    }
                }
            };
            History.prototype._doState = function (state, isUndo) {
                if (isUndo) {
                    state.undo();
                }
                else {
                    state.redo();
                }
                var d = isUndo ? "undo" : "redo";
                console.log(d, ":", state.data.cmdType, "data:", state.data);
                if (this.dispatcher && state.data) {
                    var data = { isUndo: isUndo, data: state.data };
                    this._events.push(data);
                }
                return state.batchIndex > 0 && (isUndo ? this._index >= 0 : this._index < this._states.length - 1);
            };
            History.prototype.back = function () {
                if (this._index < 0 || this._batchIndex > 0) {
                    return false;
                }
                this._locked |= 1;
                while (this._doState(this._states[this._index--], true)) {
                }
                if (this.dispatcher && this._events.length > 0) {
                    for (var _i = 0, _a = this._events; _i < _a.length; _i++) {
                        var event_1 = _a[_i];
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryState, event_1));
                    }
                    this._events.length = 0;
                }
                this._locked &= 2;
                return true;
            };
            History.prototype.forward = function () {
                if (this._index >= this._states.length - 1 || this._batchIndex > 0) {
                    return false;
                }
                this._locked |= 1;
                while (this._doState(this._states[++this._index], false)) {
                }
                if (this.dispatcher && this._events.length > 0) {
                    for (var _i = 0, _a = this._events; _i < _a.length; _i++) {
                        var event_2 = _a[_i];
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryState, event_2));
                    }
                    this._events.length = 0;
                }
                this._locked &= 2;
                return true;
            };
            History.prototype.go = function (index) {
                if (this._batchIndex > 0) {
                    return false;
                }
                var result = false;
                if (this._index < index) {
                    while (this._index !== index && this.forward()) {
                        result = true;
                    }
                }
                else {
                    while (this._index !== index && this.back()) {
                        result = true;
                    }
                }
                return result;
            };
            History.prototype.add = function (state) {
                if (this._locked !== 0) {
                    return;
                }
                if (this._batchIndex > 0) {
                    state.batchIndex = this._batchIndex;
                    this._batchStates.push(state);
                }
                else {
                    console.log("addstate:", this._index);
                    this._states[this._index + 1] = state;
                    if (this.dispatcher !== null) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryAdd, event));
                    }
                    this.forward();
                    this._free();
                }
            };
            History.prototype.beginBatch = function () {
                this._batchIndex++;
            };
            History.prototype.endBatch = function () {
                if (this._batchIndex === 0) {
                    return;
                }
                this._batchIndex--;
                if (this._batchIndex === 0) {
                    var index = this._index + 1;
                    for (var _i = 0, _a = this._batchStates; _i < _a.length; _i++) {
                        var state = _a[_i];
                        this._states[index++] = state;
                    }
                    if (this.dispatcher !== null) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryAdd, event));
                    }
                    this._batchStates.length = 0;
                    this.go(this._states.length - 1);
                }
            };
            History.prototype.getState = function (index) {
                return this._states[index];
            };
            Object.defineProperty(History.prototype, "enabled", {
                get: function () {
                    return this._locked === 0;
                },
                set: function (value) {
                    if (value) {
                        this._locked &= 1;
                    }
                    else {
                        this._locked |= 2;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "count", {
                get: function () {
                    return this._states.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "index", {
                get: function () {
                    return this._index;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "batchIndex", {
                get: function () {
                    return this._batchIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "locked", {
                get: function () {
                    return this._locked;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "states", {
                get: function () {
                    return this._states;
                },
                enumerable: true,
                configurable: true
            });
            return History;
        }());
        editor.History = History;
        __reflect(History.prototype, "paper.editor.History");
        var HistoryUtil = (function () {
            function HistoryUtil() {
            }
            HistoryUtil.serialize = function (history) {
                var states = history.states;
                var statesData = [];
                for (var index = 0; index < states.length; index++) {
                    var element = states[index];
                    var className = egret.getQualifiedClassName(element);
                    var data = {
                        className: className,
                        batchIndex: element.batchIndex,
                        data: element.data,
                        autoClear: element.autoClear,
                        isDone: element.isDone,
                    };
                    statesData.push(data);
                }
                var serializeHistory = {
                    index: history.index,
                    batchIndex: history.batchIndex,
                    locked: history.locked,
                    statesData: statesData,
                };
                return serializeHistory;
            };
            HistoryUtil.deserialize = function (serializeHistory) {
                var states = [];
                var statesData = serializeHistory.statesData;
                for (var index = 0; index < statesData.length; index++) {
                    var element = statesData[index];
                    var clazz = egret.getDefinitionByName(element.className);
                    var state = null;
                    if (clazz) {
                        state = new clazz();
                        state.batchIndex = element.batchIndex;
                        state.data = element.data;
                        state.autoClear = element.autoClear;
                        state.isDone = element.isDone;
                        states.push(state);
                    }
                }
                var initData = {
                    states: states,
                    index: serializeHistory.index,
                    batchIndex: serializeHistory.batchIndex,
                    locked: serializeHistory.locked,
                };
                return new History(initData);
            };
            return HistoryUtil;
        }());
        editor.HistoryUtil = HistoryUtil;
        __reflect(HistoryUtil.prototype, "paper.editor.HistoryUtil");
        var BaseState = (function () {
            function BaseState() {
                this.autoClear = false;
                this.batchIndex = 0;
                this.data = null;
                this._isDone = false;
            }
            BaseState.prototype.undo = function () {
                if (this._isDone) {
                    this._isDone = false;
                    return true;
                }
                return false;
            };
            BaseState.prototype.redo = function () {
                if (this._isDone) {
                    return false;
                }
                this._isDone = true;
                return true;
            };
            Object.defineProperty(BaseState.prototype, "isDone", {
                get: function () {
                    return this._isDone;
                },
                set: function (value) {
                    this._isDone = value;
                },
                enumerable: true,
                configurable: true
            });
            BaseState.prototype.dispatchEditorModelEvent = function (type, data) {
                editor.Editor.editorModel.dispatchEvent(new editor.EditorModelEvent(type, data));
            };
            return BaseState;
        }());
        editor.BaseState = BaseState;
        __reflect(BaseState.prototype, "paper.editor.BaseState");
        var ModifyGameObjectPropertyState = (function (_super) {
            __extends(ModifyGameObjectPropertyState, _super);
            function ModifyGameObjectPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyGameObjectPropertyState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new ModifyGameObjectPropertyState();
                state.data = data;
                return state;
            };
            ModifyGameObjectPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var preValue = this.data.preValue;
                    this.modifyProperty(preValue);
                    return true;
                }
                return false;
            };
            ModifyGameObjectPropertyState.prototype.modifyProperty = function (value) {
                return __awaiter(this, void 0, void 0, function () {
                    var _a, uuid, propName, editType, modifyObj, toValue;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _a = this.data, uuid = _a.uuid, propName = _a.propName, editType = _a.editType;
                                modifyObj = editor.Editor.editorModel.getGameObjectByUUid(uuid);
                                if (!(modifyObj && value !== undefined)) return [3 /*break*/, 2];
                                return [4 /*yield*/, editor.Editor.editorModel.deserializeProperty(value, editType)];
                            case 1:
                                toValue = _b.sent();
                                if (toValue !== null) {
                                    editor.Editor.editorModel.setTargetProperty(propName, modifyObj, toValue);
                                    this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: toValue });
                                }
                                _b.label = 2;
                            case 2: return [2 /*return*/];
                        }
                    });
                });
            };
            ModifyGameObjectPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var newValue = this.data.newValue;
                    this.modifyProperty(newValue);
                    return true;
                }
                return false;
            };
            return ModifyGameObjectPropertyState;
        }(BaseState));
        editor.ModifyGameObjectPropertyState = ModifyGameObjectPropertyState;
        __reflect(ModifyGameObjectPropertyState.prototype, "paper.editor.ModifyGameObjectPropertyState");
        //修改组件属性属性
        var ModifyComponentPropertyState = (function (_super) {
            __extends(ModifyComponentPropertyState, _super);
            function ModifyComponentPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyComponentPropertyState.toString = function () {
                return "[class common.ModifyComponentPropertyState]";
            };
            ModifyComponentPropertyState.create = function (source, key, value, data) {
                if (data === void 0) { data = null; }
                var state = new ModifyComponentPropertyState();
                state.data = data;
                return state;
            };
            ModifyComponentPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var preValue = this.data.preValue;
                    this.modifyProperty(preValue);
                    return true;
                }
                return false;
            };
            ModifyComponentPropertyState.prototype.modifyProperty = function (value) {
                return __awaiter(this, void 0, void 0, function () {
                    var _a, propName, componentUUid, gameObjectUUid, editType, gameObj, modifyObj, toValue;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _a = this.data, propName = _a.propName, componentUUid = _a.componentUUid, gameObjectUUid = _a.gameObjectUUid, editType = _a.editType;
                                gameObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                                if (gameObj) {
                                    modifyObj = editor.Editor.editorModel.getComponentById(gameObj, componentUUid);
                                }
                                if (!(modifyObj && value !== undefined)) return [3 /*break*/, 2];
                                return [4 /*yield*/, editor.Editor.editorModel.deserializeProperty(value, editType)];
                            case 1:
                                toValue = _b.sent();
                                if (toValue !== null) {
                                    editor.Editor.editorModel.setTargetProperty(propName, modifyObj, toValue);
                                    this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: toValue });
                                }
                                _b.label = 2;
                            case 2: return [2 /*return*/];
                        }
                    });
                });
            };
            ModifyComponentPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var newValue = this.data.newValue;
                    this.modifyProperty(newValue);
                    return true;
                }
                return false;
            };
            return ModifyComponentPropertyState;
        }(BaseState));
        editor.ModifyComponentPropertyState = ModifyComponentPropertyState;
        __reflect(ModifyComponentPropertyState.prototype, "paper.editor.ModifyComponentPropertyState");
        //选中游戏对象
        var SelectGameObjectesState = (function (_super) {
            __extends(SelectGameObjectesState, _super);
            function SelectGameObjectesState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            SelectGameObjectesState.toString = function () {
                return "[class common.SelectGameObjectesState]";
            };
            SelectGameObjectesState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new SelectGameObjectesState();
                state.data = data;
                return state;
            };
            SelectGameObjectesState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var preSelectids = this.data.prevalue;
                    var selectObjs = {};
                    selectObjs[editor.selectItemType.GAMEOBJECT] = preSelectids;
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.SELECT_GAMEOBJECTS, selectObjs);
                    return true;
                }
                return false;
            };
            SelectGameObjectesState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var newSelectids = this.data.newvalue;
                    var selectObjs = {};
                    selectObjs[editor.selectItemType.GAMEOBJECT] = newSelectids;
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.SELECT_GAMEOBJECTS, selectObjs);
                    return true;
                }
                return false;
            };
            return SelectGameObjectesState;
        }(BaseState));
        editor.SelectGameObjectesState = SelectGameObjectesState;
        __reflect(SelectGameObjectesState.prototype, "paper.editor.SelectGameObjectesState");
        //添加游戏对象
        var AddGameObjectState = (function (_super) {
            __extends(AddGameObjectState, _super);
            function AddGameObjectState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            AddGameObjectState.toString = function () {
                return "[class common.AddGameObjectState]";
            };
            AddGameObjectState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new AddGameObjectState();
                state.data = data;
                return state;
            };
            AddGameObjectState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var datas = this.data.datas;
                    var gameObjs = editor.Editor.editorModel.getGameObjectsByUUids(this.data.cacheGameObjectUUid);
                    editor.Editor.editorModel._deleteGameObject(gameObjs);
                    var selectUUids = datas.filter(function (data) {
                        if (data.parentUUid) {
                            return data.parentUUid;
                        }
                    });
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, selectUUids);
                    return true;
                }
                return false;
            };
            AddGameObjectState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var datas = this.data.datas;
                    var selectUUids = [];
                    for (var index = 0; index < datas.length; index++) {
                        var element = datas[index];
                        var parentUUid = element.parentUUid;
                        var gameObj = void 0;
                        if (element.serializeData) {
                            gameObj = paper.deserialize(element.serializeData, element.assetsMap);
                        }
                        else {
                            gameObj = new paper.GameObject();
                            gameObj.name = "NewGameObject";
                            element.serializeData = paper.serialize(gameObj);
                            element.assetsMap = editor.Editor.editorModel.createAssetMap(element.serializeData);
                        }
                        if (parentUUid) {
                            var parentGameObj = editor.Editor.editorModel.getGameObjectByUUid(parentUUid);
                            if (parentGameObj) {
                                gameObj.transform.setParent(parentGameObj.transform);
                            }
                        }
                        selectUUids.push(gameObj.uuid);
                    }
                    this.data.cacheGameObjectUUid = selectUUids.concat();
                    //select new objects
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, selectUUids);
                    return true;
                }
                return false;
            };
            return AddGameObjectState;
        }(BaseState));
        editor.AddGameObjectState = AddGameObjectState;
        __reflect(AddGameObjectState.prototype, "paper.editor.AddGameObjectState");
        //删除游戏对象
        var DeleteGameObjectsState = (function (_super) {
            __extends(DeleteGameObjectsState, _super);
            function DeleteGameObjectsState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            DeleteGameObjectsState.toString = function () {
                return "[class common.deleteGameObjectsState]";
            };
            DeleteGameObjectsState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new DeleteGameObjectsState();
                state.data = data;
                return state;
            };
            DeleteGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var _a = this.data, datas = _a.datas, prefabData = _a.prefabData, selectIds = _a.selectIds, indexData = _a.indexData;
                    var addObjs = [];
                    for (var index = 0; index < datas.length; index++) {
                        var element = datas[index];
                        var serializeData = element.serializeData;
                        var assetsMap = element.assetsMap;
                        var gameObj = paper.deserialize(serializeData, assetsMap);
                        addObjs.push(gameObj);
                    }
                    //reset index
                    for (var index = 0; index < datas.length; index++) {
                        var element = datas[index];
                        var parentUUid = element.parentUUid;
                        var preIndex = element.preIndex;
                        var gameObj = addObjs[index];
                        if (!gameObj) {
                            continue;
                        }
                        if (parentUUid) {
                            var parent_3 = editor.Editor.editorModel.getGameObjectByUUid(parentUUid);
                            if (parent_3) {
                                gameObj.transform.setParent(parent_3.transform);
                                gameObj.transform.parent.setChildIndex(gameObj.transform, preIndex);
                            }
                        }
                    }
                    for (var index = 0; index < indexData.length; index++) {
                        var element = indexData[index];
                        var preIndex = element.preIndex, uuid = element.uuid;
                        var allObjs = paper.Application.sceneManager.getActiveScene().gameObjects;
                        var gameObj = editor.Editor.editorModel.getGameObjectByUUid(uuid);
                        var currentIndex = allObjs.indexOf(gameObj);
                        if (currentIndex == preIndex || currentIndex < 0) {
                            return;
                        }
                        allObjs.splice(currentIndex, 1);
                        allObjs.splice(preIndex, 0, gameObj);
                    }
                    //prefab
                    for (var key in prefabData) {
                        var prefabRootId = prefabData[key].rootId;
                        var url = prefabData[key].url;
                        var prefabIds = prefabData[key].prefabIds;
                        var prefab = paper.Asset.find(url);
                        var rootObj = editor.Editor.editorModel.getGameObjectByUUid(prefabRootId);
                        if (rootObj) {
                            editor.Editor.editorModel.resetPrefabbyRootId(rootObj, prefab, prefabIds);
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, selectIds);
                    return true;
                }
                return false;
            };
            DeleteGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var _a = this.data, datas = _a.datas, prefabData = _a.prefabData;
                    var deleteObjs = [];
                    var deleteUUids = [];
                    for (var index = 0; index < datas.length; index++) {
                        var element = datas[index];
                        deleteUUids.push(element.deleteuuid);
                    }
                    //先处理预制体相关逻辑，再执行删除逻辑
                    for (var key in prefabData) {
                        var prefabRootId = prefabData[key].rootId;
                        var rootObj = editor.Editor.editorModel.getGameObjectByUUid(prefabRootId);
                        if (rootObj) {
                            editor.Editor.editorModel.clearRootPrefabInstance(rootObj, rootObj);
                        }
                    }
                    deleteObjs = editor.Editor.editorModel.getGameObjectsByUUids(deleteUUids);
                    editor.Editor.editorModel._deleteGameObject(deleteObjs);
                    //clear select
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, []);
                    return true;
                }
                return false;
            };
            return DeleteGameObjectsState;
        }(BaseState));
        editor.DeleteGameObjectsState = DeleteGameObjectsState;
        __reflect(DeleteGameObjectsState.prototype, "paper.editor.DeleteGameObjectsState");
        //克隆游戏对象
        var DuplicateGameObjectsState = (function (_super) {
            __extends(DuplicateGameObjectsState, _super);
            function DuplicateGameObjectsState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            DuplicateGameObjectsState.toString = function () {
                return "[class common.DuplicateGameObjectsState]";
            };
            DuplicateGameObjectsState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new DuplicateGameObjectsState();
                state.data = data;
                return state;
            };
            DuplicateGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    editor.Editor.editorModel._deleteGameObject(this.data.addObjs);
                    var selectIds = this.data.selectIds;
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, selectIds);
                    return true;
                }
                return false;
            };
            DuplicateGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var datas = this.data.datas;
                    var prefabData = this.data.prefabData;
                    var addObjs = [];
                    var selectIds = [];
                    for (var index = 0; index < datas.length; index++) {
                        var element = datas[index];
                        var duplicateUUid = element.duplicateUUid;
                        var sourceObj = editor.Editor.editorModel.getGameObjectByUUid(duplicateUUid);
                        if (!sourceObj) {
                            continue;
                        }
                        var duplicateObj = void 0;
                        if (element.serializeData) {
                            duplicateObj = paper.deserialize(element.serializeData, element.assetsMap);
                            duplicateObj.transform.setParent(sourceObj.transform.parent);
                        }
                        else {
                            duplicateObj = paper.clone(sourceObj);
                            duplicateObj.name = sourceObj.name + "_duplicate";
                            duplicateObj.transform.setParent(sourceObj.transform.parent);
                            element.serializeData = paper.serialize(duplicateObj);
                            element.assetsMap = editor.Editor.editorModel.createAssetMap(element.serializeData);
                        }
                        var stru = prefabData[index];
                        editor.Editor.editorModel.duplicatePrefabDataToGameObject(duplicateObj, stru, 0);
                        addObjs.push(duplicateObj);
                        selectIds.push(duplicateObj.uuid);
                    }
                    this.data.addObjs = addObjs;
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, selectIds);
                    return true;
                }
                return false;
            };
            return DuplicateGameObjectsState;
        }(BaseState));
        editor.DuplicateGameObjectsState = DuplicateGameObjectsState;
        __reflect(DuplicateGameObjectsState.prototype, "paper.editor.DuplicateGameObjectsState");
        //粘贴游戏对象
        var PasteGameObjectsState = (function (_super) {
            __extends(PasteGameObjectsState, _super);
            function PasteGameObjectsState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            PasteGameObjectsState.toString = function () {
                return "[class common.PasteGameObjectsState]";
            };
            PasteGameObjectsState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new PasteGameObjectsState();
                state.data = data;
                return state;
            };
            PasteGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    editor.Editor.editorModel._deleteGameObject(this.data.addObjs);
                    var selectIds = this.data.selectIds;
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, selectIds);
                    return true;
                }
                return false;
            };
            PasteGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var datas = this.data.datas;
                    var addObjs = [];
                    var prefabData = this.data.prefabData;
                    var selectIds = [];
                    for (var index = 0; index < datas.length; index++) {
                        var element = datas[index];
                        var parentUUid = element.parentUUid;
                        var targetTransform = this.data.target;
                        var sourceObj = editor.Editor.editorModel.getGameObjectByUUid(parentUUid);
                        if (!sourceObj) {
                            continue;
                        }
                        var pasteObj = void 0;
                        if (element.serializeData) {
                            pasteObj = paper.deserialize(element.serializeData, element.assetsMap);
                            pasteObj.transform.setParent(sourceObj.transform.parent);
                        }
                        else {
                            pasteObj = paper.clone(sourceObj);
                            pasteObj.name = sourceObj.name + "_paste";
                            pasteObj.transform.setParent(sourceObj.transform.parent);
                            element.serializeData = paper.serialize(pasteObj);
                            element.assetsMap = editor.Editor.editorModel.createAssetMap(element.serializeData);
                        }
                        var stru = prefabData[index];
                        editor.Editor.editorModel.duplicatePrefabDataToGameObject(pasteObj, stru, 0);
                        addObjs.push(pasteObj);
                        selectIds.push(pasteObj.uuid);
                    }
                    this.data.addObjs = addObjs;
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, selectIds);
                    return true;
                }
                return false;
            };
            return PasteGameObjectsState;
        }(BaseState));
        editor.PasteGameObjectsState = PasteGameObjectsState;
        __reflect(PasteGameObjectsState.prototype, "paper.editor.PasteGameObjectsState");
        //添加组件
        var AddComponentState = (function (_super) {
            __extends(AddComponentState, _super);
            function AddComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            AddComponentState.toString = function () {
                return "[class common.AddComponentState]";
            };
            AddComponentState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new AddComponentState();
                state.data = data;
                return state;
            };
            AddComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var gameObjectUUid = this.data.gameObjectUUid;
                    var componentId = this.data.cacheUUid;
                    var gameObject = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (gameObject) {
                        for (var i = 0; i < gameObject.components.length; i++) {
                            var comp = gameObject.components[i];
                            if (comp.uuid === componentId) {
                                gameObject.removeComponent(comp.constructor);
                                break;
                            }
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                    return true;
                }
                return false;
            };
            AddComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUid = this.data.gameObjectUUid;
                    var compClzName = this.data.compClzName;
                    var gameObject = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (gameObject) {
                        var addComponent = void 0;
                        if (this.data.serializeData) {
                            addComponent = paper.deserialize(this.data.serializeData, this.data.assetsMap);
                            editor.Editor.editorModel.addComponentToGameObject(gameObject, addComponent);
                        }
                        else {
                            var compClz = egret.getDefinitionByName(compClzName);
                            addComponent = gameObject.addComponent(compClz);
                            this.data.serializeData = paper.serialize(addComponent);
                            this.data.assetsMap = editor.Editor.editorModel.createAssetMap(this.data.serializeData);
                        }
                        this.data.cacheUUid = addComponent.uuid;
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                    return true;
                }
                return false;
            };
            return AddComponentState;
        }(BaseState));
        editor.AddComponentState = AddComponentState;
        __reflect(AddComponentState.prototype, "paper.editor.AddComponentState");
        //移除组件
        var RemoveComponentState = (function (_super) {
            __extends(RemoveComponentState, _super);
            function RemoveComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            RemoveComponentState.toString = function () {
                return "[class common.RemoveComponentState]";
            };
            RemoveComponentState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new RemoveComponentState();
                state.data = data;
                return state;
            };
            RemoveComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var serializeData = this.data.serializeData;
                    var component = paper.deserialize(serializeData, this.data.assetsMap);
                    var gameObjectUUid = this.data.gameObjectUUid;
                    if (component) {
                        var gameObject = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                        if (gameObject) {
                            component.gameObject = gameObject;
                            editor.Editor.editorModel.addComponentToGameObject(gameObject, component);
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                        }
                    }
                    return true;
                }
                return false;
            };
            RemoveComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUid = this.data.gameObjectUUid;
                    var componentUUid = this.data.componentUUid;
                    var obj = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (obj) {
                        for (var i = 0; i < obj.components.length; i++) {
                            var comp = obj.components[i];
                            if (comp.uuid === componentUUid) {
                                obj.removeComponent(comp.constructor);
                                break;
                            }
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                    return true;
                }
                return false;
            };
            return RemoveComponentState;
        }(BaseState));
        editor.RemoveComponentState = RemoveComponentState;
        __reflect(RemoveComponentState.prototype, "paper.editor.RemoveComponentState");
        //更改游戏对象层级
        var UpdateParentState = (function (_super) {
            __extends(UpdateParentState, _super);
            function UpdateParentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            UpdateParentState.toString = function () {
                return "[class common.UpdateParentState]";
            };
            UpdateParentState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new UpdateParentState();
                state.data = data;
                return state;
            };
            UpdateParentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var _a = this.data, gameObjectUUids = _a.gameObjectUUids, targetUUid = _a.targetUUid, originParentIds = _a.originParentIds, prefabData = _a.prefabData;
                    var gameObjs = editor.Editor.editorModel.getGameObjectsByUUids(gameObjectUUids);
                    var originParentId = void 0;
                    var originParent = void 0;
                    var originTransForm = void 0;
                    for (var index = 0; index < gameObjs.length; index++) {
                        var element = gameObjs[index];
                        originParentId = originParentIds[index];
                        if (originParentId) {
                            originParent = editor.Editor.editorModel.getGameObjectByUUid(originParentId);
                        }
                        originTransForm = originParent ? originParent.transform : null;
                        element.transform.setParent(originTransForm);
                        if (prefabData[element.uuid]) {
                            var prefabRootId = prefabData[element.uuid].rootId;
                            var url = prefabData[element.uuid].url;
                            var prefabIds = prefabData[element.uuid].prefabIds;
                            var prefab = paper.Asset.find(url);
                            var rootObj = editor.Editor.editorModel.getGameObjectByUUid(prefabRootId);
                            if (rootObj) {
                                editor.Editor.editorModel.resetPrefabbyRootId(rootObj, prefab, prefabIds);
                            }
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_PARENT);
                    return true;
                }
                return false;
            };
            UpdateParentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var _a = this.data, gameObjectUUids = _a.gameObjectUUids, targetUUid = _a.targetUUid, prefabData = _a.prefabData;
                    var gameObjs = editor.Editor.editorModel.getGameObjectsByUUids(gameObjectUUids);
                    var targetGameObj = editor.Editor.editorModel.getGameObjectByUUid(targetUUid);
                    var targetTransform = null;
                    for (var index = 0; index < gameObjs.length; index++) {
                        var element = gameObjs[index];
                        if (targetGameObj) {
                            targetTransform = targetGameObj.transform;
                        }
                        if (prefabData[element.uuid]) {
                            var prefabRootId = prefabData[element.uuid].rootId;
                            var rootObj = editor.Editor.editorModel.getGameObjectByUUid(prefabRootId);
                            editor.Editor.editorModel.clearRootPrefabInstance(rootObj, rootObj);
                        }
                        element.transform.setParent(targetTransform);
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_PARENT);
                    return true;
                }
                return false;
            };
            return UpdateParentState;
        }(BaseState));
        editor.UpdateParentState = UpdateParentState;
        __reflect(UpdateParentState.prototype, "paper.editor.UpdateParentState");
        var ModifyPrefabProperty = (function (_super) {
            __extends(ModifyPrefabProperty, _super);
            function ModifyPrefabProperty() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.getGameObjectsByPrefab = function (prefab) {
                    var objects = paper.Application.sceneManager.getActiveScene().gameObjects;
                    var result = [];
                    objects.forEach(function (obj) {
                        if (obj.prefab && obj.prefab.url === prefab.url && editor.Editor.editorModel.isPrefabRoot(obj)) {
                            result.push(obj);
                        }
                    });
                    return result;
                };
                return _this;
            }
            ModifyPrefabProperty.prototype.equal = function (a, b) {
                var className = egret.getQualifiedClassName(a);
                if (className === egret.getQualifiedClassName(b)) {
                    switch (className) {
                        case 'egret3d.Vector2': return egret3d.Vector2.equal(a, b);
                        case 'egret3d.Vector3': return egret3d.Vector3.equal(a, b);
                        case 'egret3d.Vector4': return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
                        case 'egret3d.Quaternion': return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
                        case 'egret3d.Rect': return a.x === b.x && a.y === b.y && a.w === b.w && a.h === b.h;
                        case 'egret3d.Color': return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
                        default:
                            return false;
                    }
                }
                else
                    return false;
            };
            ModifyPrefabProperty.prototype.dispathPropertyEvent = function (modifyObj, propName, newValue) {
                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
            };
            return ModifyPrefabProperty;
        }(BaseState));
        editor.ModifyPrefabProperty = ModifyPrefabProperty;
        __reflect(ModifyPrefabProperty.prototype, "paper.editor.ModifyPrefabProperty");
        //修改预制体游戏对象属性
        var ModifyPrefabGameObjectPropertyState = (function (_super) {
            __extends(ModifyPrefabGameObjectPropertyState, _super);
            function ModifyPrefabGameObjectPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyPrefabGameObjectPropertyState.toString = function () {
                return "[class common.ModifyPrefabGameObjectPropertyState]";
            };
            ModifyPrefabGameObjectPropertyState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new ModifyPrefabGameObjectPropertyState();
                state.data = data;
                return state;
            };
            /**
             * 修改预制体游戏对象属性,目前只支持修改根对象
             * @param gameObjectId
             * @param valueList
             */
            ModifyPrefabGameObjectPropertyState.prototype.modifyPrefabGameObjectPropertyValues = function (gameObjectUUid, valueList) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    var prefabObj, objects, editInfoList;
                    return __generator(this, function (_a) {
                        prefabObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                        if (!prefabObj) {
                            return [2 /*return*/];
                        }
                        objects = this.getGameObjectsByPrefab(prefabObj.prefab);
                        editInfoList = editor.getEditInfo(prefabObj);
                        valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                            var _this = this;
                            var propName, copyValue, valueEditType, newValue;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                        return [4 /*yield*/, editor.Editor.editorModel.deserializeProperty(copyValue, valueEditType)];
                                    case 1:
                                        newValue = _a.sent();
                                        objects.forEach(function (object) {
                                            var valueType = typeof object[propName];
                                            if (valueType === 'number' || valueType === 'boolean' || valueType === 'string') {
                                                if (object[propName] === prefabObj[propName]) {
                                                    editor.Editor.editorModel.setTargetProperty(propName, object, newValue);
                                                    _this.dispathPropertyEvent(object, propName, newValue);
                                                }
                                            }
                                            else {
                                                if (_this.equal(object[propName], prefabObj[propName])) {
                                                    editor.Editor.editorModel.setTargetProperty(propName, object, newValue);
                                                    _this.dispathPropertyEvent(object, propName, newValue);
                                                }
                                            }
                                        });
                                        editor.Editor.editorModel.setTargetProperty(propName, prefabObj, newValue);
                                        this.dispathPropertyEvent(prefabObj, propName, newValue);
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        return [2 /*return*/];
                    });
                });
            };
            ModifyPrefabGameObjectPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var _a = this.data, gameObjectUUid = _a.gameObjectUUid, preValueCopylist = _a.preValueCopylist;
                    this.modifyPrefabGameObjectPropertyValues(gameObjectUUid, preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyPrefabGameObjectPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var _a = this.data, gameObjectUUid = _a.gameObjectUUid, newValueList = _a.newValueList;
                    this.modifyPrefabGameObjectPropertyValues(gameObjectUUid, newValueList);
                    return true;
                }
                return false;
            };
            return ModifyPrefabGameObjectPropertyState;
        }(ModifyPrefabProperty));
        editor.ModifyPrefabGameObjectPropertyState = ModifyPrefabGameObjectPropertyState;
        __reflect(ModifyPrefabGameObjectPropertyState.prototype, "paper.editor.ModifyPrefabGameObjectPropertyState");
        //修改预制体组件属性
        var ModifyPrefabComponentPropertyState = (function (_super) {
            __extends(ModifyPrefabComponentPropertyState, _super);
            function ModifyPrefabComponentPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyPrefabComponentPropertyState.toString = function () {
                return "[class common.ModifyPrefabComponentPropertyState]";
            };
            ModifyPrefabComponentPropertyState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new ModifyPrefabComponentPropertyState();
                state.data = data;
                return state;
            };
            ModifyPrefabComponentPropertyState.prototype.modifyPrefabComponentPropertyValues = function (gameObjUUid, componentUUid, valueList) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    var prefabObj, objects, _loop_2, k;
                    return __generator(this, function (_a) {
                        prefabObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjUUid);
                        if (!prefabObj) {
                            return [2 /*return*/];
                        }
                        objects = this.getGameObjectsByPrefab(prefabObj.prefab);
                        _loop_2 = function (k) {
                            var prefabComp = prefabObj.components[k];
                            var editInfoList = editor.getEditInfo(prefabComp);
                            if (prefabComp.uuid === componentUUid) {
                                valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                                    var _this = this;
                                    var propName, copyValue, valueEditType, newValue;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                                return [4 /*yield*/, editor.Editor.editorModel.deserializeProperty(copyValue, valueEditType)];
                                            case 1:
                                                newValue = _a.sent();
                                                objects.forEach(function (object) {
                                                    var objectComp = editor.Editor.editorModel.getComponentByAssetId(object, prefabComp.assetUUid);
                                                    if (objectComp !== null) {
                                                        var valueType = typeof objectComp[propName];
                                                        if (valueType === 'number' || valueType === 'boolean' || valueType === 'string') {
                                                            if (objectComp[propName] === prefabComp[propName]) {
                                                                editor.Editor.editorModel.setTargetProperty(propName, objectComp, newValue);
                                                                _this.dispathPropertyEvent(objectComp, propName, newValue);
                                                            }
                                                        }
                                                        else {
                                                            if (_this.equal(objectComp[propName], prefabComp[propName])) {
                                                                editor.Editor.editorModel.setTargetProperty(propName, objectComp, newValue);
                                                                _this.dispathPropertyEvent(objectComp, propName, newValue);
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        console.warn("{prefabComp.assetUUid} not match!");
                                                    }
                                                });
                                                editor.Editor.editorModel.setTargetProperty(propName, prefabComp, newValue);
                                                this.dispathPropertyEvent(prefabComp, propName, newValue);
                                                return [2 /*return*/];
                                        }
                                    });
                                }); });
                            }
                        };
                        for (k = 0; k < prefabObj.components.length; k++) {
                            _loop_2(k);
                        }
                        return [2 /*return*/];
                    });
                });
            };
            ModifyPrefabComponentPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var _a = this.data, gameObjUUid = _a.gameObjUUid, componentUUid = _a.componentUUid, preValueCopylist = _a.preValueCopylist;
                    this.modifyPrefabComponentPropertyValues(gameObjUUid, componentUUid, preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyPrefabComponentPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var _a = this.data, gameObjUUid = _a.gameObjUUid, componentUUid = _a.componentUUid, newValueList = _a.newValueList;
                    this.modifyPrefabComponentPropertyValues(gameObjUUid, componentUUid, newValueList);
                    return true;
                }
                return false;
            };
            return ModifyPrefabComponentPropertyState;
        }(ModifyPrefabProperty));
        editor.ModifyPrefabComponentPropertyState = ModifyPrefabComponentPropertyState;
        __reflect(ModifyPrefabComponentPropertyState.prototype, "paper.editor.ModifyPrefabComponentPropertyState");
        //移除组件
        var RemovePrefabComponentState = (function (_super) {
            __extends(RemovePrefabComponentState, _super);
            function RemovePrefabComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            RemovePrefabComponentState.toString = function () {
                return "[class common.RemovePrefabComponentState]";
            };
            RemovePrefabComponentState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new RemovePrefabComponentState();
                state.data = data;
                return state;
            };
            RemovePrefabComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var datas = this.data.datas;
                    for (var index = 0; index < datas.length; index++) {
                        var element = datas[index];
                        var gameObjUUid = element.gameObjUUid, componentUUid = element.componentUUid, serializeData = element.serializeData, assetsMap = element.assetsMap;
                        var addComponent = paper.deserialize(serializeData, assetsMap);
                        if (addComponent) {
                            var gameObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjUUid);
                            if (gameObj) {
                                // addComponent.uuid = componentUUid;
                                addComponent.gameObject = gameObj;
                                editor.Editor.editorModel.addComponentToGameObject(gameObj, addComponent);
                                this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                            }
                        }
                    }
                    return true;
                }
                return false;
            };
            RemovePrefabComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var datas = this.data.datas;
                    for (var index = 0; index < datas.length; index++) {
                        var element = datas[index];
                        var gameObjUUid = element.gameObjUUid, componentUUid = element.componentUUid;
                        var gameObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjUUid);
                        if (gameObj) {
                            var componentObj = editor.Editor.editorModel.getComponentById(gameObj, componentUUid);
                            if (componentObj) {
                                gameObj.removeComponent(componentObj.constructor);
                                this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                            }
                        }
                    }
                    return true;
                }
                return false;
            };
            return RemovePrefabComponentState;
        }(BaseState));
        editor.RemovePrefabComponentState = RemovePrefabComponentState;
        __reflect(RemovePrefabComponentState.prototype, "paper.editor.RemovePrefabComponentState");
        //添加组件
        var AddPrefabComponentState = (function (_super) {
            __extends(AddPrefabComponentState, _super);
            function AddPrefabComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            AddPrefabComponentState.toString = function () {
                return "[class common.AddPrefabComponentState]";
            };
            AddPrefabComponentState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new AddPrefabComponentState();
                state.data = data;
                return state;
            };
            AddPrefabComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var datas = this.data.datas;
                    for (var index = 0; index < datas.length; index++) {
                        var element = datas[index];
                        var gameObjectUUid = element.gameObjectUUid, compClzName = element.compClzName, cacheUUid = element.cacheUUid;
                        var gameObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                        if (gameObj && cacheUUid) {
                            var removeComponent = editor.Editor.editorModel.getComponentById(gameObj, cacheUUid);
                            if (removeComponent) {
                                gameObj.removeComponent(removeComponent);
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                        }
                    }
                    return true;
                }
                return false;
            };
            AddPrefabComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var datas = this.data.datas;
                    for (var index = 0; index < datas.length; index++) {
                        var element = datas[index];
                        var gameObjectUUid = element.gameObjectUUid, compClz = element.compClz;
                        var gameObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                        if (gameObj) {
                            var addComponent = void 0;
                            if (this.data.serializeData) {
                                addComponent = paper.deserialize(this.data.serializeData, this.data.assetsMap, true);
                                editor.Editor.editorModel.addComponentToGameObject(gameObj, addComponent);
                            }
                            else {
                                addComponent = gameObj.addComponent(compClz);
                                this.data.serializeData = paper.serialize(addComponent);
                                this.data.assetsMap = editor.Editor.editorModel.createAssetMap(this.data.serializeData);
                            }
                            element.cacheUUid = addComponent.uuid;
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                        }
                    }
                    return true;
                }
                return false;
            };
            return AddPrefabComponentState;
        }(BaseState));
        editor.AddPrefabComponentState = AddPrefabComponentState;
        __reflect(AddPrefabComponentState.prototype, "paper.editor.AddPrefabComponentState");
        //修改asset
        var ModifyAssetPropertyState = (function (_super) {
            __extends(ModifyAssetPropertyState, _super);
            function ModifyAssetPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyAssetPropertyState.toString = function () {
                return "[class common.ModifyAssetPropertyState]";
            };
            ModifyAssetPropertyState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new ModifyAssetPropertyState();
                state.data = data;
                return state;
            };
            ModifyAssetPropertyState.prototype.modifyAssetPropertyValues = function (assetUrl, valueList) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    var target, editInfoList;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, editor.Editor.editorModel.getAssetByAssetUrl(assetUrl)];
                            case 1:
                                target = _a.sent();
                                editInfoList = editor.getEditInfo(target);
                                valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                                    var propName, copyValue, valueEditType, newValue;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                                return [4 /*yield*/, editor.Editor.editorModel.deserializeProperty(copyValue, valueEditType)];
                                            case 1:
                                                newValue = _a.sent();
                                                editor.Editor.editorModel.setTargetProperty(propName, target, newValue);
                                                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: target, propName: propName, propValue: newValue });
                                                return [2 /*return*/];
                                        }
                                    });
                                }); });
                                return [2 /*return*/];
                        }
                    });
                });
            };
            ModifyAssetPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var _a = this.data, assetUrl = _a.assetUrl, preValueCopylist = _a.preValueCopylist;
                    this.modifyAssetPropertyValues(assetUrl, preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyAssetPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var _a = this.data, newValueList = _a.newValueList, assetUrl = _a.assetUrl;
                    this.modifyAssetPropertyValues(assetUrl, newValueList);
                    return true;
                }
                return false;
            };
            return ModifyAssetPropertyState;
        }(BaseState));
        editor.ModifyAssetPropertyState = ModifyAssetPropertyState;
        __reflect(ModifyAssetPropertyState.prototype, "paper.editor.ModifyAssetPropertyState");
        var CreatePrefabState = (function (_super) {
            __extends(CreatePrefabState, _super);
            function CreatePrefabState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            CreatePrefabState.toString = function () {
                return "[class common.CreatePrefabState]";
            };
            CreatePrefabState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new CreatePrefabState();
                state.data = data;
                return state;
            };
            /**
             * 设置children prefab属性
             * @param gameObj
             * @param prefab
             */
            CreatePrefabState.prototype.setGameObjectPrefab = function (gameObj, prefab, rootObj) {
                if (!gameObj) {
                    return;
                }
                gameObj.prefab = prefab;
                if (gameObj != rootObj) {
                    gameObj.prefabEditInfo = rootObj.uuid;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    this.setGameObjectPrefab(obj, prefab, rootObj);
                }
            };
            CreatePrefabState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var deleteUUid = this.data.cachePrefabUUid;
                    var gameObj = editor.Editor.editorModel.getGameObjectByUUid(deleteUUid);
                    editor.Editor.editorModel._deleteGameObject([gameObj]);
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, [this.data.selectIds]);
                    return true;
                }
                return false;
            };
            CreatePrefabState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var prefab = this.data.prefab;
                    if (prefab) {
                        var instance = void 0;
                        if (this.data.serializeData) {
                            instance = paper.deserialize(this.data.serializeData, this.data.assetsMap);
                            this.setGameObjectPrefab(instance, prefab, instance);
                        }
                        else {
                            instance = prefab.createInstance();
                            instance.prefabEditInfo = true;
                            this.setGameObjectPrefab(instance, prefab, instance);
                            this.data.serializeData = paper.serialize(instance);
                            this.data.assetsMap = editor.Editor.editorModel.createAssetMap(this.data.serializeData);
                        }
                        this.data.cachePrefabUUid = instance.uuid;
                    }
                    //select prefab root
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, [this.data.cachePrefabUUid]);
                    return true;
                }
                return false;
            };
            return CreatePrefabState;
        }(BaseState));
        editor.CreatePrefabState = CreatePrefabState;
        __reflect(CreatePrefabState.prototype, "paper.editor.CreatePrefabState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ValueUUID = (function () {
            function ValueUUID(_value) {
                this._value = _value;
                // empty
            }
            ValueUUID.prototype.asHex = function () {
                return this._value;
            };
            return ValueUUID;
        }());
        __reflect(ValueUUID.prototype, "ValueUUID", ["paper.editor.UUID"]);
        var V4UUID = (function (_super) {
            __extends(V4UUID, _super);
            function V4UUID() {
                return _super.call(this, [
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    '4',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._oneOf(V4UUID._timeHighBits),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                ].join('')) || this;
            }
            V4UUID._oneOf = function (array) {
                return array[Math.floor(array.length * Math.random())];
            };
            V4UUID._randomHex = function () {
                return V4UUID._oneOf(V4UUID._chars);
            };
            V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
            V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
            return V4UUID;
        }(ValueUUID));
        __reflect(V4UUID.prototype, "V4UUID");
        function v4() {
            return new V4UUID();
        }
        editor.v4 = v4;
        var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        function isUUID(value) {
            return _UUIDPattern.test(value);
        }
        editor.isUUID = isUUID;
        /**
         * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
         * @param value A uuid string.
         */
        function parse(value) {
            if (!isUUID(value)) {
                throw new Error('invalid uuid');
            }
            return new ValueUUID(value);
        }
        editor.parse = parse;
        function generateUuid() {
            return v4().asHex();
        }
        editor.generateUuid = generateUuid;
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * EditorCamera系统
         */
        var EditorCameraSystem = (function (_super) {
            __extends(EditorCameraSystem, _super);
            function EditorCameraSystem() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            /**
             * @inheritDoc
             */
            EditorCameraSystem.prototype.onUpdate = function () {
                this._components.sort(function (a, b) {
                    return a.order - b.order;
                });
                var lightSystem = paper.Application.systemManager.getSystem(egret3d.LightSystem);
                var lights = lightSystem ? lightSystem.components : null;
                var camera = null;
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (component.gameObject.tag === "EditorCamera") {
                        camera = component;
                    }
                    component.update(paper.Time.deltaTime);
                    if (lights && lights.length > 0) {
                        component.context.updateLights(lights);
                    }
                }
                if (camera) {
                    camera.context.drawtype = "";
                    camera._targetAndViewport(camera.renderTarget, false);
                    this.$renderCamera(camera);
                }
                else {
                    egret3d.WebGLKit.webgl.clearColor(0, 0, 0, 1);
                    egret3d.WebGLKit.webgl.clearDepth(1.0);
                    egret3d.WebGLKit.webgl.clear(egret3d.WebGLKit.webgl.COLOR_BUFFER_BIT | egret3d.WebGLKit.webgl.DEPTH_BUFFER_BIT);
                }
            };
            return EditorCameraSystem;
        }(egret3d.CameraSystem));
        editor.EditorCameraSystem = EditorCameraSystem;
        __reflect(EditorCameraSystem.prototype, "paper.editor.EditorCameraSystem");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * TODO Gizmos系统
         * 可以用来绘制一些图标等
         */
        var GizmosSystem = (function (_super) {
            __extends(GizmosSystem, _super);
            function GizmosSystem() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            /**
             * @inheritDoc
             */
            GizmosSystem.prototype.onUpdate = function () {
            };
            return GizmosSystem;
        }(paper.BaseSystem));
        editor.GizmosSystem = GizmosSystem;
        __reflect(GizmosSystem.prototype, "paper.editor.GizmosSystem");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var forward = new egret3d.Vector3();
        var up = new egret3d.Vector3();
        var right = new egret3d.Vector3();
        var EditorCameraScript = (function (_super) {
            __extends(EditorCameraScript, _super);
            function EditorCameraScript() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.moveSpeed = 20;
                _this.wheelSpeed = 2;
                _this.rotateSpeed = 1;
                _this._lastMouseX = 0;
                _this._lastMouseY = 0;
                _this._mouseDown_r = false;
                _this._mouseDown_l = false;
                _this._lookAtPiont = new egret3d.Vector3();
                _this._dragPlanePoint = new egret3d.Vector3(0, 0, 0);
                _this._dragPlaneNormal = new egret3d.Vector3(0, 1, 0);
                _this._helpQuat = new egret3d.Quaternion();
                _this._helpVec3 = new egret3d.Vector3();
                return _this;
            }
            EditorCameraScript.prototype.onStart = function () {
                this.bindKeyboard = egret3d.InputManager.keyboard;
                this.bindMouse = egret3d.InputManager.mouse;
            };
            ;
            EditorCameraScript.prototype.onUpdate = function (delta) {
                this.inputUpdate(delta);
                //this.mouseUpdate(delta);
                //Gizmo.DrawLine(new egret3d.Vector3(-5, 5, 0.5), new egret3d.Vector3(5, 5, 0.5), 100.0, [1.0, 0.0, 0.0, 1.0]);
                editor.Gizmo.DrawCoord();
                editor.Gizmo.DrawLights();
                editor.Gizmo.DrawCameras();
                //Gizmo.DrawArrowXYZ();
                // this.editorModel.geoController.update();
            };
            ;
            EditorCameraScript.prototype.OnEnable = function () {
                this._lastMouseX = 0;
                this._lastMouseY = 0;
                this._mouseDown_r = false;
                this._mouseDown_l = false;
            };
            EditorCameraScript.prototype.OnDisable = function () {
                this._lastMouseX = 0;
                this._lastMouseY = 0;
                this._mouseDown_r = false;
                this._mouseDown_l = false;
            };
            EditorCameraScript.prototype.inputUpdate = function (delta) {
                var mouse = this.bindMouse;
                var keyboard = this.bindKeyboard;
                forward.x = 0;
                forward.y = 0;
                forward.z = 0;
                up.x = 0;
                up.y = this.moveSpeed * delta;
                up.z = 0;
                right.x = this.moveSpeed * delta;
                right.y = 0;
                right.z = 0;
                var rotation = this.gameObject.transform.getLocalRotation();
                egret3d.Quaternion.transformVector3(rotation, up, up);
                egret3d.Quaternion.transformVector3(rotation, right, right);
                var p = this.gameObject.transform.getLocalPosition();
                var result = new egret3d.Vector3();
                egret3d.Vector3.copy(p, result);
                //上下左右
                if (keyboard.isPressed("LEFT")) {
                    egret3d.Vector3.subtract(result, right, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (keyboard.isPressed("RIGHT")) {
                    egret3d.Vector3.add(result, right, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (keyboard.isPressed("UP")) {
                    egret3d.Vector3.add(result, up, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (keyboard.isPressed("DOWN")) {
                    egret3d.Vector3.subtract(result, up, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                //放大缩小
                if (mouse.wheel !== 0) {
                    forward.z = mouse.wheel * this.wheelSpeed;
                    egret3d.Quaternion.transformVector3(rotation, forward, forward);
                    egret3d.Vector3.add(result, forward, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (mouse.isPressed(2) && keyboard.isPressed('ALT')) {
                    if (!this._mouseDown_r) {
                        this._mouseDown_r = true;
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                    else {
                        var moveX = mouse.position.x - this._lastMouseX;
                        forward.z = moveX * 0.1;
                        egret3d.Quaternion.transformVector3(rotation, forward, forward);
                        egret3d.Vector3.add(result, forward, result);
                        this.gameObject.transform.setLocalPosition(result);
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                }
                else if (keyboard.wasReleased('ALT') || mouse.wasReleased(0)) {
                    this._mouseDown_r = false;
                }
                //方向
                if (mouse.isPressed(2) && !keyboard.isPressed('ALT')) {
                    if (!this._mouseDown_r) {
                        this._mouseDown_r = true;
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                    else {
                        var moveX = mouse.position.x - this._lastMouseX;
                        var moveY = mouse.position.y - this._lastMouseY;
                        var euler = this.gameObject.transform.getLocalEulerAngles();
                        this.gameObject.transform.setLocalEulerAngles(Math.max(Math.min((euler.x + moveY * this.rotateSpeed), 89.9), -89.9), euler.y + moveX * this.rotateSpeed, euler.z);
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                }
                else if (mouse.wasReleased(2) || keyboard.wasPressed('ALT')) {
                    this._mouseDown_r = false;
                }
                if (keyboard.isPressed('ALT') && mouse.isPressed(0)) {
                    if (!this._mouseDown_l) {
                        this._mouseDown_l = true;
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                        var screenPosition = new egret3d.Vector2(egret3d.stage.screenViewport.w / 2, egret3d.stage.screenViewport.h / 2);
                        var camera = this.gameObject.getComponent(egret3d.Camera);
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        this._lookAtPiont = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                    }
                    else {
                        var moveX = mouse.position.x - this._lastMouseX;
                        var moveY = mouse.position.y - this._lastMouseY;
                        //let euler = this.gameObject.transform.getLocalEulerAngles();
                        var theta_x = moveY * this.rotateSpeed, theta_y = moveX * this.rotateSpeed;
                        var sinX = Math.sin(theta_x / 180 * Math.PI / 2), cosX = Math.cos(theta_x / 180 * Math.PI / 2);
                        var sinY = Math.sin(theta_y / 180 * Math.PI / 2), cosY = Math.cos(theta_y / 180 * Math.PI / 2);
                        //this.gameObject.transform.setLocalEulerAngles(Math.max(Math.min((euler.x + theta_x), 89.9), -89.9), euler.y + theta_y, euler.z);
                        var rot = this.gameObject.transform.getRotation();
                        var pos = this.gameObject.transform.getPosition();
                        egret3d.Vector3.subtract(pos, this._lookAtPiont, pos);
                        this.gameObject.transform.getRight(this._helpVec3);
                        egret3d.Vector3.normalize(this._helpVec3);
                        egret3d.Quaternion.set(sinX * this._helpVec3.x, sinX * this._helpVec3.y, sinX * this._helpVec3.z, cosX, this._helpQuat);
                        egret3d.Quaternion.transformVector3(this._helpQuat, pos, pos);
                        egret3d.Quaternion.multiply(this._helpQuat, rot, rot);
                        egret3d.Vector3.set(0, 1, 0, this._helpVec3);
                        egret3d.Quaternion.set(sinY * this._helpVec3.x, sinY * this._helpVec3.y, sinY * this._helpVec3.z, cosY, this._helpQuat);
                        egret3d.Quaternion.transformVector3(this._helpQuat, pos, pos);
                        egret3d.Quaternion.multiply(this._helpQuat, rot, rot);
                        egret3d.Vector3.add(pos, this._lookAtPiont, pos);
                        this.gameObject.transform.setRotation(rot);
                        this.gameObject.transform.setPosition(pos);
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                }
                else if (keyboard.wasReleased('ALT') || mouse.wasReleased(0)) {
                    this._mouseDown_l = false;
                }
                // 复制粘贴
                // if (keyboard.isPressed('CONTROL') && keyboard.wasPressed('C')) {
                //     let clipboard = __global.runtimeModule.getClipborad()
                //     clipboard.writeText("zhrit", "paper");
                // }
                // if (keyboard.isPressed('CONTROL') && keyboard.wasPressed('V')) {
                //     let clipboard = __global.runtimeModule.getClipborad()
                //     let msg = clipboard.readText("paper");
                //     console.log(msg);
                // }
                //(keyboard.isPressed('ALT') && mouse.isPressed(0)) || 
            };
            ;
            EditorCameraScript.prototype.onDestroy = function () {
                var inputManager = egret3d.InputManager;
                if (inputManager.mouse.wasPressed(0)) {
                    // do something
                }
                if (inputManager.keyboard.isPressed("K")) {
                    // do something
                }
                if (inputManager.touch.touchCount > 0) {
                    var touch = inputManager.touch.getTouch(0);
                    // do something
                }
            };
            EditorCameraScript = __decorate([
                paper.executeInEditMode
            ], EditorCameraScript);
            return EditorCameraScript;
        }(paper.Behaviour));
        editor.EditorCameraScript = EditorCameraScript;
        __reflect(EditorCameraScript.prototype, "paper.editor.EditorCameraScript");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var PickGameObjectScript = (function (_super) {
            __extends(PickGameObjectScript, _super);
            function PickGameObjectScript() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._tapStart = 0;
                _this.selectedGameObjects = [];
                return _this;
            }
            PickGameObjectScript.prototype.onStart = function () {
                this.bindMouse = egret3d.InputManager.mouse;
                this.bindKeyboard = egret3d.InputManager.keyboard;
                this.camera = this.gameObject.getComponent(egret3d.Camera);
                this.cameraScript = this.gameObject.getComponent(editor.EditorCameraScript);
                this.selectedGameObjects = [];
            };
            PickGameObjectScript.prototype.onUpdate = function (delta) {
                try {
                    // 点击 game object 激活
                    if (this.bindMouse.wasReleased(0)) {
                        var ray = this.camera.createRayByScreen(this.bindMouse.position.x, this.bindMouse.position.y);
                        var pickInfo = egret3d.Ray.raycast(ray, true);
                        var tapDelta = Date.now() - this._tapStart;
                        if (this.bindKeyboard.isPressed('CONTROL')) {
                            if (pickInfo) {
                                var picked = pickInfo.transform.gameObject;
                                if (picked.name !== "GizmoController_Ball" && picked.name !== "GizmoController_X" && picked.name !== "GizmoController_Y" && picked.name !== "GizmoController_Z"
                                    && picked.name !== "GizmoController_Rotate_X" && picked.name !== "GizmoController_Rotate_Y" && picked.name !== "GizmoController_Rotate_Z"
                                    && picked.name !== "GizmoController_Scale_X" && picked.name !== "GizmoController_Scale_Y" && picked.name !== "GizmoController_Scale_Z") {
                                    // 对GameObject的点选
                                    if (tapDelta < 200) {
                                        var index = -1;
                                        var l = this.selectedGameObjects.length;
                                        for (var i = 0; i < l; i++) {
                                            if (this.selectedGameObjects[i] == picked) {
                                                index = i;
                                                break;
                                            }
                                        }
                                        if (index < 0) {
                                            this.selectedGameObjects.push(picked);
                                        }
                                        else if (l > 1) {
                                            this.selectedGameObjects.splice(index, 1);
                                        }
                                        var selectUUids = this.selectedGameObjects.map(function (gameobj) { return gameobj.uuid; });
                                        var select = {};
                                        select[editor.selectItemType.GAMEOBJECT] = selectUUids;
                                        this.editorModel.selectGameObject(select, null);
                                    }
                                }
                            }
                        }
                        else {
                            if (pickInfo) {
                                var picked = pickInfo.transform.gameObject;
                                if (picked.name !== "GizmoController_Ball" && picked.name !== "GizmoController_X" && picked.name !== "GizmoController_Y" && picked.name !== "GizmoController_Z"
                                    && picked.name !== "GizmoController_Rotate_X" && picked.name !== "GizmoController_Rotate_Y" && picked.name !== "GizmoController_Rotate_Z"
                                    && picked.name !== "GizmoController_Scale_X" && picked.name !== "GizmoController_Scale_Y" && picked.name !== "GizmoController_Scale_Z") {
                                    // 对GameObject的点选
                                    if (tapDelta < 200) {
                                        this.selectedGameObjects = [picked];
                                        var selectUUids = this.selectedGameObjects.map(function (gameobj) { return gameobj.uuid; });
                                        var select = {};
                                        select[editor.selectItemType.GAMEOBJECT] = selectUUids;
                                        this.editorModel.selectGameObject(select, null);
                                    }
                                }
                            }
                            else if (tapDelta < 200) {
                                this.selectedGameObjects = [];
                                var select = {};
                                select[editor.selectItemType.GAMEOBJECT] = [];
                                this.editorModel.selectGameObject(select, null);
                            }
                        }
                    }
                    // 点击控制杆，更新控制点
                    if (this.bindMouse.wasPressed(0)) {
                        this._tapStart = Date.now();
                    }
                }
                catch (e) {
                    console.log(e);
                }
            };
            //TODO,描边
            PickGameObjectScript.prototype.setStroke = function (picked) {
            };
            PickGameObjectScript = __decorate([
                paper.executeInEditMode
            ], PickGameObjectScript);
            return PickGameObjectScript;
        }(paper.Behaviour));
        editor.PickGameObjectScript = PickGameObjectScript;
        __reflect(PickGameObjectScript.prototype, "paper.editor.PickGameObjectScript");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //只有编辑模式可以执行，编辑相机
        var Gizmo = (function () {
            function Gizmo() {
            }
            Gizmo.Enabled = function (editorCamera) {
                this._editorCamera = editorCamera;
                this.camera = this._editorCamera.getComponent(egret3d.Camera);
                this.context = this.camera.context;
                this.webgl = egret3d.WebGLKit.webgl;
                this._enabled = true;
                this.initPrg();
                this.lineVertexBuffer = this.webgl.createBuffer();
                this.setVertices();
                this.getAllLightAndCamera();
                this.initIconTexture();
            };
            Gizmo.Disabled = function () {
                this._editorCamera = null;
                this._enabled = false;
                this.camera = null;
                this.context = null;
                this.texturePool = {};
                this.lightPool = null;
                this.cameraPool = null;
                this.glProgram_line = null;
                this.glProgram_icon = null;
                this.lineVertexBuffer = null;
                this.verticesCoord = null;
                this.coordVertexBuffer = null;
                this.nrLine = null;
            };
            Gizmo.DrawIcon = function (path, pos, size, color) {
                if (!this._enabled || !this.imageLoaded)
                    return;
                var gl = this.webgl;
                var prg = this.glProgram_icon;
                this.verticesLine = [pos.x, pos.y, pos.z];
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesLine), gl.STATIC_DRAW);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.textures[path]);
                if (color) {
                    prg.setBool("hasColor", true);
                    prg.setColor("iconColor", [color.r, color.g, color.b, color.a]);
                }
                else {
                    prg.setBool("hasColor", false);
                    prg.setColor("iconColor", [0, 0, 0, 1]);
                }
                prg.setTexture("PointTexture", 0);
                this.setMVPMatrix();
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setFloat("pointSize", size);
                gl.drawArrays(gl.POINTS, 0, 1);
            };
            Gizmo.DrawLine = function (posStart, posEnd, size, color) {
                if (!this._enabled)
                    return;
                egret3d.WebGLKit.zTest(true);
                var gl = this.webgl;
                var prg = this.glProgram_line;
                this.verticesLine = [
                    posStart.x, posStart.y, posStart.z,
                    posEnd.x, posEnd.y, posEnd.z
                ];
                gl.lineWidth(size || 1);
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesLine), gl.STATIC_DRAW);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                this.setMVPMatrix();
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", color);
                gl.drawArrays(gl.LINES, 0, 2);
            };
            Gizmo.DrawCoord = function () {
                if (!this._enabled)
                    return;
                egret3d.WebGLKit.zTest(true);
                var gl = this.webgl;
                var prg = this.glProgram_line;
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.coordVertexBuffer);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                this.setMVPMatrix();
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", [0.7, 0.7, 0.7, 0.8]);
                gl.drawArrays(gl.LINES, 0, (2 * this.nrLine + 1) * 4 + 2);
            };
            Gizmo.setVertices = function () {
                var gl = this.webgl;
                var nrLine = this.nrLine = 100;
                this.verticesCoord = [];
                this.cameraVertexBuffer = gl.createBuffer();
                this.cameraIndexBuffer = gl.createBuffer();
                this.coordVertexBuffer = gl.createBuffer();
                this.cylinderVertexBuffer = gl.createBuffer();
                this.arrowVertexBuffer = gl.createBuffer();
                var bia = -0.05;
                for (var i = 0, len = 2 * nrLine + 1; i < len; i++) {
                    this.verticesCoord[6 * i] = -nrLine + i;
                    this.verticesCoord[6 * i + 1] = bia;
                    this.verticesCoord[6 * i + 2] = -nrLine;
                    this.verticesCoord[6 * i + 3] = -nrLine + i;
                    this.verticesCoord[6 * i + 4] = bia;
                    this.verticesCoord[6 * i + 5] = nrLine;
                    this.verticesCoord[6 * len + 6 * i] = -nrLine;
                    this.verticesCoord[6 * len + 6 * i + 1] = bia;
                    this.verticesCoord[6 * len + 6 * i + 2] = -nrLine + i;
                    this.verticesCoord[6 * len + 6 * i + 3] = nrLine;
                    this.verticesCoord[6 * len + 6 * i + 4] = bia;
                    this.verticesCoord[6 * len + 6 * i + 5] = -nrLine + i;
                }
                this.verticesCylinder = [
                    0.5, 0, 0, 0.5, 0, 2,
                    0.433, 0.25, 0, 0.433, 0.25, 2,
                    0.25, 0.433, 0, 0.25, 0.433, 2,
                    -0.5, 0, 0, -0.5, 0, 2,
                    -0.433, 0.25, 0, -0.433, 0.25, 2,
                    -0.25, 0.433, 0, -0.25, 0.433, 2,
                    -0.5, 0, 0, -0.5, 0, 2,
                    -0.433, -0.25, 0, -0.433, -0.25, 2,
                    -0.25, -0.433, 0, -0.25, -0.433, 2,
                    0.5, 0, 0, 0.5, 0, 2,
                    0.433, -0.25, 0, 0.433, -0.25, 2,
                    0.25, -0.433, 0, 0.25, -0.433, 2,
                ];
                for (var i = 0; i < this.verticesCylinder.length; i++) {
                    this.verticesCylinder[i] *= 0.5;
                }
                this.verticesArrow = [
                    0.7, 0.0, 0.0, 0.0, 0.0, 0.0,
                    0.7, 0.0, 0.0, 0.7, 0.0, 0.1, 0.7, 0.1, 0.0,
                    0.7, 0.0, 0.0, 0.7, 0.1, 0.0, 0.7, 0.0, -0.1,
                    0.7, 0.0, 0.0, 0.7, 0.0, -0.1, 0.7, -0.1, 0.0,
                    0.7, 0.0, 0.0, 0.7, -0.1, 0.0, 0.7, 0.0, 0.1,
                    1.0, 0.0, 0.0, 0.7, 0.0, 0.1, 0.7, 0.1, 0.0,
                    1.0, 0.0, 0.0, 0.7, 0.1, 0.0, 0.7, 0.0, -0.1,
                    1.0, 0.0, 0.0, 0.7, 0.0, -0.1, 0.7, -0.1, 0.0,
                    1.0, 0.0, 0.0, 0.7, -0.1, 0.0, 0.7, 0.0, 0.1
                ];
                this.verticesCoord = this.verticesCoord.concat([0, -this.nrLine, 0, 0, this.nrLine, 0]);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.coordVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesCoord), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.cylinderVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesCylinder), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.arrowVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesArrow), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
            };
            Gizmo.setMVPMatrix = function (m) {
                var asp = this.context.viewPortPixel.w / this.context.viewPortPixel.h;
                this.camera.calcViewMatrix(this.vMatrix);
                this.camera.calcProjectMatrix(asp, this.pMatrix);
                egret3d.Matrix.multiply(this.pMatrix, this.vMatrix, this.mvpMatrix);
                m = m || new egret3d.Matrix();
                egret3d.Matrix.copy(m, this.mMatrix);
                egret3d.Matrix.multiply(this.mvpMatrix, this.mMatrix, this.mvpMatrix);
            };
            Gizmo.initPrg = function () {
                this.glProgram_line = new editor.GizmoShader(this.webgl, editor.line_vert, editor.line_frag);
                this.glProgram_icon = new editor.GizmoShader(this.webgl, editor.icon_vert, editor.icon_frag);
            };
            Gizmo.getAllLightAndCamera = function () {
                this.lightPool = [];
                var lightSystem = paper.Application.systemManager.getSystem(egret3d.LightSystem);
                var lights = lightSystem.components;
                for (var i = 0; i < lights.length; i++)
                    this.lightPool.push(lights[i].gameObject);
                this.cameraPool = [];
                var allGameObj = paper.Application.sceneManager.activeScene.gameObjects;
                for (var i = 0; i < allGameObj.length; i++) {
                    if (allGameObj[i].getComponent(egret3d.Camera)) {
                        if (allGameObj[i].tag != "EditorCamera")
                            this.cameraPool.push(allGameObj[i]);
                    }
                }
            };
            Gizmo.DrawLights = function () {
                if (!this._enabled)
                    return;
                var gl = this.webgl;
                for (var i = 0; i < this.lightPool.length; i++) {
                    var light = this.lightPool[i].getComponent(egret3d.BaseLight, true);
                    Gizmo.DrawIcon("light", this.lightPool[i].transform.getPosition(), 30, light.color);
                    Gizmo.DrawCylinder(this.lightPool[i].transform, light.color);
                }
            };
            Gizmo.DrawCylinder = function (transform, color) {
                if (!this._enabled)
                    return;
                egret3d.WebGLKit.zTest(true);
                var gl = this.webgl;
                var prg = this.glProgram_line;
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.cylinderVertexBuffer);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                var m = this.helpMat;
                this.getWorldMatrixWithoutScale(transform, 15, m);
                this.setMVPMatrix(m);
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", [color.r, color.g, color.b, color.a]);
                gl.drawArrays(gl.LINES, 0, 24);
            };
            Gizmo.DrawCameras = function () {
                if (!this._enabled)
                    return;
                var gl = this.webgl;
                for (var i = 0; i < this.cameraPool.length; i++) {
                    Gizmo.DrawIcon("camera", this.cameraPool[i].transform.getPosition(), 30);
                    //Gizmo.DrawCameraSquare(this.cameraPool[i], [1.0, 0.0, 1.0, 1.0]);
                }
            };
            Gizmo.DrawCameraSquare = function (obj, color) {
                if (!this._enabled)
                    return;
                egret3d.WebGLKit.zTest(true);
                var gl = this.webgl;
                var prg = this.glProgram_line;
                this.getCameraSquare(obj);
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.cameraVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesCameraSquare), gl.STATIC_DRAW);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                this.setMVPMatrix();
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", color);
                var indices = [1, 0, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7];
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.cameraIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
                gl.drawElements(gl.LINES, indices.length, gl.UNSIGNED_SHORT, 0);
                //sconsole.log(this.verticesCameraSquare);
                //gl.drawArrays(gl.LINES, 0, 24);
            };
            Gizmo.getCameraSquare = function (obj) {
                this.verticesCameraSquare = [];
                var t = obj.transform;
                var camera = obj.getComponent(egret3d.Camera);
                var forward = this.helpVec31;
                var up = this.helpVec32;
                var right = this.helpVec33;
                var nearCenter = this.helpVec34;
                var farCenter = this.helpVec35;
                t.getForward(forward);
                t.getUp(up);
                t.getRight(right);
                var cameraPos = t.getPosition();
                egret3d.Vector3.add(egret3d.Vector3.scale(forward, camera.near), cameraPos, nearCenter);
                t.getForward(forward);
                egret3d.Vector3.add(egret3d.Vector3.scale(forward, camera.far), cameraPos, farCenter);
                var asp = this.context.viewPortPixel.w / this.context.viewPortPixel.h;
                var nearH = camera.opvalue > 0 ? camera.near * Math.tan(camera.fov * 0.5) : camera.size * 0.5;
                var nearW = nearH * asp;
                var farH = camera.opvalue > 0 ? camera.far * Math.tan(camera.fov * 0.5) : camera.size * 0.5;
                var farW = farH * asp;
                var point = this.helpVec36;
                //0
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(nearCenter, egret3d.Vector3.scale(up, nearH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, nearW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //1
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(nearCenter, egret3d.Vector3.scale(up, nearH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, -nearW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //2
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(nearCenter, egret3d.Vector3.scale(up, -nearH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, -nearW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //3
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(nearCenter, egret3d.Vector3.scale(up, -nearH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, nearW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //4
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(farCenter, egret3d.Vector3.scale(up, farH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, farW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //5
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(farCenter, egret3d.Vector3.scale(up, farH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, -farW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //6
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(farCenter, egret3d.Vector3.scale(up, -farH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, -farW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //7
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(farCenter, egret3d.Vector3.scale(up, -farH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, farW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
            };
            Gizmo.DrawArrow = function (m, color, fixSize) {
                if (!this._enabled)
                    return;
                egret3d.WebGLKit.zTest(false);
                var gl = this.webgl;
                var prg = this.glProgram_line;
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.arrowVertexBuffer);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                this.setMVPMatrix(m);
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", color);
                gl.drawArrays(gl.LINES, 0, 2);
                gl.drawArrays(gl.TRIANGLES, 2, 24);
            };
            Gizmo.DrawArrowXYZ = function (transform) {
                var worldMat = Gizmo.helpMat;
                Gizmo.getWorldMatrixWithoutScale(transform, 10, worldMat);
                egret3d.Matrix.multiply(worldMat, this.xArrowMMatrix, worldMat);
                Gizmo.DrawArrow(worldMat, [1.0, 0.0, 0.0, 1.0], true);
                egret3d.Matrix.multiply(worldMat, this.yArrowMMatrix, worldMat);
                Gizmo.DrawArrow(worldMat, [0.0, 1.0, 0.0, 1.0], true);
                egret3d.Matrix.multiply(worldMat, this.zArrowMMatrix, worldMat);
                Gizmo.DrawArrow(worldMat, [0.0, 0.0, 1.0, 1.0], true);
            };
            Gizmo.getWorldMatrixWithoutScale = function (transform, fixScale, out) {
                egret3d.Matrix.identify(out);
                var p = transform.getPosition();
                var r = transform.getRotation();
                var p_c = this.camera.gameObject.transform.getPosition();
                egret3d.Vector3.subtract(p, p_c, p_c);
                var sca = egret3d.Vector3.getLength(p_c) / fixScale;
                var matS = this.helpMat1;
                egret3d.Matrix.formScale(sca, sca, sca, matS);
                egret3d.Quaternion.toMatrix(r, out);
                egret3d.Matrix.multiply(out, matS, out);
                out.rawData[12] = p.x;
                out.rawData[13] = p.y;
                out.rawData[14] = p.z;
            };
            Gizmo.initIconTexture = function () {
                for (var key in this.icons) {
                    var image = new Image();
                    image.setAttribute('src', this.icons[key]);
                    image.onload = this.loadIconTexture.bind(this, image, key);
                }
            };
            Gizmo.loadIconTexture = function (image, key) {
                var gl = this.webgl;
                var texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                this.textures[key] = texture;
                if (this.textures["camera"] && this.textures["light"]) {
                    this.imageLoaded = true;
                }
            };
            Gizmo._editorCamera = null;
            Gizmo._enabled = false;
            Gizmo.texturePool = {};
            Gizmo.mvpMatrix = new egret3d.Matrix();
            Gizmo.mMatrix = new egret3d.Matrix();
            Gizmo.vMatrix = new egret3d.Matrix();
            Gizmo.pMatrix = new egret3d.Matrix();
            Gizmo.helpVec31 = new egret3d.Vector3();
            Gizmo.helpVec32 = new egret3d.Vector3();
            Gizmo.helpVec33 = new egret3d.Vector3();
            Gizmo.helpVec34 = new egret3d.Vector3();
            Gizmo.helpVec35 = new egret3d.Vector3();
            Gizmo.helpVec36 = new egret3d.Vector3();
            Gizmo.xArrowMMatrix = new egret3d.Matrix();
            Gizmo.yArrowMMatrix = new egret3d.Matrix(new Float32Array([
                0, 1, 0, 0,
                -1, 0, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]));
            Gizmo.zArrowMMatrix = new egret3d.Matrix(new Float32Array([
                0, 0, 1, 0,
                0, 1, 0, 0,
                -1, 0, 0, 0,
                0, 0, 0, 1
            ]));
            Gizmo.helpMat = new egret3d.Matrix();
            Gizmo.helpMat1 = new egret3d.Matrix();
            Gizmo.fixPMat = new egret3d.Matrix();
            Gizmo.textures = {};
            Gizmo.imageLoaded = false;
            Gizmo.icons = {
                camera: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIcSURBVFhH7ZbPjtMwEMYj7vAACCFg28Rx4oQmtGnLQo/7Du1pK3Hk2BtSHwYkXoA34C34I7Fozxxoy+6yaocZx9M6u4WkFaA95JN+qu0Z21/riVOnVq1a/0oiaoMXPdlCBxpxG0xaNXlB+vHqIl7Utfo5Jl3LxU2uxpkmmjNp1RTEGfg4kZhOp/eRe8xwOHzqmnjSPXxnpjhBlIEIM5BRb40f96Ch2jCZTO6atGryVQeESjVmqCA/zGNy15/2xuv4xcuBK1N4KBNw445FZugauG/ndKr9GlJRYWBBxcn7LHveHAyOHtC4iJKLbQW0C0IlBRNemH6jTzpSQqouOFQ89iSdibLHcrKKbObYBqhGaC9qc/yaAdnKdMKjoLUe08QpvH7zFsp08fOyMI8N0DHRPqUGRJhXsWr112ME5SwWM73Jp5NTzecvFtg/+XqK0UsQ1vNvG+Ax6nN7bYBN8GPW0HVRZL44h+VqdW2cafcOYYUW9jZAAZb3uHiWxPcfZQae7Wdgmw7wYuEk5r8a8MPNBGa+OIMVGpBRfyu9rI/bL/+OAU/Sy2azOS06m81xgzItoRkmm3l7G2gGr7gwGR8LU+JbLAcvEQ29bIi8L4Li0bEBunR4TK9v2r81QCIDwiQSblwNzifYAMkNW+Dil6A2x/9ogGQvtg8HQn0wS2mxIY5LlV98pRqNRnfG4/HtXcD/CrfM9Fq1at1kOc4vVSG2+aaGzOwAAAAASUVORK5CYII=",
                light: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPcSURBVFhH3ZdLSNRRFMbn4fuZmtmYZpn0gCx6YbQokBZRq6hVL6xWUdCmICIoIYjaWBDRu3WShhUJLSKIIKISgqBWao9NlIsUwlKn33fnzDij/1HHsU0fHM693z333HPOffxnfNNBMBjcgRpCVjjiX6GwsHAJKhDpjYIAdqLCyEpHxKG8vLwgJyen2rrTR25uboPf7/+Ns31GxTBRAJmZmc2BQKC/rKys0qhpAz+Bt8inUCiUZ5xDsgAIeh5BDzCnzaj0kJ2d3YjDcFZW1imjHJIFkJGRcQf7waKiojqj0gdOH5DRz7y8vLlGeQZA6Vex+DBjLUalhtLS0iJrJoDsl+os4PiGUVqsHu48zVCEcYE+JdAfZF9qVAKS+XfgoM1nch+LnK2oqMg3OgYWvIhcsu44VFVV5RLAXYI9alQMBQUFsxm7prPk5dtBhwejdu03hr04Uonj4TftKy4ursVmP/bH0LvZmlgVQMwOBDlDh/D53bbmWklJSbGNeYMJW3D6kWaYBZ4Q/bLIiM+nM8BYG85G6Gr/ndD/owy5doWyE6joBmzf0Ayz8EsSXBsZmRqycHgCx/1MPieCyKtpdyNhgnTCluh2hHGuIFS519EgsGul/w27g3THPWRTAoemyg6OH2fPtLgWoz9OqI4CUNVu0Ve1QmxVidppgywaUUkXjwplVyWGsF9If+ZA5i3Knuw8F46KApCmEkfQKaEH+ewhWxG9xw+13zQnFJ0DBYl2DxHzDqO8/D5HRsGEVuTeWGFovcZx1D6VAKJVQl+gr8pt9/KLXNb4lIGjMzpgkwWhmyGN3V70zMHeguGJDqECtEP4k9M/Cy59cMe3ktUCtcnqKs7D+fn5bq+hEhYXrzZzjqN1DdcQcIPaKcOe2g6aKqfbr5qamhy4TnHKVA+QSh4V8ez/dbR7iml3Eugw+ibBzRE3KfRBYb+bmfhLwuLNY36IBFn4KGO6NfEVeI/tLhlEoS8ivq5gO8R4H4HoagYjox7AwXIMu5mgTDrIqtaGHOwTG31S/aoSduv0RBvnqhT/PRDYitX4fUFTt6NL35PIyBhoIkE8J8NtRiWAxR4x/tS642DV+4BcNCoefhJqYv5j2ql/F5i8GaV9PxlhXECbUM+QRY4AcLep4CC/pBcbNSMIUsIupFdZGuf5k4xTX0kAAwRy36j0QdkO6Fyg9xjl4BWAwOKnUSPcFFUoPegPBpl/RV7RTdi7ZAHoJxf2Xxh/TXd6vwOiIOt6HPWQzUajYkgWgMC8JsbfJT3xqaCuri7bmgmYKACgzDMizX+EuFswc39A/kfE/0RPAp/vL7M1A0/aWSCCAAAAAElFTkSuQmCC"
            };
            return Gizmo;
        }());
        editor.Gizmo = Gizmo;
        __reflect(Gizmo.prototype, "paper.editor.Gizmo");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var GizmoShader = (function () {
            function GizmoShader(gl, vshader, fshader) {
                this.gl = gl;
                this.prg = this.createProgram(vshader, fshader);
            }
            GizmoShader.prototype.createProgram = function (vshader, fshader) {
                var gl = this.gl;
                var prg = gl.createProgram();
                var vertexShader = this.createShader(gl.VERTEX_SHADER, vshader);
                var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fshader);
                gl.attachShader(prg, vertexShader);
                gl.attachShader(prg, fragmentShader);
                gl.linkProgram(prg);
                if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
                    alert("Could not initialise shaders");
                }
                return prg;
            };
            GizmoShader.prototype.createShader = function (type, str) {
                var gl = this.gl;
                var shader = gl.createShader(type);
                gl.shaderSource(shader, str);
                gl.compileShader(shader);
                var parameter = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                if (!parameter) {
                    if (confirm("shader compile:" + gl.getShaderInfoLog(shader) + "\n")) {
                        gl.deleteShader(shader);
                    }
                    return null;
                }
                return shader;
            };
            GizmoShader.prototype.use = function () {
                egret3d.WebGLKit.useProgram(this.prg);
            };
            GizmoShader.prototype.setFloat = function (name, value) {
                var gl = this.gl;
                gl.uniform1f(gl.getUniformLocation(this.prg, name), value);
            };
            GizmoShader.prototype.setInt = function (name, value) {
                var gl = this.gl;
                gl.uniform1i(gl.getUniformLocation(this.prg, name), value);
            };
            GizmoShader.prototype.setBool = function (name, value) {
                var gl = this.gl;
                gl.uniform1i(gl.getUniformLocation(this.prg, name), value ? 1 : 0);
            };
            GizmoShader.prototype.setVec3 = function (name, value) {
                var gl = this.gl;
                gl.uniform3f(gl.getUniformLocation(this.prg, name), value.x, value.y, value.z);
            };
            GizmoShader.prototype.setVec4 = function (name, value) {
                var gl = this.gl;
                gl.uniform4f(gl.getUniformLocation(this.prg, name), value.x, value.y, value.z, value.w);
            };
            GizmoShader.prototype.setColor = function (name, value) {
                var gl = this.gl;
                gl.uniform4f(gl.getUniformLocation(this.prg, name), value[0], value[1], value[2], value[3]);
            };
            //public setColor (name: string, value: egret3d.Color) {
            //let gl = this.gl;
            //gl.uniform4f(gl.getUniformLocation(this.prg, name), value.r, value.g, value.b, value.a);
            //}
            GizmoShader.prototype.setMatrix = function (name, value) {
                var gl = this.gl;
                gl.uniformMatrix4fv(gl.getUniformLocation(this.prg, name), false, value.rawData);
            };
            GizmoShader.prototype.setTexture = function (name, value) {
                var gl = this.gl;
                gl.uniform1i(gl.getUniformLocation(this.prg, name), value);
            };
            return GizmoShader;
        }());
        editor.GizmoShader = GizmoShader;
        __reflect(GizmoShader.prototype, "paper.editor.GizmoShader");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        editor.icon_frag = "\n        #ifdef GL_ES\n        precision highp float;\n        #endif\n        uniform sampler2D PointTexture;\n        uniform bool hasColor;\n        uniform vec4 iconColor;\n        void main(void) {\n            vec4 tex = texture2D(PointTexture, gl_PointCoord);\n            gl_FragColor = tex;\n            if (hasColor) {\n                if (gl_FragColor.a >= 0.1) {\n                    gl_FragColor = iconColor;\n                } else {\n                    gl_FragColor.a = 0.0;\n                }\n            }\n        }";
        editor.icon_vert = "\n        attribute vec3 aVertexPosition; \n        uniform mat4 mvpMat;\n        uniform float pointSize;\n        void main(void) {\n            gl_Position = mvpMat * vec4(aVertexPosition,1.0);\n            gl_PointSize = pointSize; \n        }";
        editor.line_frag = "\n        #ifdef GL_ES\n        precision highp float;\n        #endif\n        uniform vec4 lineColor;\n        void main(void) {\n            gl_FragColor = lineColor;\n        }";
        editor.line_vert = "\n        attribute vec3 aVertexPosition; \n        uniform mat4 mvpMat;\n        void main(void) {\n            gl_Position = mvpMat * vec4(aVertexPosition,1.0);\n        }";
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var BoxShape = (function (_super) {
            __extends(BoxShape, _super);
            function BoxShape() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._size = egret3d.Vector3.ONE.clone();
                _this._scale = egret3d.Vector3.ONE.clone();
                return _this;
            }
            BoxShape.prototype._createCollisionShape = function () {
                var btVector3 = ammo.PhysicsSystem.helpVector3A;
                btVector3.setValue(this._size.x * 0.5, this._size.y * 0.5, this._size.z * 0.5);
                var btCollisionShape = new Ammo.btBoxShape(btVector3);
                btCollisionShape.setMargin(this._margin);
                this._updateScale(btCollisionShape);
                return btCollisionShape;
            };
            BoxShape.prototype._updateScale = function (btCollisionShape) {
                var btVector3 = ammo.PhysicsSystem.helpVector3A;
                btVector3.setValue(this._scale.x, this._scale.y, this._scale.z);
                btCollisionShape.setLocalScaling(btVector3);
            };
            Object.defineProperty(BoxShape.prototype, "size", {
                /**
                 *
                 */
                get: function () {
                    return this._size;
                },
                set: function (value) {
                    if (this._btCollisionShape) {
                        console.warn("Cannot change the size after the collision shape has been created.\nSize is only the initial value.\nUse scale to change the shape of a collision shape.");
                    }
                    else {
                        this._size.copy(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BoxShape.prototype, "scale", {
                /**
                 *
                 */
                get: function () {
                    return this._scale;
                },
                set: function (value) {
                    this._scale.copy(value);
                    if (this._btCollisionShape) {
                        this._updateScale(this._btCollisionShape);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], BoxShape.prototype, "_size", void 0);
            __decorate([
                paper.serializedField
            ], BoxShape.prototype, "_scale", void 0);
            return BoxShape;
        }(ammo.CollisionShape));
        ammo.BoxShape = BoxShape;
        __reflect(BoxShape.prototype, "egret3d.ammo.BoxShape");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var CapsuleShape = (function (_super) {
            __extends(CapsuleShape, _super);
            function CapsuleShape() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._upAxis = 1 /* Y */;
                _this._radius = 1.0;
                _this._height = 1.0;
                _this._scale = egret3d.Vector3.ONE.clone();
                return _this;
            }
            CapsuleShape.prototype._createCollisionShape = function () {
                var btCollisionShape;
                switch (this._upAxis) {
                    case 0 /* X */:
                        btCollisionShape = new Ammo.btCapsuleShapeX(this._radius, this._height);
                        break;
                    case 1 /* Y */:
                    default:
                        btCollisionShape = new Ammo.btCapsuleShape(this._radius, this._height);
                        break;
                    case 2 /* Z */:
                        btCollisionShape = new Ammo.btCapsuleShapeZ(this._radius, this._height);
                        break;
                }
                btCollisionShape.setMargin(this._margin);
                this._updateScale(btCollisionShape);
                return btCollisionShape;
            };
            CapsuleShape.prototype._updateScale = function (btCollisionShape) {
                var btVector3 = ammo.PhysicsSystem.helpVector3A;
                btVector3.setValue(this._scale.x, this._scale.y, this._scale.z);
                btCollisionShape.setLocalScaling(btVector3);
            };
            Object.defineProperty(CapsuleShape.prototype, "upAxis", {
                /**
                 *
                 */
                get: function () {
                    return this._upAxis;
                },
                set: function (value) {
                    if (this._upAxis === value) {
                        return;
                    }
                    if (this._btCollisionShape) {
                        console.warn("Cannot change the up axis after the collision shape has been created.");
                    }
                    else {
                        this._upAxis = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CapsuleShape.prototype, "radius", {
                /**
                 *
                 */
                get: function () {
                    return this._radius;
                },
                set: function (value) {
                    if (this._radius === value) {
                        return;
                    }
                    if (this._btCollisionShape) {
                        console.warn("Cannot change the radius after the collision shape has been created.");
                    }
                    else {
                        this._radius = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CapsuleShape.prototype, "height", {
                /**
                 *
                 */
                get: function () {
                    return this._height;
                },
                set: function (value) {
                    if (this._height === value) {
                        return;
                    }
                    if (this._btCollisionShape) {
                        console.warn("Cannot change the height after the collision shape has been created.");
                    }
                    else {
                        this._height = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CapsuleShape.prototype, "scale", {
                /**
                 *
                 */
                get: function () {
                    return this._scale;
                },
                set: function (value) {
                    this._scale.copy(value);
                    if (this._btCollisionShape) {
                        this._updateScale(this._btCollisionShape);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], CapsuleShape.prototype, "_upAxis", void 0);
            __decorate([
                paper.serializedField
            ], CapsuleShape.prototype, "_radius", void 0);
            __decorate([
                paper.serializedField
            ], CapsuleShape.prototype, "_height", void 0);
            __decorate([
                paper.serializedField
            ], CapsuleShape.prototype, "_scale", void 0);
            return CapsuleShape;
        }(ammo.CollisionShape));
        ammo.CapsuleShape = CapsuleShape;
        __reflect(CapsuleShape.prototype, "egret3d.ammo.CapsuleShape");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var ConeShape = (function (_super) {
            __extends(ConeShape, _super);
            function ConeShape() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._upAxis = 1 /* Y */;
                _this._radius = 1.0;
                _this._height = 1.0;
                _this._scale = egret3d.Vector3.ONE.clone();
                return _this;
            }
            ConeShape.prototype._createCollisionShape = function () {
                var btCollisionShape;
                switch (this._upAxis) {
                    case 0 /* X */:
                        btCollisionShape = new Ammo.btConeShapeX(this._radius, this._height);
                        break;
                    case 1 /* Y */:
                    default:
                        btCollisionShape = new Ammo.btConeShape(this._radius, this._height);
                        break;
                    case 2 /* Z */:
                        btCollisionShape = new Ammo.btConeShapeZ(this._radius, this._height);
                        break;
                }
                btCollisionShape.setMargin(this._margin);
                this._updateScale(btCollisionShape);
                return btCollisionShape;
            };
            ConeShape.prototype._updateScale = function (btCollisionShape) {
                var btVector3 = ammo.PhysicsSystem.helpVector3A;
                btVector3.setValue(this._scale.x, this._scale.y, this._scale.z);
                btCollisionShape.setLocalScaling(btVector3);
            };
            Object.defineProperty(ConeShape.prototype, "upAxis", {
                /**
                 *
                 */
                get: function () {
                    return this._upAxis;
                },
                set: function (value) {
                    if (this._upAxis === value) {
                        return;
                    }
                    if (this._btCollisionShape) {
                        console.warn("Cannot change the up axis after the collision shape has been created.");
                    }
                    else {
                        this._upAxis = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeShape.prototype, "radius", {
                /**
                 *
                 */
                get: function () {
                    return this._radius;
                },
                set: function (value) {
                    if (this._radius === value) {
                        return;
                    }
                    if (this._btCollisionShape) {
                        console.warn("Cannot change the radius after the collision shape has been created.");
                    }
                    else {
                        this._radius = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeShape.prototype, "height", {
                /**
                 *
                 */
                get: function () {
                    return this._height;
                },
                set: function (value) {
                    if (this._height === value) {
                        return;
                    }
                    if (this._btCollisionShape) {
                        console.warn("Cannot change the height after the collision shape has been created.");
                    }
                    else {
                        this._height = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeShape.prototype, "scale", {
                /**
                 *
                 */
                get: function () {
                    return this._scale;
                },
                set: function (value) {
                    this._scale.copy(value);
                    if (this._btCollisionShape) {
                        this._updateScale(this._btCollisionShape);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ConeShape.prototype, "_upAxis", void 0);
            __decorate([
                paper.serializedField
            ], ConeShape.prototype, "_radius", void 0);
            __decorate([
                paper.serializedField
            ], ConeShape.prototype, "_height", void 0);
            __decorate([
                paper.serializedField
            ], ConeShape.prototype, "_scale", void 0);
            return ConeShape;
        }(ammo.CollisionShape));
        ammo.ConeShape = ConeShape;
        __reflect(ConeShape.prototype, "egret3d.ammo.ConeShape");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var ConvexHullShape = (function (_super) {
            __extends(ConvexHullShape, _super);
            function ConvexHullShape() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._scale = egret3d.Vector3.ONE.clone();
                return _this;
            }
            ConvexHullShape.prototype._createCollisionShape = function () {
                var meshFilter = this.gameObject.getComponent(egret3d.MeshFilter);
                if (meshFilter && meshFilter.mesh) {
                    var btVector3 = ammo.PhysicsSystem.helpVector3A;
                    var btCollisionShape = new Ammo.btConvexHullShape();
                    var vertices = meshFilter.mesh.getVertices();
                    for (var i = 0, l = vertices.length; i < l; i += 3) {
                        btVector3.setValue(vertices[i], vertices[i + 1], vertices[i + 2]);
                        btCollisionShape.addPoint(btVector3, i === l - 1);
                    }
                    btCollisionShape.setMargin(this._margin);
                    this._updateScale(btCollisionShape);
                    return btCollisionShape;
                }
                throw new Error("Arguments error.");
            };
            ConvexHullShape.prototype._updateScale = function (btCollisionShape) {
                var btVector3 = ammo.PhysicsSystem.helpVector3A;
                btVector3.setValue(this._scale.x, this._scale.y, this._scale.z);
                btCollisionShape.setLocalScaling(btVector3);
            };
            Object.defineProperty(ConvexHullShape.prototype, "scale", {
                /**
                 *
                 */
                get: function () {
                    return this._scale;
                },
                set: function (value) {
                    this._scale.copy(value);
                    if (this._btCollisionShape) {
                        this._updateScale(this._btCollisionShape);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ConvexHullShape.prototype, "_scale", void 0);
            return ConvexHullShape;
        }(ammo.CollisionShape));
        ammo.ConvexHullShape = ConvexHullShape;
        __reflect(ConvexHullShape.prototype, "egret3d.ammo.ConvexHullShape");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var CylinderShape = (function (_super) {
            __extends(CylinderShape, _super);
            function CylinderShape() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._upAxis = 1 /* Y */;
                _this._size = egret3d.Vector3.ONE.clone();
                _this._scale = egret3d.Vector3.ONE.clone();
                return _this;
            }
            CylinderShape.prototype._createCollisionShape = function () {
                var btVector3 = ammo.PhysicsSystem.helpVector3A;
                btVector3.setValue(this._size.x * 0.5, this._size.y * 0.5, this._size.z * 0.5);
                var btCollisionShape;
                switch (this._upAxis) {
                    case 0 /* X */:
                        btCollisionShape = new Ammo.btCylinderShapeX(btVector3);
                        break;
                    case 1 /* Y */:
                    default:
                        btCollisionShape = new Ammo.btCylinderShape(btVector3);
                        break;
                    case 2 /* Z */:
                        btCollisionShape = new Ammo.btCylinderShapeZ(btVector3);
                        break;
                }
                btCollisionShape.setMargin(this._margin);
                this._updateScale(btCollisionShape);
                return btCollisionShape;
            };
            CylinderShape.prototype._updateScale = function (btCollisionShape) {
                var btVector3 = ammo.PhysicsSystem.helpVector3A;
                btVector3.setValue(this._scale.x, this._scale.y, this._scale.z);
                btCollisionShape.setLocalScaling(btVector3);
            };
            Object.defineProperty(CylinderShape.prototype, "upAxis", {
                /**
                 *
                 */
                get: function () {
                    return this._upAxis;
                },
                set: function (value) {
                    if (this._upAxis === value) {
                        return;
                    }
                    if (this._btCollisionShape) {
                        console.warn("Cannot change the up axis after the collision shape has been created.");
                    }
                    else {
                        this._upAxis = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CylinderShape.prototype, "size", {
                /**
                 *
                 */
                get: function () {
                    return this._size;
                },
                set: function (value) {
                    if (this._btCollisionShape) {
                        console.warn("Cannot change the size after the collision shape has been created.\nSize is only the initial value.\nUse scale to change the shape of a collision shape.");
                    }
                    else {
                        this._size.copy(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CylinderShape.prototype, "scale", {
                /**
                 *
                 */
                get: function () {
                    return this._scale;
                },
                set: function (value) {
                    this._scale.copy(value);
                    if (this._btCollisionShape) {
                        this._updateScale(this._btCollisionShape);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], CylinderShape.prototype, "_upAxis", void 0);
            __decorate([
                paper.serializedField
            ], CylinderShape.prototype, "_size", void 0);
            __decorate([
                paper.serializedField
            ], CylinderShape.prototype, "_scale", void 0);
            return CylinderShape;
        }(ammo.CollisionShape));
        ammo.CylinderShape = CylinderShape;
        __reflect(CylinderShape.prototype, "egret3d.ammo.CylinderShape");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var SphereShape = (function (_super) {
            __extends(SphereShape, _super);
            function SphereShape() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._radius = 1.0;
                _this._scale = egret3d.Vector3.ONE.clone();
                return _this;
            }
            SphereShape.prototype._createCollisionShape = function () {
                var btCollisionShape = new Ammo.btSphereShape(this._radius);
                btCollisionShape.setMargin(this._margin);
                this._updateScale(btCollisionShape);
                return btCollisionShape;
            };
            SphereShape.prototype._updateScale = function (btCollisionShape) {
                var btVector3 = ammo.PhysicsSystem.helpVector3A;
                btVector3.setValue(this._scale.x, this._scale.y, this._scale.z);
                btCollisionShape.setLocalScaling(btVector3);
            };
            Object.defineProperty(SphereShape.prototype, "radius", {
                /**
                 *
                 */
                get: function () {
                    return this._radius;
                },
                set: function (value) {
                    if (this._radius === value) {
                        return;
                    }
                    if (this._btCollisionShape) {
                        console.warn("Cannot change the radius after the collision shape has been created.");
                    }
                    else {
                        this._radius = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SphereShape.prototype, "scale", {
                /**
                 *
                 */
                get: function () {
                    return this._scale;
                },
                set: function (value) {
                    this._scale.copy(value);
                    if (this._btCollisionShape) {
                        this._updateScale(this._btCollisionShape);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], SphereShape.prototype, "_radius", void 0);
            __decorate([
                paper.serializedField
            ], SphereShape.prototype, "_scale", void 0);
            return SphereShape;
        }(ammo.CollisionShape));
        ammo.SphereShape = SphereShape;
        __reflect(SphereShape.prototype, "egret3d.ammo.SphereShape");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         * TODO
         */
        var HeightfieldTerrainShape = (function (_super) {
            __extends(HeightfieldTerrainShape, _super);
            function HeightfieldTerrainShape() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._upAxis = 1 /* Y */;
                return _this;
            }
            HeightfieldTerrainShape.prototype._createCollisionShape = function () {
                var meshFilter = this.gameObject.getComponent(egret3d.MeshFilter);
                if (meshFilter && meshFilter.mesh) {
                    var vertices = meshFilter.mesh.getVertices();
                    var btCollisionShape = new Ammo.btHeightfieldTerrainShape(0, 0, null, 1.0, 0.0, 1.0, this._upAxis, "PHY_FLOAT", false);
                    btCollisionShape.setMargin(this._margin);
                    return btCollisionShape;
                }
                throw new Error("Arguments error.");
            };
            Object.defineProperty(HeightfieldTerrainShape.prototype, "upAxis", {
                /**
                 *
                 */
                get: function () {
                    return this._upAxis;
                },
                set: function (value) {
                    if (this._upAxis === value) {
                        return;
                    }
                    if (this._btCollisionShape) {
                        console.warn("Cannot change the up axis after the collision shape has been created.");
                    }
                    else {
                        this._upAxis = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], HeightfieldTerrainShape.prototype, "_upAxis", void 0);
            return HeightfieldTerrainShape;
        }(ammo.CollisionShape));
        ammo.HeightfieldTerrainShape = HeightfieldTerrainShape;
        __reflect(HeightfieldTerrainShape.prototype, "egret3d.ammo.HeightfieldTerrainShape");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var KEY_GAMEOBJECTS = "gameObjects";
    var KEY_COMPONENTS = "components";
    var KEY_CHILDREN = "children";
    var KEY_SERIALIZE = "serialize";
    var KEY_DESERIALIZE = "deserialize";
    var _sourcePath = "";
    var _serializeds = []; // 缓存序列化记录，提高查找效率
    var _serializeData = null;
    /**
     * 序列化方法
     * 只有 ISerializable 参与序列化
     * 只有被标记的对象属性 参与序列化
     * 序列化后，输出 ISerializeData
     * 对象在objects中按生成顺序，root一定是第一个元素。
     * 允许依赖标记对序列化对象数据分类，以便单独处理一些对象（例如资源等等，但资源的路径这里不做处理，在方法外由开发者自行处理）
     */
    function serialize(source, sourcePath) {
        if (sourcePath === void 0) { sourcePath = ""; }
        _serializeData = { objects: [] };
        _sourcePath = sourcePath;
        if (!_sourcePath && source instanceof paper.Scene) {
            var rawScene = source.rawScene;
            _sourcePath = rawScene ? rawScene.url : "";
        }
        _serializeObject(source);
        _serializeds.length = 0;
        var data = _serializeData;
        _serializeData = null;
        return data;
    }
    paper.serialize = serialize;
    /**
     *
     */
    function serializeAsset(source) {
        var target = _serializeObject(source);
        if (_sourcePath && source._isLoad) {
            target.url = egret3d.utils.getRelativePath(source.url, _sourcePath);
        }
        if (!source.url) {
            return null;
        }
        return serializeR(source);
    }
    paper.serializeAsset = serializeAsset;
    /**
     *
     */
    function serializeRC(source) {
        var className = egret.getQualifiedClassName(source);
        return { uuid: source.uuid, class: paper.findClassCode(className) || className };
    }
    paper.serializeRC = serializeRC;
    /**
     *
     */
    function serializeR(source) {
        return { uuid: source.uuid };
    }
    paper.serializeR = serializeR;
    /**
     *
     */
    function serializeC(source) {
        var className = egret.getQualifiedClassName(source);
        return { class: paper.findClassCode(className) || className };
    }
    paper.serializeC = serializeC;
    /**
     *
     */
    function getTypesFromPrototype(classPrototype, typeKey, types) {
        if (types === void 0) { types = null; }
        if ((typeKey in classPrototype)) {
            types = types || [];
            for (var _i = 0, _a = classPrototype[typeKey]; _i < _a.length; _i++) {
                var type = _a[_i];
                types.push(type);
            }
        }
        if (classPrototype.__proto__) {
            getTypesFromPrototype(classPrototype.__proto__, typeKey, types);
        }
        return types;
    }
    paper.getTypesFromPrototype = getTypesFromPrototype;
    function _serializeObject(source, isStruct, parentHasCustomDeserialize) {
        if (isStruct === void 0) { isStruct = false; }
        if (parentHasCustomDeserialize === void 0) { parentHasCustomDeserialize = false; }
        if (_serializeds.indexOf(source.uuid) >= 0) {
            return serializeR(source);
        }
        var classPrototype = source.constructor.prototype;
        var hasCustomSerialize = classPrototype.hasOwnProperty(KEY_SERIALIZE);
        var target = hasCustomSerialize ?
            classPrototype[KEY_SERIALIZE].apply(source) :
            (parentHasCustomDeserialize ? {} : (isStruct ? serializeC(source) : serializeRC(source)));
        if (!isStruct && _serializeData) {
            _serializeds.push(source.uuid);
            // Add to custom.
            if ("__serializedType" /* SerializedType */ in source) {
                for (var _i = 0, _a = source["__serializedType" /* SerializedType */]; _i < _a.length; _i++) {
                    var type = _a[_i];
                    if (type in _serializeData) {
                        _serializeData[type].push(target);
                    }
                    else {
                        _serializeData[type] = [target];
                    }
                }
            }
            else {
                _serializeData.objects.push(target);
            }
        }
        if (!hasCustomSerialize) {
            var serializedKeys = getTypesFromPrototype(classPrototype, "__serialized" /* Serialized */);
            if (serializedKeys && serializedKeys.length > 0) {
                for (var _b = 0, serializedKeys_1 = serializedKeys; _b < serializedKeys_1.length; _b++) {
                    var key = serializedKeys_1[_b];
                    target[key] = _serializeChild(source[key], source, key);
                }
            }
        }
        return target;
    }
    function _serializeChild(source, parent, key) {
        if (source === null || source === undefined) {
            return source;
        }
        switch (typeof source) {
            case "function":
                return undefined;
            case "object": {
                if (Array.isArray(source) || ArrayBuffer.isView(source)) {
                    var target = [];
                    for (var _i = 0, _a = source; _i < _a.length; _i++) {
                        var element = _a[_i];
                        target.push(_serializeChild(element, parent, key));
                    }
                    return target;
                }
                if (source.constructor === Object) {
                    var target = {};
                    for (var k in source) {
                        target[k] = _serializeChild(source[k], parent, key);
                    }
                    return target;
                }
                // TODO es6
                if (source instanceof paper.Asset) {
                    return serializeAsset(source);
                }
                if (source instanceof paper.Scene || source instanceof paper.GameObject || source instanceof paper.BaseComponent) {
                    if (parent) {
                        if (parent instanceof paper.Scene) {
                            if (key === KEY_GAMEOBJECTS) {
                                _serializeObject(source);
                                return serializeR(source);
                            }
                        }
                        else if (parent instanceof paper.GameObject) {
                            if (key === KEY_COMPONENTS) {
                                _serializeObject(source);
                                return serializeR(source);
                            }
                        }
                        else if (parent instanceof egret3d.Transform) {
                            if (key === KEY_CHILDREN) {
                                _serializeObject(source.gameObject);
                                return serializeR(source);
                            }
                        }
                    }
                    return serializeRC(source);
                }
                return _serializeObject(source, true, parent && parent.constructor.prototype.hasOwnProperty(KEY_DESERIALIZE)); // Other class.
            }
            default:
                return source;
        }
    }
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var FixedConstraint = (function (_super) {
            __extends(FixedConstraint, _super);
            function FixedConstraint() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            FixedConstraint.prototype._createConstraint = function () {
                this._rigidbody = this.gameObject.getComponent(ammo.Rigidbody);
                if (!this._rigidbody) {
                    console.debug("Never.");
                    return null;
                }
                if (!this._connectedBody) {
                    console.error("The constraint need to config another rigid body.", this.gameObject.name, this.gameObject.uuid);
                    return null;
                }
                //
                var helpMatrixA = ammo.TypedConstraint._helpMatrixA;
                var helpMatrixB = ammo.TypedConstraint._helpMatrixB;
                this._createFrames(helpMatrixA, helpMatrixB);
                var helpVector3A = ammo.PhysicsSystem.helpVector3A;
                var helpQuaternionA = ammo.PhysicsSystem.helpQuaternionA;
                var helpTransformA = ammo.PhysicsSystem.helpTransformA;
                var helpTransformB = ammo.PhysicsSystem.helpTransformB;
                //
                var helpQA = egret3d.Matrix.getQuaternion(helpMatrixA, ammo.TypedConstraint._helpQuaternionA);
                helpVector3A.setValue(helpMatrixA.rawData[12], helpMatrixA.rawData[13], helpMatrixA.rawData[14]);
                helpQuaternionA.setValue(helpQA.x, helpQA.y, helpQA.z, helpQA.w);
                helpTransformA.setIdentity();
                helpTransformA.setOrigin(helpVector3A);
                helpTransformA.setRotation(helpQuaternionA);
                //
                var helpQB = egret3d.Matrix.getQuaternion(helpMatrixB, ammo.TypedConstraint._helpQuaternionA);
                helpVector3A.setValue(helpMatrixB.rawData[12], helpMatrixB.rawData[13], helpMatrixB.rawData[14]);
                helpQuaternionA.setValue(helpQB.x, helpQB.y, helpQB.z, helpQB.w);
                helpTransformB.setIdentity();
                helpTransformB.setOrigin(helpVector3A);
                helpTransformB.setRotation(helpQuaternionA);
                //
                var btConstraint = new Ammo.btFixedConstraint(this._rigidbody.btRigidbody, this._connectedBody.btRigidbody, helpTransformA, helpTransformB);
                btConstraint.setBreakingImpulseThreshold(this._breakingImpulseThreshold);
                // btConstraint.setOverrideNumSolverIterations(this._overrideNumSolverIterations);
                return btConstraint;
            };
            return FixedConstraint;
        }(ammo.TypedConstraint));
        ammo.FixedConstraint = FixedConstraint;
        __reflect(FixedConstraint.prototype, "egret3d.ammo.FixedConstraint");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var SliderConstraint = (function (_super) {
            __extends(SliderConstraint, _super);
            function SliderConstraint() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._lowerLinearLimit = -10.0;
                _this._upperLinearLimit = 10.0;
                _this._lowerAngularLimit = -Math.PI;
                _this._upperAngularLimit = Math.PI;
                return _this;
            }
            SliderConstraint.prototype._createConstraint = function () {
                this._rigidbody = this.gameObject.getComponent(ammo.Rigidbody);
                if (!this._rigidbody) {
                    console.debug("Never.");
                    return null;
                }
                var helpVector3A = ammo.PhysicsSystem.helpVector3A;
                var helpQuaternionA = ammo.PhysicsSystem.helpQuaternionA;
                var helpTransformA = ammo.PhysicsSystem.helpTransformA;
                var helpTransformB = ammo.PhysicsSystem.helpTransformB;
                var helpMatrixA = ammo.TypedConstraint._helpMatrixA;
                var helpMatrixB = ammo.TypedConstraint._helpMatrixB;
                var btConstraint;
                if (this._constraintType === 1 /* ConstrainToAnotherBody */) {
                    if (!this._connectedBody) {
                        console.error("The constraint need to config another rigid body.", this.gameObject.name, this.gameObject.uuid);
                        return null;
                    }
                    this._createFrames(helpMatrixA, helpMatrixB);
                    //
                    var helpQA = egret3d.Matrix.getQuaternion(helpMatrixA, ammo.TypedConstraint._helpQuaternionA);
                    helpVector3A.setValue(helpMatrixA.rawData[8], helpMatrixA.rawData[9], helpMatrixA.rawData[10]);
                    helpQuaternionA.setValue(helpQA.x, helpQA.y, helpQA.z, helpQA.w);
                    helpTransformA.setIdentity();
                    helpTransformA.setOrigin(helpVector3A);
                    helpTransformA.setRotation(helpQuaternionA);
                    //
                    var helpQB = egret3d.Matrix.getQuaternion(helpMatrixB, ammo.TypedConstraint._helpQuaternionA);
                    helpVector3A.setValue(helpMatrixB.rawData[8], helpMatrixB.rawData[9], helpMatrixB.rawData[10]);
                    helpQuaternionA.setValue(helpQB.x, helpQB.y, helpQB.z, helpQB.w);
                    helpTransformB.setIdentity();
                    helpTransformB.setOrigin(helpVector3A);
                    helpTransformB.setRotation(helpQuaternionA);
                    //
                    btConstraint = new Ammo.btSliderConstraint(this._rigidbody.btRigidbody, this._connectedBody.btRigidbody, helpTransformA, helpTransformB, true);
                }
                else {
                    this._createFrame(this._axisX, this._axisY, this._anchor, helpMatrixA);
                    //
                    var helpQA = egret3d.Matrix.getQuaternion(helpMatrixA, ammo.TypedConstraint._helpQuaternionA);
                    helpVector3A.setValue(helpMatrixA.rawData[8], helpMatrixA.rawData[9], helpMatrixA.rawData[10]);
                    helpQuaternionA.setValue(helpQA.x, helpQA.y, helpQA.z, helpQA.w);
                    helpTransformA.setIdentity();
                    helpTransformA.setOrigin(helpVector3A);
                    helpTransformA.setRotation(helpQuaternionA);
                    btConstraint = new Ammo.btSliderConstraint(this._rigidbody.btRigidbody, helpTransformA, true);
                }
                btConstraint.setLowerLinLimit(this._lowerLinearLimit);
                btConstraint.setUpperLinLimit(this._upperLinearLimit);
                btConstraint.setLowerAngLimit(this._lowerAngularLimit);
                btConstraint.setUpperAngLimit(this._upperAngularLimit);
                btConstraint.setBreakingImpulseThreshold(this._breakingImpulseThreshold);
                // btConstraint.setOverrideNumSolverIterations(this._overrideNumSolverIterations);
                return btConstraint;
            };
            Object.defineProperty(SliderConstraint.prototype, "lowerLinearLimit", {
                /**
                 *
                 */
                get: function () {
                    return this._lowerLinearLimit;
                },
                set: function (value) {
                    if (this._lowerLinearLimit === value) {
                        return;
                    }
                    this._lowerLinearLimit = value;
                    if (this._btTypedConstraint) {
                        this._btTypedConstraint.setLowerLinLimit(this._lowerLinearLimit);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SliderConstraint.prototype, "upperLinearLimit", {
                /**
                 *
                 */
                get: function () {
                    return this._upperLinearLimit;
                },
                set: function (value) {
                    if (this._upperLinearLimit === value) {
                        return;
                    }
                    this._upperLinearLimit = value;
                    if (this._btTypedConstraint) {
                        this._btTypedConstraint.setUpperLinLimit(this._upperLinearLimit);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SliderConstraint.prototype, "lowerAngularLimit", {
                /**
                 *
                 */
                get: function () {
                    return this._lowerAngularLimit;
                },
                set: function (value) {
                    if (this._lowerAngularLimit === value) {
                        return;
                    }
                    this._lowerAngularLimit = value;
                    if (this._btTypedConstraint) {
                        this._btTypedConstraint.setLowerAngLimit(this._lowerAngularLimit);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SliderConstraint.prototype, "upperAngularLimit", {
                /**
                 *
                 */
                get: function () {
                    return this._upperAngularLimit;
                },
                set: function (value) {
                    if (this._upperAngularLimit === value) {
                        return;
                    }
                    this._upperAngularLimit = value;
                    if (this._btTypedConstraint) {
                        this._btTypedConstraint.setUpperAngLimit(this._upperAngularLimit);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], SliderConstraint.prototype, "_lowerLinearLimit", void 0);
            __decorate([
                paper.serializedField
            ], SliderConstraint.prototype, "_upperLinearLimit", void 0);
            __decorate([
                paper.serializedField
            ], SliderConstraint.prototype, "_lowerAngularLimit", void 0);
            __decorate([
                paper.serializedField
            ], SliderConstraint.prototype, "_upperAngularLimit", void 0);
            return SliderConstraint;
        }(ammo.TypedConstraint));
        ammo.SliderConstraint = SliderConstraint;
        __reflect(SliderConstraint.prototype, "egret3d.ammo.SliderConstraint");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var HingeConstraint = (function (_super) {
            __extends(HingeConstraint, _super);
            function HingeConstraint() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._motorEnabled = false;
                _this._limitEnabled = false;
                _this._targetVelocity = 0.0;
                _this._maxMotorImpulse = 0.0;
                _this._lowAngular = 0.0;
                _this._highAngular = 0.0;
                _this._softness = 0.9;
                _this._biasFactor = 0.3;
                _this._relaxationFactor = 0.0;
                return _this;
            }
            HingeConstraint.prototype._updateLimit = function () {
                this._btTypedConstraint.setLimit(this._lowAngular, this._highAngular, this._softness, this._biasFactor, this._relaxationFactor);
            };
            HingeConstraint.prototype._createConstraint = function () {
                this._rigidbody = this.gameObject.getComponent(ammo.Rigidbody);
                if (!this._rigidbody) {
                    console.debug("Never.");
                    return null;
                }
                var btConstraint;
                if (this._constraintType === 1 /* ConstrainToAnotherBody */) {
                    if (!this._connectedBody) {
                        console.error("The constraint need to config another rigid body.", this.gameObject.name, this.gameObject.uuid);
                        return null;
                    }
                    var helpMatrixA_1 = ammo.TypedConstraint._helpMatrixA;
                    var helpMatrixB_1 = ammo.TypedConstraint._helpMatrixB;
                    this._createFrames(helpMatrixA_1, helpMatrixB_1);
                    var helpVertex3A = ammo.PhysicsSystem.helpVector3A;
                    var helpVertex3B = ammo.PhysicsSystem.helpVector3B;
                    var helpVertex3C = ammo.PhysicsSystem.helpVector3C;
                    var helpVertex3D = ammo.PhysicsSystem.helpVector3D;
                    helpVertex3A.setValue(helpMatrixA_1.rawData[12], helpMatrixA_1.rawData[13], helpMatrixA_1.rawData[14]);
                    helpVertex3B.setValue(helpMatrixB_1.rawData[12], helpMatrixB_1.rawData[13], helpMatrixB_1.rawData[14]);
                    helpVertex3C.setValue(helpMatrixA_1.rawData[0], helpMatrixA_1.rawData[4], helpMatrixA_1.rawData[8]);
                    helpVertex3D.setValue(helpMatrixB_1.rawData[0], helpMatrixB_1.rawData[4], helpMatrixB_1.rawData[8]);
                    //
                    btConstraint = new Ammo.btHingeConstraint(this._rigidbody.btRigidbody, this._connectedBody.btRigidbody, helpVertex3A, helpVertex3B, helpVertex3C, helpVertex3D, true);
                }
                else {
                    var helpVertex3A = ammo.PhysicsSystem.helpVector3A;
                    var helpVertex3B = ammo.PhysicsSystem.helpVector3B;
                    helpVertex3A.setValue(this._anchor.x, this._anchor.y, this._anchor.z);
                    helpVertex3B.setValue(this._axisX.x, this._axisX.y, this._axisX.z);
                    btConstraint = new Ammo.btHingeConstraint(this._rigidbody.btRigidbody, helpVertex3A, helpVertex3B, true);
                }
                if (this._motorEnabled) {
                    btConstraint.enableAngularMotor(this._motorEnabled, this._targetVelocity, this._maxMotorImpulse);
                }
                if (this._limitEnabled) {
                    this._updateLimit();
                }
                btConstraint.setBreakingImpulseThreshold(this._breakingImpulseThreshold);
                // btConstraint.setOverrideNumSolverIterations(this._overrideNumSolverIterations);
                return btConstraint;
            };
            Object.defineProperty(HingeConstraint.prototype, "motorEnabled", {
                /**
                 *
                 */
                get: function () {
                    return this._motorEnabled;
                },
                set: function (value) {
                    if (this._motorEnabled === value) {
                        return;
                    }
                    this._motorEnabled = value;
                    if (this._btTypedConstraint) {
                        this._btTypedConstraint.enableMotor(this._motorEnabled);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeConstraint.prototype, "targetVelocity", {
                /**
                 *
                 */
                get: function () {
                    return this._targetVelocity;
                },
                set: function (value) {
                    if (this._targetVelocity === value) {
                        return;
                    }
                    this._targetVelocity = value;
                    if (this._btTypedConstraint && this._motorEnabled) {
                        this._btTypedConstraint.enableAngularMotor(this._motorEnabled, this._targetVelocity, this._maxMotorImpulse);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeConstraint.prototype, "maxMotorImpulse", {
                /**
                 *
                 */
                get: function () {
                    return this._maxMotorImpulse;
                },
                set: function (value) {
                    if (this._maxMotorImpulse === value) {
                        return;
                    }
                    this._maxMotorImpulse = value;
                    if (this._btTypedConstraint && this._motorEnabled) {
                        this._btTypedConstraint.setMaxMotorImpulse(this._maxMotorImpulse);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeConstraint.prototype, "limitEnabled", {
                /**
                 *
                 */
                get: function () {
                    return this._limitEnabled;
                },
                set: function (value) {
                    if (this._limitEnabled === value) {
                        return;
                    }
                    this._limitEnabled = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeConstraint.prototype, "lowAngularLimit", {
                /**
                 *
                 */
                get: function () {
                    return this._lowAngular;
                },
                set: function (value) {
                    if (this._lowAngular === value) {
                        return;
                    }
                    this._lowAngular = value;
                    if (this._btTypedConstraint && this._limitEnabled) {
                        this._updateLimit();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeConstraint.prototype, "highAngularLimit", {
                /**
                 *
                 */
                get: function () {
                    return this._highAngular;
                },
                set: function (value) {
                    if (this._highAngular === value) {
                        return;
                    }
                    this._highAngular = value;
                    if (this._btTypedConstraint && this._limitEnabled) {
                        this._updateLimit();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeConstraint.prototype, "softnessLimit", {
                /**
                 *
                 */
                get: function () {
                    return this._softness;
                },
                set: function (value) {
                    if (this._softness === value) {
                        return;
                    }
                    this._softness = value;
                    if (this._btTypedConstraint && this._limitEnabled) {
                        this._updateLimit();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeConstraint.prototype, "biasFactorLimit", {
                /**
                 *
                 */
                get: function () {
                    return this._biasFactor;
                },
                set: function (value) {
                    if (this._biasFactor === value) {
                        return;
                    }
                    this._biasFactor = value;
                    if (this._btTypedConstraint && this._limitEnabled) {
                        this._updateLimit();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeConstraint.prototype, "relaxationFactor", {
                /**
                 *
                 */
                get: function () {
                    return this._relaxationFactor;
                },
                set: function (value) {
                    if (this._relaxationFactor === value) {
                        return;
                    }
                    this._relaxationFactor = value;
                    if (this._btTypedConstraint && this._limitEnabled) {
                        this._updateLimit();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeConstraint.prototype, "hingeAngle", {
                /**
                 *
                 */
                get: function () {
                    if (this._btTypedConstraint) {
                        return this._btTypedConstraint.getHingeAngle();
                    }
                    return 0.0;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], HingeConstraint.prototype, "_motorEnabled", void 0);
            __decorate([
                paper.serializedField
            ], HingeConstraint.prototype, "_limitEnabled", void 0);
            __decorate([
                paper.serializedField
            ], HingeConstraint.prototype, "_targetVelocity", void 0);
            __decorate([
                paper.serializedField
            ], HingeConstraint.prototype, "_maxMotorImpulse", void 0);
            __decorate([
                paper.serializedField
            ], HingeConstraint.prototype, "_lowAngular", void 0);
            __decorate([
                paper.serializedField
            ], HingeConstraint.prototype, "_highAngular", void 0);
            __decorate([
                paper.serializedField
            ], HingeConstraint.prototype, "_softness", void 0);
            __decorate([
                paper.serializedField
            ], HingeConstraint.prototype, "_biasFactor", void 0);
            __decorate([
                paper.serializedField
            ], HingeConstraint.prototype, "_relaxationFactor", void 0);
            return HingeConstraint;
        }(ammo.TypedConstraint));
        ammo.HingeConstraint = HingeConstraint;
        __reflect(HingeConstraint.prototype, "egret3d.ammo.HingeConstraint");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var ConeTwistConstraint = (function (_super) {
            __extends(ConeTwistConstraint, _super);
            function ConeTwistConstraint() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._swingSpan1 = Math.PI;
                _this._swingSpan2 = Math.PI;
                _this._twistSpan = Math.PI;
                _this._softness = 0.5;
                _this._biasFactor = 0.3;
                _this._relaxationFactor = 1.0;
                return _this;
            }
            ConeTwistConstraint.prototype._updateLimit = function (btConstraint) {
                btConstraint.setLimit(5, this._swingSpan1);
                btConstraint.setLimit(4, this._swingSpan2);
                btConstraint.setLimit(3, this._twistSpan);
                // btConstraint.setLimit(this._swingSpanX, this._swingSpanY, this._twistSpan, this._softness, this._biasFactor, this._relaxationFactor);
            };
            ConeTwistConstraint.prototype._createConstraint = function () {
                var rigidbody = this.gameObject.getComponent(ammo.Rigidbody);
                if (!rigidbody) {
                    console.debug("Never.");
                    return null;
                }
                var helpVector3A = ammo.PhysicsSystem.helpVector3A;
                var helpQuaternionA = ammo.PhysicsSystem.helpQuaternionA;
                var helpTransformA = ammo.PhysicsSystem.helpTransformA;
                var helpTransformB = ammo.PhysicsSystem.helpTransformB;
                var helpMatrixA = ammo.TypedConstraint._helpMatrixA;
                var helpMatrixB = ammo.TypedConstraint._helpMatrixB;
                var btConstraint;
                if (this._constraintType === 1 /* ConstrainToAnotherBody */) {
                    if (!this._connectedBody) {
                        console.error("The constraint need to config another rigid body.", this.gameObject.name, this.gameObject.uuid);
                        return null;
                    }
                    this._createFrames(helpMatrixA, helpMatrixB);
                    //
                    var helpQA = egret3d.Matrix.getQuaternion(helpMatrixA, ammo.TypedConstraint._helpQuaternionA);
                    helpVector3A.setValue(helpMatrixA.rawData[12], helpMatrixA.rawData[13], helpMatrixA.rawData[14]);
                    helpQuaternionA.setValue(helpQA.x, helpQA.y, helpQA.z, helpQA.w);
                    helpTransformA.setIdentity();
                    helpTransformA.setOrigin(helpVector3A);
                    helpTransformA.setRotation(helpQuaternionA);
                    //
                    var helpQB = egret3d.Matrix.getQuaternion(helpMatrixB, ammo.TypedConstraint._helpQuaternionA);
                    helpVector3A.setValue(helpMatrixB.rawData[12], helpMatrixB.rawData[13], helpMatrixB.rawData[14]);
                    helpQuaternionA.setValue(helpQB.x, helpQB.y, helpQB.z, helpQB.w);
                    helpTransformB.setIdentity();
                    helpTransformB.setOrigin(helpVector3A);
                    helpTransformB.setRotation(helpQuaternionA);
                    //
                    btConstraint = new Ammo.btConeTwistConstraint(rigidbody.btRigidbody, this._connectedBody.btRigidbody, helpTransformA, helpTransformB);
                }
                else {
                    this._createFrame(this._axisX, this._axisY, this._anchor, helpMatrixA);
                    //
                    var helpQA = egret3d.Matrix.getQuaternion(helpMatrixA, ammo.TypedConstraint._helpQuaternionA);
                    helpVector3A.setValue(helpMatrixA.rawData[8], helpMatrixA.rawData[9], helpMatrixA.rawData[10]);
                    helpQuaternionA.setValue(helpQA.x, helpQA.y, helpQA.z, helpQA.w);
                    helpTransformA.setIdentity();
                    helpTransformA.setOrigin(helpVector3A);
                    helpTransformA.setRotation(helpQuaternionA);
                    //
                    btConstraint = new Ammo.btConeTwistConstraint(rigidbody.btRigidbody, helpTransformA);
                }
                btConstraint.setBreakingImpulseThreshold(this._breakingImpulseThreshold);
                // btConstraint.setOverrideNumSolverIterations(this._overrideNumSolverIterations);
                this._updateLimit(btConstraint);
                return btConstraint;
            };
            Object.defineProperty(ConeTwistConstraint.prototype, "swingSpan1", {
                /**
                 *
                 */
                get: function () {
                    return this._swingSpan1;
                },
                set: function (value) {
                    if (value <= 0.0) {
                        value = 0.000001;
                    }
                    if (this._swingSpan1 === value) {
                        return;
                    }
                    this._swingSpan1 = value;
                    if (this._btTypedConstraint) {
                        this._btTypedConstraint.setLimit(5, this._swingSpan1);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistConstraint.prototype, "swingSpan2", {
                /**
                 *
                 */
                get: function () {
                    return this._swingSpan2;
                },
                set: function (value) {
                    if (value <= 0.0) {
                        value = 0.000001;
                    }
                    if (this._swingSpan2 === value) {
                        return;
                    }
                    this._swingSpan2 = value;
                    if (this._btTypedConstraint) {
                        this._btTypedConstraint.setLimit(4, this._swingSpan2);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistConstraint.prototype, "twistSpan", {
                /**
                 *
                 */
                get: function () {
                    return this._twistSpan;
                },
                set: function (value) {
                    if (value <= 0.0) {
                        value = 0.000001;
                    }
                    if (this._twistSpan === value) {
                        return;
                    }
                    this._twistSpan = value;
                    if (this._btTypedConstraint) {
                        this._btTypedConstraint.setLimit(3, this._twistSpan);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistConstraint.prototype, "softness", {
                /**
                 *
                 */
                get: function () {
                    return this._softness;
                },
                set: function (value) {
                    if (this.softness === value) {
                        return;
                    }
                    this._softness = value;
                    if (this._btTypedConstraint) {
                        // this._updateLimit(this._btTypedConstraint as Ammo.btConeTwistConstraint);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistConstraint.prototype, "biasFactor", {
                /**
                 *
                 */
                get: function () {
                    return this._biasFactor;
                },
                set: function (value) {
                    if (this._biasFactor === value) {
                        return;
                    }
                    this._biasFactor = value;
                    if (this._btTypedConstraint) {
                        // this._updateLimit(this._btTypedConstraint as Ammo.btConeTwistConstraint);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistConstraint.prototype, "relaxationFactor", {
                /**
                 *
                 */
                get: function () {
                    return this._relaxationFactor;
                },
                set: function (value) {
                    if (this._relaxationFactor === value) {
                        return;
                    }
                    this._relaxationFactor = value;
                    if (this._btTypedConstraint) {
                        // this._updateLimit(this._btTypedConstraint as Ammo.btConeTwistConstraint);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ConeTwistConstraint.prototype, "_swingSpan1", void 0);
            __decorate([
                paper.serializedField
            ], ConeTwistConstraint.prototype, "_swingSpan2", void 0);
            __decorate([
                paper.serializedField
            ], ConeTwistConstraint.prototype, "_twistSpan", void 0);
            __decorate([
                paper.serializedField
            ], ConeTwistConstraint.prototype, "_softness", void 0);
            __decorate([
                paper.serializedField
            ], ConeTwistConstraint.prototype, "_biasFactor", void 0);
            __decorate([
                paper.serializedField
            ], ConeTwistConstraint.prototype, "_relaxationFactor", void 0);
            return ConeTwistConstraint;
        }(ammo.TypedConstraint));
        ammo.ConeTwistConstraint = ConeTwistConstraint;
        __reflect(ConeTwistConstraint.prototype, "egret3d.ammo.ConeTwistConstraint");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var BallSocketConstraint = (function (_super) {
            __extends(BallSocketConstraint, _super);
            function BallSocketConstraint() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            BallSocketConstraint.prototype._createConstraint = function () {
                this._rigidbody = this.gameObject.getComponent(ammo.Rigidbody);
                if (!this._rigidbody) {
                    console.debug("Never.");
                    return null;
                }
                var helpVector3A = ammo.PhysicsSystem.helpVector3A;
                var helpVector3B = ammo.PhysicsSystem.helpVector3B;
                var btConstraint;
                helpVector3A.setValue(this._anchor.x, this._anchor.y, this._anchor.z);
                if (this._constraintType === 1 /* ConstrainToAnotherBody */) {
                    if (!this._connectedBody) {
                        console.error("The constraint need to config another rigid body.", this.gameObject.name, this.gameObject.uuid);
                        return null;
                    }
                    var pivotInOther = egret3d.helpMatrixA.copy(this._connectedBody.gameObject.transform.getWorldMatrix()).inverse().transformVector3(this._rigidbody.gameObject.transform.getWorldMatrix().transformVector3(ammo.TypedConstraint._helpVector3A.copy(this._anchor)));
                    helpVector3B.setValue(pivotInOther.x, pivotInOther.y, pivotInOther.z);
                    btConstraint = new Ammo.btPoint2PointConstraint(this._rigidbody.btRigidbody, this._connectedBody.btRigidbody, helpVector3A, helpVector3B);
                }
                else {
                    btConstraint = new Ammo.btPoint2PointConstraint(this._rigidbody.btRigidbody, helpVector3A);
                }
                btConstraint.setBreakingImpulseThreshold(this._breakingImpulseThreshold);
                // btConstraint.setOverrideNumSolverIterations(this._overrideNumSolverIterations);
                return btConstraint;
            };
            return BallSocketConstraint;
        }(ammo.TypedConstraint));
        ammo.BallSocketConstraint = BallSocketConstraint;
        __reflect(BallSocketConstraint.prototype, "egret3d.ammo.BallSocketConstraint");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var PhysicsSystem = (function (_super) {
            __extends(PhysicsSystem, _super);
            function PhysicsSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._interests = [
                    {
                        componentClass: [ammo.BoxShape, ammo.CapsuleShape, ammo.ConeShape, ammo.ConvexHullShape, ammo.CylinderShape, ammo.HeightfieldTerrainShape, ammo.SphereShape]
                    },
                    {
                        componentClass: [ammo.CollisionObject, ammo.Rigidbody]
                    },
                ];
                _this._worldType = 1 /* RigidBodyDynamics */; // TODO
                _this._collisionType = 0 /* DefaultDynamicsWorldCollisionConf */; // TODO
                _this._broadphaseType = 0 /* DynamicAABBBroadphase */; // TODO
                _this._axis3SweepBroadphaseMin = new egret3d.Vector3(-1000.0, -1000.0, -1000.0); // TODO
                _this._axis3SweepBroadphaseMax = new egret3d.Vector3(1000.0, 1000.0, 1000.0); // TODO
                _this._gravity = new egret3d.Vector3(0.0, -9.8, 0.0);
                _this._btCollisionWorld = null;
                _this._btDynamicsWorld = null;
                // TODO 完善系统生命周期
                _this._startGameObjects = [];
                _this._constraints = [];
                return _this;
            }
            Object.defineProperty(PhysicsSystem, "helpVector3A", {
                /**
                 * @internal
                 */
                get: function () {
                    if (!this._helpVector3A) {
                        this._helpVector3A = new Ammo.btVector3();
                    }
                    return this._helpVector3A;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsSystem, "helpVector3B", {
                /**
                 * @internal
                 */
                get: function () {
                    if (!this._helpVector3B) {
                        this._helpVector3B = new Ammo.btVector3();
                    }
                    return this._helpVector3B;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsSystem, "helpVector3C", {
                /**
                 * @internal
                 */
                get: function () {
                    if (!this._helpVector3C) {
                        this._helpVector3C = new Ammo.btVector3();
                    }
                    return this._helpVector3C;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsSystem, "helpVector3D", {
                /**
                 * @internal
                 */
                get: function () {
                    if (!this._helpVector3D) {
                        this._helpVector3D = new Ammo.btVector3();
                    }
                    return this._helpVector3D;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsSystem, "helpQuaternionA", {
                /**
                 * @internal
                 */
                get: function () {
                    if (!this._helpQuaternionA) {
                        this._helpQuaternionA = new Ammo.btQuaternion();
                    }
                    return this._helpQuaternionA;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsSystem, "helpTransformA", {
                /**
                 * @internal
                 */
                get: function () {
                    if (!this._helpTransformA) {
                        this._helpTransformA = new Ammo.btTransform();
                    }
                    return this._helpTransformA;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsSystem, "helpTransformB", {
                /**
                 * @internal
                 */
                get: function () {
                    if (!this._helpTransformB) {
                        this._helpTransformB = new Ammo.btTransform();
                    }
                    return this._helpTransformB;
                },
                enumerable: true,
                configurable: true
            });
            PhysicsSystem.prototype._onAddComponent = function (component) {
                if (!_super.prototype._onAddComponent.call(this, component)) {
                    return false;
                }
                if (this._startGameObjects.indexOf(component.gameObject) < 0) {
                    this._startGameObjects.push(component.gameObject);
                }
                return true;
            };
            PhysicsSystem.prototype._onRemoveComponent = function (component) {
                if (!_super.prototype._onRemoveComponent.call(this, component)) {
                    return false;
                }
                var index = this._startGameObjects.indexOf(component.gameObject);
                if (index >= 0) {
                    this._startGameObjects.splice(index, 1);
                }
                else {
                    var collisionObject = this._getComponent(component.gameObject, 1);
                    this._btCollisionWorld.removeCollisionObject(collisionObject.btCollisionObject);
                }
                return true;
            };
            PhysicsSystem.prototype._updateGravity = function () {
                var btVector3 = PhysicsSystem.helpVector3A;
                btVector3.setValue(this._gravity.x, this._gravity.y, this._gravity.z);
                this._btDynamicsWorld.setGravity(btVector3);
            };
            PhysicsSystem.prototype.initialize = function () {
                var _this = this;
                _super.prototype.initialize.call(this);
                var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
                var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
                var broadphase = new Ammo.btDbvtBroadphase();
                var solver = new Ammo.btSequentialImpulseConstraintSolver();
                this._btCollisionWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
                // 
                this._btDynamicsWorld = this._btCollisionWorld;
                if (this._btDynamicsWorld) {
                    this._updateGravity();
                }
                // TODO 完善约束初始化机制。
                var constraintClasses = [
                    ammo.FixedConstraint,
                    ammo.SliderConstraint,
                    ammo.HingeConstraint,
                    ammo.ConeTwistConstraint,
                ];
                for (var _i = 0, constraintClasses_1 = constraintClasses; _i < constraintClasses_1.length; _i++) {
                    var constraintClass = constraintClasses_1[_i];
                    paper.EventPool.addEventListener("__enabled__" /* Enabled */, constraintClass, function (component) {
                        if (_this._constraints.indexOf(component) < 0) {
                            _this._constraints.push(component);
                        }
                    });
                    paper.EventPool.addEventListener("__disabled__" /* Disabled */, constraintClass, function (component) {
                        var index = _this._constraints.indexOf(component);
                        var btTypedConstraint = component.btTypedConstraint;
                        if (index >= 0) {
                            _this._constraints.splice(index, 1);
                        }
                        else if (_this._btDynamicsWorld && btTypedConstraint) {
                            _this._btDynamicsWorld.removeConstraint(btTypedConstraint);
                        }
                    });
                }
            };
            PhysicsSystem.prototype.onUpdate = function () {
                if (this._startGameObjects.length > 0) {
                    for (var _i = 0, _a = this._startGameObjects; _i < _a.length; _i++) {
                        var gameObject = _a[_i];
                        var collisionObject = this._getComponent(gameObject, 1);
                        var collisionShape = this._getComponent(gameObject, 0);
                        var btCollisionObject = collisionObject.btCollisionObject;
                        var btCollisionShape = collisionShape.btCollisionShape;
                        btCollisionObject.setCollisionShape(btCollisionShape);
                        switch (this._worldType) {
                            case 0 /* CollisionOnly */:
                                this._btCollisionWorld.addCollisionObject(btCollisionObject, collisionObject.collisionGroups, collisionObject.collisionMask);
                                break;
                            case 1 /* RigidBodyDynamics */:
                                if (this._btDynamicsWorld) {
                                    if (collisionObject.collisionObjectType & 2 /* RigidBody */) {
                                        collisionObject._updateMass();
                                        this._btDynamicsWorld.addRigidBody(collisionObject.btRigidbody, collisionObject.collisionGroups, collisionObject.collisionMask);
                                    }
                                    else {
                                        this._btCollisionWorld.addCollisionObject(btCollisionObject, collisionObject.collisionGroups, collisionObject.collisionMask);
                                    }
                                }
                                else {
                                    throw new Error("Arguments error.");
                                }
                                break;
                            case 2 /* MultiBodyWorld */:
                                // TODO
                                break;
                            case 3 /* SoftBodyAndRigidBody */:
                                // TODO
                                break;
                        }
                    }
                    this._startGameObjects.length = 0;
                }
                if (this._constraints.length > 0) {
                    for (var _b = 0, _c = this._constraints; _b < _c.length; _b++) {
                        var constraint = _c[_b];
                        var btTypedConstraint = constraint.btTypedConstraint;
                        if (this._btDynamicsWorld && btTypedConstraint) {
                            this._btDynamicsWorld.addConstraint(btTypedConstraint, !constraint.collisionEnabled);
                        }
                    }
                    this._constraints.length = 0;
                }
                if (this._btDynamicsWorld) {
                    var helpTransformA = PhysicsSystem.helpTransformA;
                    this._btDynamicsWorld.stepSimulation(paper.Time.deltaTime, paper.Time.maxFixedSubSteps, paper.Time.fixedTimeStep);
                    for (var i = 0, l = this._components.length; i < l; i += this._interestComponentCount) {
                        var collisionObject = this._components[i + 1];
                        if (collisionObject.collisionObjectType & 2 /* RigidBody */) {
                            var motionState = collisionObject.btRigidbody.getMotionState();
                            if (motionState) {
                                var transform = collisionObject.gameObject.transform;
                                motionState.getWorldTransform(helpTransformA);
                                var t = helpTransformA.getOrigin();
                                var r = helpTransformA.getRotation();
                                transform.setPosition(t.x(), t.y(), t.z());
                                transform.setRotation(r.x(), r.y(), r.z(), r.w());
                            }
                        }
                        if (collisionObject.collisionObjectType & 4 /* GhostObject */) {
                            var ghostObject = collisionObject;
                            var btGhostObject = collisionObject.btGhostObject;
                            var behaviours = collisionObject.gameObject.getComponents(paper.Behaviour, true);
                            ghostObject._currentCollisionObjects.length = 0;
                            for (var i_1 = 0, l_1 = btGhostObject.getNumOverlappingObjects(); i_1 < l_1; ++i_1) {
                                var btCollisionObject = btGhostObject.getOverlappingObject(i_1);
                                var otherCollisionObject = Ammo.castObject(btCollisionObject.getUserPointer(), Ammo.btVector3).egretComponent;
                                ghostObject._currentCollisionObjects.push(otherCollisionObject);
                                if (ghostObject._prevCollisionObjects.indexOf(otherCollisionObject) < 0) {
                                    for (var _d = 0, behaviours_1 = behaviours; _d < behaviours_1.length; _d++) {
                                        var behaviour = behaviours_1[_d];
                                        if (behaviour._isTriggerEnabled) {
                                            behaviour.onTriggerEnter(otherCollisionObject);
                                        }
                                    }
                                }
                                else {
                                    for (var _e = 0, behaviours_2 = behaviours; _e < behaviours_2.length; _e++) {
                                        var behaviour = behaviours_2[_e];
                                        if (behaviour._isTriggerEnabled) {
                                            behaviour.onTriggerStay(otherCollisionObject);
                                        }
                                    }
                                }
                            }
                            for (var _f = 0, _g = ghostObject._prevCollisionObjects; _f < _g.length; _f++) {
                                var otherCollisionObject = _g[_f];
                                if (ghostObject._currentCollisionObjects.indexOf(otherCollisionObject) < 0) {
                                    for (var _h = 0, behaviours_3 = behaviours; _h < behaviours_3.length; _h++) {
                                        var behaviour = behaviours_3[_h];
                                        if (behaviour._isTriggerEnabled) {
                                            behaviour.onTriggerExit(otherCollisionObject);
                                        }
                                    }
                                }
                            }
                            var temp = ghostObject._prevCollisionObjects;
                            ghostObject._prevCollisionObjects = ghostObject._currentCollisionObjects;
                            ghostObject._currentCollisionObjects = temp;
                        }
                    }
                }
            };
            /**
             *
             */
            PhysicsSystem.prototype.rayTest = function (from, to, group, mask) {
                if (group === void 0) { group = 1 /* DefaultFilter */; }
                if (mask === void 0) { mask = -1 /* AllFilter */; }
                var rayResult = new Ammo.ClosestRayResultCallback();
                var rayFrom = rayResult.get_m_rayFromWorld();
                var rayTo = rayResult.get_m_rayToWorld();
                rayResult.set_m_collisionFilterGroup(group);
                rayResult.set_m_collisionFilterMask(mask);
                rayFrom.setValue(from.x, from.y, from.z);
                rayTo.setValue(to.x, to.y, to.z);
                this._btCollisionWorld.rayTest(rayFrom, rayTo, rayResult);
                if (rayResult.hasHit()) {
                    var raycastInfo = PhysicsSystem._raycastInfoPool.get() || new ammo.RaycastInfo();
                    // raycastInfo.clean(); TODO cache
                    // PhysicsSystem._raycastInfoPool.add(raycastInfo);
                    var btCollisionObject = rayResult.get_m_collisionObject();
                    var position = rayResult.get_m_hitPointWorld();
                    var normal = rayResult.get_m_hitNormalWorld();
                    raycastInfo.collisionObject = Ammo.castObject(btCollisionObject.getUserPointer(), Ammo.btVector3).egretComponent;
                    raycastInfo.transform = raycastInfo.collisionObject.gameObject.transform;
                    raycastInfo.position.set(position.x(), position.y(), position.z());
                    raycastInfo.normal.set(normal.x(), normal.y(), normal.z());
                    raycastInfo.distance = from.getDistance(raycastInfo.position); // distance 是否应该惰性计算。
                    Ammo.destroy(rayResult);
                    return raycastInfo;
                }
                Ammo.destroy(rayResult);
                return null;
            };
            Object.defineProperty(PhysicsSystem.prototype, "gravity", {
                /**
                 *
                 */
                get: function () {
                    return this._gravity;
                },
                set: function (value) {
                    this._gravity.copy(value);
                    if (this._btDynamicsWorld) {
                        this._updateGravity();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsSystem.prototype, "btCollisionWorld", {
                get: function () {
                    return this._btCollisionWorld;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsSystem.prototype, "btDynamicsWorld", {
                get: function () {
                    return this._btDynamicsWorld;
                },
                enumerable: true,
                configurable: true
            });
            PhysicsSystem._helpVector3A = null;
            PhysicsSystem._helpVector3B = null;
            PhysicsSystem._helpVector3C = null;
            PhysicsSystem._helpVector3D = null;
            PhysicsSystem._helpQuaternionA = null;
            PhysicsSystem._helpTransformA = null;
            PhysicsSystem._helpTransformB = null;
            PhysicsSystem._raycastInfoPool = new egret3d.Pool();
            return PhysicsSystem;
        }(paper.BaseSystem));
        ammo.PhysicsSystem = PhysicsSystem;
        __reflect(PhysicsSystem.prototype, "egret3d.ammo.PhysicsSystem");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var GhostObject = (function (_super) {
            __extends(GhostObject, _super);
            function GhostObject() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.collisionObjectType = 4 /* GhostObject */;
                /**
                 * @internal
                 */
                _this._prevCollisionObjects = [];
                /**
                 * @internal
                 */
                _this._currentCollisionObjects = [];
                return _this;
            }
            GhostObject.prototype._createCollisionObject = function () {
                var btCollisionObject = new Ammo.btGhostObject();
                btCollisionObject.setWorldTransform(this._getBTTransform());
                btCollisionObject.setCollisionFlags(this._collisionFlags);
                btCollisionObject.setUserPointer(this._btPointer);
                this._btPointer.egretComponent = this;
                return btCollisionObject;
            };
            GhostObject.prototype.initialize = function () {
                _super.prototype.initialize.call(this);
                this._collisionFlags = 4 /* NoContactResponse */;
            };
            Object.defineProperty(GhostObject.prototype, "collisionFlags", {
                set: function (_value) {
                    console.warn("Cannot set the collision flags of ghost gbject.");
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(GhostObject.prototype, "btGhostObject", {
                get: function () {
                    return this._btCollisionObject;
                },
                enumerable: true,
                configurable: true
            });
            return GhostObject;
        }(ammo.CollisionObject));
        ammo.GhostObject = GhostObject;
        __reflect(GhostObject.prototype, "egret3d.ammo.GhostObject");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        /**
         *
         */
        var Rigidbody = (function (_super) {
            __extends(Rigidbody, _super);
            function Rigidbody() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.collisionObjectType = 1 /* CollisionObject */ | 2 /* RigidBody */;
                _this._mass = 1.0;
                _this._friction = 0.5;
                _this._rollingFriction = 0.0;
                _this._linearDamping = 0.1;
                _this._angularDamping = 0.1;
                _this._additionalDamping = false;
                _this._additionalLinearDampingFactor = 0.005;
                _this._additionalLinearDampingThresholdSqr = 0.01;
                _this._additionalAngularDampingFactor = 0.01;
                _this._additionalAngularDampingThresholdSqr = 0.01;
                _this._restitution = 0.0;
                _this._linearSleepingThreshold = 0.8;
                _this._angularSleepingThreshold = 1.0;
                _this._linearFactor = egret3d.Vector3.ONE.clone();
                _this._angularFactor = egret3d.Vector3.ONE.clone();
                _this._localInertia = egret3d.Vector3.ZERO.clone();
                return _this;
            }
            Rigidbody.prototype._createCollisionObject = function () {
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo();
                rigidBodyInfo.set_m_friction(this._friction);
                rigidBodyInfo.set_m_rollingFriction(this._rollingFriction);
                rigidBodyInfo.set_m_linearDamping(this._linearDamping);
                rigidBodyInfo.set_m_angularDamping(this._angularDamping);
                rigidBodyInfo.set_m_restitution(this._restitution);
                rigidBodyInfo.set_m_linearSleepingThreshold(this._linearSleepingThreshold);
                rigidBodyInfo.set_m_angularSleepingThreshold(this._angularSleepingThreshold);
                rigidBodyInfo.set_m_additionalDamping(this._additionalDamping);
                rigidBodyInfo.set_m_additionalDampingFactor(this._additionalLinearDampingFactor);
                rigidBodyInfo.set_m_additionalLinearDampingThresholdSqr(this._additionalLinearDampingThresholdSqr);
                rigidBodyInfo.set_m_additionalAngularDampingFactor(this._additionalAngularDampingFactor);
                rigidBodyInfo.set_m_additionalAngularDampingThresholdSqr(this._additionalAngularDampingThresholdSqr);
                //
                var btCollisionObject = new Ammo.btRigidBody(rigidBodyInfo);
                var motionState = new Ammo.btDefaultMotionState(this._getBTTransform()); // TODO 可扩展 的 state。
                btCollisionObject.setCollisionFlags(this._collisionFlags);
                btCollisionObject.setMotionState(motionState);
                btCollisionObject.setUserPointer(this._btPointer);
                this._btPointer.egretComponent = this;
                Ammo.destroy(rigidBodyInfo); //
                return btCollisionObject;
            };
            /**
             * @internal
             */
            Rigidbody.prototype._updateMass = function () {
                var helpVector3A = ammo.PhysicsSystem.helpVector3A;
                if (this._mass > 0.0 && this.isDynamic()) {
                    var collisionShape = this.gameObject.getComponent(ammo.CollisionShape, true);
                    helpVector3A.setValue(this._localInertia.x, this._localInertia.y, this._localInertia.z);
                    collisionShape.btCollisionShape.calculateLocalInertia(this._mass, helpVector3A);
                    this._localInertia.set(helpVector3A.x(), helpVector3A.y(), helpVector3A.z());
                    this.btRigidbody.setMassProps(this._mass, helpVector3A);
                    this.btRigidbody.setActivationState(4 /* DisableDeactivation */);
                }
                else {
                    this._localInertia.set(0.0, 0.0, 0.0);
                    helpVector3A.setValue(0.0, 0.0, 0.0);
                    this.btRigidbody.setMassProps(0.0, helpVector3A);
                    this.btRigidbody.setActivationState(0 /* Undefined */);
                }
            };
            Object.defineProperty(Rigidbody.prototype, "collisionFlags", {
                /**
                 *
                 */
                get: function () {
                    return this._collisionFlags;
                },
                set: function (value) {
                    if (this._collisionFlags === value) {
                        return;
                    }
                    this._collisionFlags = value;
                    if (this._btCollisionObject) {
                        this._btCollisionObject.setCollisionFlags(this._collisionFlags);
                        this._updateMass();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "mass", {
                /**
                 *
                 */
                get: function () {
                    return this._mass;
                },
                set: function (value) {
                    if (this._mass === value) {
                        return;
                    }
                    this._mass = value;
                    if (this._btCollisionObject) {
                        this._updateMass();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "friction", {
                /**
                 *
                 */
                get: function () {
                    return this._friction;
                },
                set: function (value) {
                    if (this._friction === value) {
                        return;
                    }
                    this._friction = value;
                    if (this._btCollisionObject) {
                        this.btRigidbody.setFriction(this._friction);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "rollingFriction", {
                /**
                 *
                 */
                get: function () {
                    return this._rollingFriction;
                },
                set: function (value) {
                    if (this._rollingFriction === value) {
                        return;
                    }
                    this._rollingFriction = value;
                    if (this._btCollisionObject) {
                        this.btRigidbody.setRollingFriction(this._rollingFriction);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "linearDamping", {
                /**
                 *
                 */
                get: function () {
                    return this._linearDamping;
                },
                set: function (value) {
                    if (this._linearDamping === value) {
                        return;
                    }
                    this._linearDamping = value;
                    if (this._btCollisionObject) {
                        this.btRigidbody.setDamping(this._linearDamping, this._angularDamping);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "angularDamping", {
                /**
                 *
                 */
                get: function () {
                    return this._angularDamping;
                },
                set: function (value) {
                    if (this._angularDamping === value) {
                        return;
                    }
                    this._angularDamping = value;
                    if (this._btCollisionObject) {
                        this.btRigidbody.setDamping(this._linearDamping, this._angularDamping);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "additionalDamping", {
                /**
                 *
                 */
                get: function () {
                    return this._additionalDamping;
                },
                set: function (value) {
                    if (this._additionalDamping === value) {
                        return;
                    }
                    if (this._btCollisionObject) {
                        console.warn("Cannot change the additionalDamping after the collision object has been created.");
                    }
                    else {
                        this._additionalDamping = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "additionalLinearDampingFactor", {
                /**
                 *
                 */
                get: function () {
                    return this._additionalLinearDampingFactor;
                },
                set: function (value) {
                    if (this._additionalLinearDampingFactor === value) {
                        return;
                    }
                    if (this._btCollisionObject) {
                        console.warn("Cannot change the additionalLinearDampingFactor after the collision object has been created.");
                    }
                    else {
                        this._additionalLinearDampingFactor = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "additionalLinearDampingThresholdSqr", {
                /**
                 *
                 */
                get: function () {
                    return this._additionalLinearDampingThresholdSqr;
                },
                set: function (value) {
                    if (this._additionalLinearDampingThresholdSqr === value) {
                        return;
                    }
                    if (this._btCollisionObject) {
                        console.warn("Cannot change the additionalLinearDampingThresholdSqr after the collision object has been created.");
                    }
                    else {
                        this._additionalLinearDampingThresholdSqr = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "additionalAngularDampingFactor", {
                /**
                 *
                 */
                get: function () {
                    return this._additionalAngularDampingFactor;
                },
                set: function (value) {
                    if (this._additionalAngularDampingFactor === value) {
                        return;
                    }
                    if (this._btCollisionObject) {
                        console.warn("Cannot change the additionalAngularDampingFactor after the collision object has been created.");
                    }
                    else {
                        this._additionalAngularDampingFactor = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "additionalAngularDampingThresholdSqr", {
                /**
                 *
                 */
                get: function () {
                    return this._additionalAngularDampingThresholdSqr;
                },
                set: function (value) {
                    if (this._additionalAngularDampingThresholdSqr === value) {
                        return;
                    }
                    if (this._btCollisionObject) {
                        console.warn("Cannot change the additionalAngularDampingThresholdSqr after the collision object has been created.");
                    }
                    else {
                        this._additionalAngularDampingThresholdSqr = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "restitution", {
                /**
                 *
                 */
                get: function () {
                    return this._restitution;
                },
                set: function (value) {
                    if (this._restitution === value) {
                        return;
                    }
                    this._restitution = value;
                    if (this._btCollisionObject) {
                        this.btRigidbody.setRestitution(this._restitution);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "linearSleepingThreshold", {
                /**
                 *
                 */
                get: function () {
                    return this._linearSleepingThreshold;
                },
                set: function (value) {
                    if (this._linearSleepingThreshold === value) {
                        return;
                    }
                    this._linearSleepingThreshold = value;
                    if (this._btCollisionObject) {
                        this.btRigidbody.setSleepingThresholds(this._linearSleepingThreshold, this._angularSleepingThreshold);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "angularSleepingThreshold", {
                /**
                 *
                 */
                get: function () {
                    return this._angularSleepingThreshold;
                },
                set: function (value) {
                    if (this._angularSleepingThreshold === value) {
                        return;
                    }
                    this._angularSleepingThreshold = value;
                    if (this._btCollisionObject) {
                        this.btRigidbody.setSleepingThresholds(this._linearSleepingThreshold, this._angularSleepingThreshold);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "linearFactor", {
                /**
                 *
                 */
                get: function () {
                    return this._linearFactor;
                },
                set: function (value) {
                    this._linearFactor.copy(value);
                    if (this._btCollisionObject) {
                        var helpVector3A_1 = ammo.PhysicsSystem.helpVector3A;
                        helpVector3A_1.setValue(this._linearFactor.x, this._linearFactor.y, this._linearFactor.z);
                        this.btRigidbody.setLinearFactor(helpVector3A_1);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "angularFactor", {
                /**
                 *
                 */
                get: function () {
                    return this._angularFactor;
                },
                set: function (value) {
                    this._angularFactor.copy(value);
                    if (this._btCollisionObject) {
                        var helpVector3A_2 = ammo.PhysicsSystem.helpVector3A;
                        helpVector3A_2.setValue(this._angularFactor.x, this._angularFactor.y, this._angularFactor.z);
                        this.btRigidbody.setAngularFactor(helpVector3A_2);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "localInertia", {
                /**
                 *
                 */
                get: function () {
                    return this._localInertia;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "btRigidbody", {
                /**
                 *
                 */
                get: function () {
                    return this._btCollisionObject;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_mass", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_friction", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_rollingFriction", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_linearDamping", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_angularDamping", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_additionalDamping", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_additionalLinearDampingFactor", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_additionalLinearDampingThresholdSqr", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_additionalAngularDampingFactor", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_additionalAngularDampingThresholdSqr", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_restitution", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_linearSleepingThreshold", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_angularSleepingThreshold", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_linearFactor", void 0);
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_angularFactor", void 0);
            return Rigidbody;
        }(ammo.CollisionObject));
        ammo.Rigidbody = Rigidbody;
        __reflect(Rigidbody.prototype, "egret3d.ammo.Rigidbody");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        var _helpVector3A = new egret3d.Vector3();
        var _helpMatrix = new egret3d.Matrix();
        var _attributes = [
            "POSITION" /* POSITION */,
            "COLOR_0" /* COLOR_0 */,
        ];
        /**
         *
         */
        var RayTester = (function (_super) {
            __extends(RayTester, _super);
            function RayTester() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.distance = 10.0;
                _this.collisionGroups = 8 /* DebrisFilter */;
                _this.collisionMask = -1 /* AllFilter */;
                _this._hitted = false;
                return _this;
            }
            RayTester.prototype.onStart = function () {
                this._meshFilter = this.gameObject.getComponent(egret3d.MeshFilter) || this.gameObject.addComponent(egret3d.MeshFilter);
                this._meshRender = this.gameObject.getComponent(egret3d.MeshRenderer) || this.gameObject.addComponent(egret3d.MeshRenderer);
                var mesh = new egret3d.Mesh(3, null, _attributes);
                var vertices = mesh.getVertices();
                var colors = mesh.getColors();
                vertices[0] = 0.0;
                vertices[1] = 0.0;
                vertices[2] = 0.0;
                vertices[3] = this.distance;
                vertices[4] = 0.0;
                vertices[5] = 0.0;
                vertices[6] = this.distance;
                vertices[7] = 0.0;
                vertices[8] = 0.0;
                for (var i = 0, l = colors.length; i < l; i += 4) {
                    colors[i + 0] = 0.0;
                    colors[i + 1] = 1.0;
                    colors[i + 2] = 0.0;
                    colors[i + 3] = 1.0;
                }
                mesh.glTFMesh.primitives[0].mode = 3 /* LineStrip */;
                mesh.uploadSubVertexBuffer(_attributes);
                RayTester._material.setShader(egret3d.DefaultShaders.LINE);
                this._meshRender.materials = [RayTester._material];
                this._meshFilter.mesh = mesh;
            };
            RayTester.prototype.onUpdate = function () {
                var physicsSystem = paper.Application.systemManager.getSystem(ammo.PhysicsSystem);
                if (!physicsSystem || !physicsSystem.enabled) {
                    return;
                }
                var transform = this.gameObject.transform;
                var matrix = transform.getWorldMatrix();
                var from = transform.getPosition();
                var to = matrix.transformVector3(_helpVector3A.set(this.distance, 0.0, 0.0));
                var raycastInfo = physicsSystem.rayTest(from, to, this.collisionGroups, this.collisionMask);
                if (raycastInfo) {
                    this._hitted = true;
                    var mesh = this._meshFilter.mesh;
                    if (mesh) {
                        var v = _helpMatrix.copy(matrix).inverse().transformNormal(raycastInfo.normal).scale(1.0);
                        var vertices = mesh.getVertices();
                        vertices[3] = raycastInfo.distance;
                        vertices[4] = 0.0;
                        vertices[5] = 0.0;
                        vertices[6] = v.x + raycastInfo.distance;
                        vertices[7] = v.y;
                        vertices[8] = v.z;
                        mesh.uploadSubVertexBuffer("POSITION" /* POSITION */);
                    }
                }
                else {
                    if (this._hitted) {
                        var mesh = this._meshFilter.mesh;
                        if (mesh) {
                            var vertices = mesh.getVertices();
                            vertices[3] = this.distance;
                            vertices[4] = 0.0;
                            vertices[5] = 0.0;
                            vertices[6] = this.distance;
                            vertices[7] = 0.0;
                            vertices[8] = 0.0;
                            mesh.uploadSubVertexBuffer("POSITION" /* POSITION */);
                        }
                    }
                    this._hitted = false;
                }
            };
            RayTester._material = new egret3d.Material("line");
            __decorate([
                paper.serializedField
            ], RayTester.prototype, "distance", void 0);
            __decorate([
                paper.serializedField
            ], RayTester.prototype, "collisionGroups", void 0);
            __decorate([
                paper.serializedField
            ], RayTester.prototype, "collisionMask", void 0);
            return RayTester;
        }(paper.Behaviour));
        ammo.RayTester = RayTester;
        __reflect(RayTester.prototype, "egret3d.ammo.RayTester");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ammo;
    (function (ammo) {
        var RaycastInfo = (function () {
            function RaycastInfo() {
                this.position = new egret3d.Vector3();
                this.normal = new egret3d.Vector3();
            }
            /**
             * @internal
             */
            RaycastInfo.prototype.clean = function () {
                this.distance = 0.0;
                this.position.x = 0.0;
                this.position.y = 0.0;
                this.position.z = 0.0;
                this.normal.x = 0.0;
                this.normal.y = 0.0;
                this.normal.z = 0.0;
                this.transform = null;
                this.collisionObject = null;
            };
            return RaycastInfo;
        }());
        ammo.RaycastInfo = RaycastInfo;
        __reflect(RaycastInfo.prototype, "egret3d.ammo.RaycastInfo");
    })(ammo = egret3d.ammo || (egret3d.ammo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var colorHelper1 = new egret3d.Color();
        var colorHelper2 = new egret3d.Color();
        var Keyframe = (function () {
            function Keyframe() {
            }
            Keyframe.prototype.serialize = function () {
                return [this.time, this.value];
            };
            Keyframe.prototype.deserialize = function (element) {
                this.time = element[0];
                this.value = element[1];
            };
            Keyframe.prototype.clone = function (source) {
                this.time = source.time;
                this.value = source.value;
            };
            return Keyframe;
        }());
        particle.Keyframe = Keyframe;
        __reflect(Keyframe.prototype, "egret3d.particle.Keyframe", ["paper.ISerializable"]);
        var AnimationCurve = (function () {
            function AnimationCurve() {
                /**
                 * 功能与效率平衡长度取4
                 */
                this._keys = new Array();
                this._floatValues = new Float32Array(8);
            }
            AnimationCurve.prototype.serialize = function () {
                return this._keys.map(function (keyFrame) { return keyFrame.serialize(); });
            };
            AnimationCurve.prototype.deserialize = function (element) {
                this._keys.length = 0;
                for (var i = 0, l = element.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.deserialize(element[i]);
                    this._keys.push(keyframe);
                }
            };
            AnimationCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this._keys.length; i < l; i++) {
                    var curKeyFrame = this._keys[i];
                    if (curKeyFrame.time < t) {
                        continue;
                    }
                    //
                    var lastIndex = i === 0 ? 0 : i - 1;
                    var lastKeyFrame = this._keys[lastIndex];
                    var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                    return egret3d.numberLerp(lastKeyFrame.value, curKeyFrame.value, tt);
                }
                throw "AnimationCurve: invalid t or keys.length is 0";
            };
            Object.defineProperty(AnimationCurve.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    var offset = 0;
                    for (var _i = 0, _a = this._keys; _i < _a.length; _i++) {
                        var keyFrame = _a[_i];
                        res[offset++] = keyFrame.time;
                        res[offset++] = keyFrame.value;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            AnimationCurve.prototype.clone = function (source) {
                this._keys.length = 0;
                var sourceKeys = source._keys;
                for (var i = 0, l = sourceKeys.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.time = sourceKeys[i].time;
                    keyframe.value = sourceKeys[i].value;
                    this._keys.push(keyframe);
                }
            };
            return AnimationCurve;
        }());
        particle.AnimationCurve = AnimationCurve;
        __reflect(AnimationCurve.prototype, "egret3d.particle.AnimationCurve", ["paper.ISerializable"]);
        var GradientColorKey = (function (_super) {
            __extends(GradientColorKey, _super);
            function GradientColorKey() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.color = new egret3d.Color();
                return _this;
            }
            GradientColorKey.prototype.deserialize = function (element) {
                this.color.deserialize(element.color);
                this.time = element.time;
            };
            __decorate([
                paper.serializedField
            ], GradientColorKey.prototype, "color", void 0);
            __decorate([
                paper.serializedField
            ], GradientColorKey.prototype, "time", void 0);
            return GradientColorKey;
        }(paper.SerializableObject));
        particle.GradientColorKey = GradientColorKey;
        __reflect(GradientColorKey.prototype, "egret3d.particle.GradientColorKey");
        var GradientAlphaKey = (function (_super) {
            __extends(GradientAlphaKey, _super);
            function GradientAlphaKey() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            GradientAlphaKey.prototype.deserialize = function (element) {
                this.alpha = element.alpha;
                this.time = element.time;
            };
            __decorate([
                paper.serializedField
            ], GradientAlphaKey.prototype, "alpha", void 0);
            __decorate([
                paper.serializedField
            ], GradientAlphaKey.prototype, "time", void 0);
            return GradientAlphaKey;
        }(paper.SerializableObject));
        particle.GradientAlphaKey = GradientAlphaKey;
        __reflect(GradientAlphaKey.prototype, "egret3d.particle.GradientAlphaKey");
        var Gradient = (function (_super) {
            __extends(Gradient, _super);
            function Gradient() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 0 /* Blend */;
                _this.alphaKeys = new Array();
                _this.colorKeys = new Array();
                _this._alphaValue = new Float32Array(8);
                _this._colorValue = new Float32Array(16);
                return _this;
            }
            Gradient.prototype.deserialize = function (element) {
                this.colorKeys.length = 0;
                for (var i = 0, l = element.colorKeys.length; i < l; i++) {
                    var color = new GradientColorKey();
                    color.deserialize(element.colorKeys[i]);
                    this.colorKeys.push(color);
                }
                //
                this.alphaKeys.length = 0;
                for (var i = 0, l = element.alphaKeys.length; i < l; i++) {
                    var alpha = new GradientAlphaKey();
                    alpha.deserialize(element.alphaKeys[i]);
                    this.alphaKeys.push(alpha);
                }
            };
            Gradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this.alphaKeys.length; i < l; i++) {
                    var curKeyFrame = this.alphaKeys[i];
                    if (curKeyFrame.time > t) {
                        var lastIndex = i == 0 ? 0 : i - 1;
                        var lastKeyFrame = this.alphaKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                        out.a = egret3d.numberLerp(lastKeyFrame.alpha, curKeyFrame.alpha, tt);
                        break;
                    }
                }
                for (var i = 0, l = this.colorKeys.length; i < l; i++) {
                    var colorKey = this.colorKeys[i];
                    if (colorKey.time > t) {
                        var lastIndex = i == 0 ? 0 : i - 1;
                        var lastKeyFrame = this.colorKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (colorKey.time - lastKeyFrame.time);
                        out.r = egret3d.numberLerp(lastKeyFrame.color.r, colorKey.color.r, tt);
                        out.g = egret3d.numberLerp(lastKeyFrame.color.g, colorKey.color.g, tt);
                        out.b = egret3d.numberLerp(lastKeyFrame.color.b, colorKey.color.b, tt);
                        break;
                    }
                }
                return out;
            };
            Object.defineProperty(Gradient.prototype, "alphaValues", {
                get: function () {
                    var res = this._alphaValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.alphaKeys; _i < _a.length; _i++) {
                        var alpha = _a[_i];
                        res[offset++] = alpha.time;
                        res[offset++] = alpha.alpha;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Gradient.prototype, "colorValues", {
                get: function () {
                    var res = this._colorValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.colorKeys; _i < _a.length; _i++) {
                        var color = _a[_i];
                        res[offset++] = color.time;
                        res[offset++] = color.color.r;
                        res[offset++] = color.color.g;
                        res[offset++] = color.color.b;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "alphaKeys", void 0);
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "colorKeys", void 0);
            return Gradient;
        }(paper.SerializableObject));
        particle.Gradient = Gradient;
        __reflect(Gradient.prototype, "egret3d.particle.Gradient");
        var MinMaxCurve = (function (_super) {
            __extends(MinMaxCurve, _super);
            function MinMaxCurve() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 0 /* Constant */;
                _this.curve = new AnimationCurve();
                _this.curveMin = new AnimationCurve();
                _this.curveMax = new AnimationCurve();
                return _this;
            }
            MinMaxCurve.prototype.deserialize = function (element) {
                this.mode = element.mode;
                this.constant = element.constant || 0;
                this.constantMin = element.constantMin || 0;
                this.constantMax = element.constantMax || 0;
                element.curve && this.curve.deserialize(element.curve);
                element.curveMin && this.curveMin.deserialize(element.curveMin);
                element.curveMax && this.curveMax.deserialize(element.curveMax);
            };
            MinMaxCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Constant */) {
                    return this.constant;
                }
                else if (this.mode === 3 /* TwoConstants */) {
                    return (Math.random() * (this.constantMax - this.constantMin) + this.constantMin);
                }
                else if (this.mode === 1 /* Curve */) {
                    return this.curve.evaluate(t);
                }
                else {
                    var min = this.curveMin.evaluate(t);
                    var max = this.curveMax.evaluate(t);
                    return (Math.random() * (min - max) + min);
                }
            };
            MinMaxCurve.prototype.clone = function (source) {
                this.mode = source.mode;
                this.constant = source.constant;
                this.constantMin = source.constantMin;
                this.constantMax = source.constantMax;
                this.curve.clone(source.curve);
                this.curveMin.clone(source.curveMin);
                this.curveMax.clone(source.curveMax);
            };
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constant", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constantMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constantMax", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curve", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curveMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curveMax", void 0);
            return MinMaxCurve;
        }(paper.SerializableObject));
        particle.MinMaxCurve = MinMaxCurve;
        __reflect(MinMaxCurve.prototype, "egret3d.particle.MinMaxCurve");
        var MinMaxGradient = (function (_super) {
            __extends(MinMaxGradient, _super);
            function MinMaxGradient() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 1 /* Gradient */;
                _this.color = new egret3d.Color();
                _this.colorMin = new egret3d.Color();
                _this.colorMax = new egret3d.Color();
                _this.gradient = new Gradient();
                _this.gradientMin = new Gradient();
                _this.gradientMax = new Gradient();
                return _this;
            }
            MinMaxGradient.prototype.deserialize = function (element) {
                // super.deserialize(element);
                this.mode = element.mode;
                if (element.color) {
                    this.color.deserialize(element.color);
                }
                if (element.colorMin) {
                    this.colorMin.deserialize(element.colorMin);
                }
                if (element.colorMax) {
                    this.colorMax.deserialize(element.colorMax);
                }
                if (element.gradient) {
                    this.gradient.deserialize(element.gradient);
                }
                if (element.gradientMin) {
                    this.gradientMin.deserialize(element.gradientMin);
                }
                if (element.gradientMax) {
                    this.gradientMax.deserialize(element.gradientMax);
                }
            };
            MinMaxGradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Color */) {
                    out.r = this.color.r;
                    out.g = this.color.g;
                    out.b = this.color.b;
                    out.a = this.color.a;
                }
                else if (this.mode === 2 /* TwoColors */) {
                    out.r = Math.random() * (this.colorMax.r - this.colorMin.r) + this.colorMin.r;
                    out.g = Math.random() * (this.colorMax.g - this.colorMin.g) + this.colorMin.g;
                    out.b = Math.random() * (this.colorMax.b - this.colorMin.b) + this.colorMin.b;
                    out.a = Math.random() * (this.colorMax.a - this.colorMin.a) + this.colorMin.a;
                }
                else if (this.mode === 1 /* Gradient */) {
                    return this.gradient.evaluate(t, out);
                }
                else if (this.mode === 3 /* TwoGradients */) {
                    this.gradientMin.evaluate(t, colorHelper1);
                    this.gradientMax.evaluate(t, colorHelper2);
                    out.r = (Math.random() * (colorHelper1.r - colorHelper2.r) + colorHelper1.r);
                    out.g = (Math.random() * (colorHelper1.g - colorHelper2.g) + colorHelper1.g);
                    out.b = (Math.random() * (colorHelper1.b - colorHelper2.b) + colorHelper1.b);
                    out.a = (Math.random() * (colorHelper1.a - colorHelper2.a) + colorHelper1.a);
                }
                else {
                    out.r = Math.random();
                    out.g = Math.random();
                    out.b = Math.random();
                    out.a = Math.random();
                }
                return out;
            };
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "color", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "colorMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "colorMax", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradient", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradientMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradientMax", void 0);
            return MinMaxGradient;
        }(paper.SerializableObject));
        particle.MinMaxGradient = MinMaxGradient;
        __reflect(MinMaxGradient.prototype, "egret3d.particle.MinMaxGradient");
        var Burst = (function () {
            function Burst() {
            }
            Burst.prototype.serialize = function () {
                return [this.time, this.minCount, this.maxCount, this.cycleCount, this.repeatInterval];
            };
            Burst.prototype.deserialize = function (element) {
                this.time = element[0];
                this.minCount = element[1];
                this.maxCount = element[2];
                this.cycleCount = element[3];
                this.repeatInterval = element[4];
            };
            return Burst;
        }());
        particle.Burst = Burst;
        __reflect(Burst.prototype, "egret3d.particle.Burst", ["paper.ISerializable"]);
        var ParticleSystemModule = (function (_super) {
            __extends(ParticleSystemModule, _super);
            function ParticleSystemModule(comp) {
                var _this = _super.call(this) || this;
                _this.enable = false;
                _this._comp = comp;
                return _this;
            }
            /**
             * @internal
             */
            ParticleSystemModule.prototype.initialize = function () { };
            ParticleSystemModule.prototype.deserialize = function (element) {
                this.enable = true;
            };
            __decorate([
                paper.serializedField
            ], ParticleSystemModule.prototype, "enable", void 0);
            return ParticleSystemModule;
        }(paper.SerializableObject));
        particle.ParticleSystemModule = ParticleSystemModule;
        __reflect(ParticleSystemModule.prototype, "egret3d.particle.ParticleSystemModule");
        var MainModule = (function (_super) {
            __extends(MainModule, _super);
            function MainModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.duration = 0.0;
                _this.loop = false;
                //
                _this.startDelay = new MinMaxCurve();
                //
                _this.startLifetime = new MinMaxCurve();
                //
                _this.startSpeed = new MinMaxCurve();
                //
                _this.startSizeX = new MinMaxCurve();
                _this.startSizeY = new MinMaxCurve();
                _this.startSizeZ = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._startRotation3D = false;
                _this.startRotationX = new MinMaxCurve();
                _this.startRotationY = new MinMaxCurve();
                _this.startRotationZ = new MinMaxCurve();
                //
                _this.startColor = new MinMaxGradient();
                //
                _this.gravityModifier = new MinMaxCurve(); //TODO
                /**
                 * @internal
                 */
                _this._simulationSpace = 0 /* Local */;
                /**
                 * @internal
                 */
                _this._scaleMode = 0 /* Hierarchy */;
                //
                _this.playOnAwake = false;
                /**
                 * @internal
                 */
                _this._maxParticles = 0;
                return _this;
            }
            MainModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.duration = element.duration;
                this.loop = element.loop || element.looping; // TODO 兼容代码 looping。
                this.startDelay.deserialize(element.startDelay);
                this.startLifetime.deserialize(element.startLifetime);
                this.startSpeed.deserialize(element.startSpeed);
                this.startSizeX.deserialize(element.startSizeX);
                this.startSizeY.deserialize(element.startSizeY);
                this.startSizeZ.deserialize(element.startSizeZ);
                this._startRotation3D = (element._startRotation3D || element.startRotation3D) || false;
                this.startRotationX.deserialize(element.startRotationX);
                this.startRotationY.deserialize(element.startRotationY);
                this.startRotationZ.deserialize(element.startRotationZ);
                this.startColor.deserialize(element.startColor);
                this.gravityModifier.deserialize(element.gravityModifier);
                this._simulationSpace = (element._simulationSpace || element.simulationSpace) || 0;
                this._scaleMode = (element._scaleMode || element.scaleMode) || 0 /* Hierarchy */;
                this.playOnAwake = element.playOnAwake;
                this._maxParticles = (element._maxParticles || element.maxParticles) || 0;
            };
            Object.defineProperty(MainModule.prototype, "startRotation3D", {
                get: function () {
                    return this._startRotation3D;
                },
                set: function (value) {
                    if (this._startRotation3D !== value) {
                        this._startRotation3D = value;
                        paper.EventPool.dispatchEvent("rotation3DChanged" /* StartRotation3DChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "simulationSpace", {
                get: function () {
                    return this._simulationSpace;
                },
                set: function (value) {
                    if (this._simulationSpace !== value) {
                        this._simulationSpace = value;
                        paper.EventPool.dispatchEvent("simulationSpace" /* SimulationSpaceChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "scaleMode", {
                get: function () {
                    return this._scaleMode;
                },
                set: function (value) {
                    if (this._scaleMode !== value) {
                        this._scaleMode = value;
                        paper.EventPool.dispatchEvent("scaleMode" /* ScaleModeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "maxParticles", {
                get: function () {
                    return this._maxParticles;
                },
                set: function (value) {
                    if (this._maxParticles !== value) {
                        this._maxParticles = value;
                        paper.EventPool.dispatchEvent("maxParticles" /* MaxParticlesChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "duration", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "loop", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startDelay", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startLifetime", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSpeed", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_startRotation3D", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startColor", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "gravityModifier", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_simulationSpace", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_scaleMode", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "playOnAwake", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_maxParticles", void 0);
            return MainModule;
        }(ParticleSystemModule));
        particle.MainModule = MainModule;
        __reflect(MainModule.prototype, "egret3d.particle.MainModule");
        var EmissionModule = (function (_super) {
            __extends(EmissionModule, _super);
            function EmissionModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.rateOverTime = new MinMaxCurve();
                _this.bursts = new Array();
                return _this;
            }
            EmissionModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.rateOverTime.deserialize(element.rateOverTime);
                if (element.bursts) {
                    this.bursts.length = 0;
                    for (var i = 0, l = element.bursts.length; i < l; i++) {
                        var burst = new Burst();
                        burst.deserialize(element.bursts[i]);
                        this.bursts.push(burst);
                    }
                }
            };
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "rateOverTime", void 0);
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "bursts", void 0);
            return EmissionModule;
        }(ParticleSystemModule));
        particle.EmissionModule = EmissionModule;
        __reflect(EmissionModule.prototype, "egret3d.particle.EmissionModule");
        var ShapeModule = (function (_super) {
            __extends(ShapeModule, _super);
            function ShapeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.shapeType = 0 /* Sphere */;
                _this.radius = 0.0;
                _this.angle = 0.0;
                _this.length = 0.0;
                _this.arcSpeed = new MinMaxCurve();
                _this.arcMode = 0 /* Random */;
                _this.radiusMode = 0 /* Random */;
                _this.box = new egret3d.Vector3();
                _this.randomDirection = false;
                _this.spherizeDirection = false;
                return _this;
            }
            ShapeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.shapeType = element.shapeType;
                this.radius = element.radius;
                this.angle = element.angle;
                this.length = element.length;
                this.arcSpeed.deserialize(element.arcSpeed);
                this.arcMode = element.arcMode;
                this.radiusSpread = element.radiusSpread;
                this.radiusMode = element.radiusMode;
                this.box.deserialize(element.box);
                this.randomDirection = element.randomDirection;
                this.spherizeDirection = element.spherizeDirection;
            };
            ShapeModule.prototype.invalidUpdate = function () {
                paper.EventPool.dispatchEvent("shapeChanged" /* ShapeChanged */, this._comp);
            };
            ShapeModule.prototype.generatePositionAndDirection = function (position, direction) {
                particle.generatePositionAndDirection(position, direction, this);
            };
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "shapeType", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radius", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "angle", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "length", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcSpeed", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusSpread", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "box", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "randomDirection", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "spherizeDirection", void 0);
            return ShapeModule;
        }(ParticleSystemModule));
        particle.ShapeModule = ShapeModule;
        __reflect(ShapeModule.prototype, "egret3d.particle.ShapeModule");
        var VelocityOverLifetimeModule = (function (_super) {
            __extends(VelocityOverLifetimeModule, _super);
            function VelocityOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._mode = 0 /* Constant */;
                /**
                 * @internal
                 */
                _this._space = 0 /* Local */;
                /**
                 * @internal
                 */
                _this._x = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._y = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._z = new MinMaxCurve();
                return _this;
            }
            VelocityOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._mode = (element._mode || element.mode) || 0 /* Constant */;
                this._space = (element._space || element.space) || 0 /* Local */;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
            };
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "mode", {
                get: function () {
                    return this._mode;
                },
                set: function (value) {
                    if (this._mode !== value) {
                        this._mode = value;
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "space", {
                get: function () {
                    return this._space;
                },
                set: function (value) {
                    if (this._space !== value) {
                        this._space = value;
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._x !== value) {
                        this._x.clone(value);
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._y !== value) {
                        this._y.clone(value);
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "z", {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    if (this._z !== value) {
                        this._z.clone(value);
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_mode", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_space", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_z", void 0);
            return VelocityOverLifetimeModule;
        }(ParticleSystemModule));
        particle.VelocityOverLifetimeModule = VelocityOverLifetimeModule;
        __reflect(VelocityOverLifetimeModule.prototype, "egret3d.particle.VelocityOverLifetimeModule");
        var ColorOverLifetimeModule = (function (_super) {
            __extends(ColorOverLifetimeModule, _super);
            function ColorOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._color = new MinMaxGradient();
                return _this;
            }
            ColorOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._color.deserialize(element._color || element.color);
            };
            Object.defineProperty(ColorOverLifetimeModule.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    if (this._color !== value) {
                        this._color = value;
                        paper.EventPool.dispatchEvent("colorChanged" /* ColorChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ColorOverLifetimeModule.prototype, "_color", void 0);
            return ColorOverLifetimeModule;
        }(ParticleSystemModule));
        particle.ColorOverLifetimeModule = ColorOverLifetimeModule;
        __reflect(ColorOverLifetimeModule.prototype, "egret3d.particle.ColorOverLifetimeModule");
        var SizeOverLifetimeModule = (function (_super) {
            __extends(SizeOverLifetimeModule, _super);
            function SizeOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._separateAxes = false;
                /**
                 * @internal
                 */
                _this._size = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._x = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._y = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._z = new MinMaxCurve();
                return _this;
            }
            SizeOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._size.deserialize(element._size || element.size);
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
            };
            Object.defineProperty(SizeOverLifetimeModule.prototype, "separateAxes", {
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes !== value) {
                        this._separateAxes = value;
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "size", {
                get: function () {
                    return this._size;
                },
                set: function (value) {
                    if (this._size !== value) {
                        this._size.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._x !== value) {
                        this._x.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._y !== value) {
                        this._y.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "z", {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    if (this._z !== value) {
                        this._z.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_size", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_z", void 0);
            return SizeOverLifetimeModule;
        }(ParticleSystemModule));
        particle.SizeOverLifetimeModule = SizeOverLifetimeModule;
        __reflect(SizeOverLifetimeModule.prototype, "egret3d.particle.SizeOverLifetimeModule");
        var RotationOverLifetimeModule = (function (_super) {
            __extends(RotationOverLifetimeModule, _super);
            function RotationOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._x = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._y = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._z = new MinMaxCurve();
                return _this;
            }
            RotationOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
            };
            Object.defineProperty(RotationOverLifetimeModule.prototype, "separateAxes", {
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes !== value) {
                        this._separateAxes = value;
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._x !== value) {
                        this._x.clone(value);
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._y !== value) {
                        this._y.clone(value);
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "z", {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    if (this._z !== value) {
                        this._z.clone(value);
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_z", void 0);
            return RotationOverLifetimeModule;
        }(ParticleSystemModule));
        particle.RotationOverLifetimeModule = RotationOverLifetimeModule;
        __reflect(RotationOverLifetimeModule.prototype, "egret3d.particle.RotationOverLifetimeModule");
        var TextureSheetAnimationModule = (function (_super) {
            __extends(TextureSheetAnimationModule, _super);
            function TextureSheetAnimationModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._animation = 0 /* WholeSheet */;
                /**
                 * @internal
                 */
                _this._frameOverTime = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._startFrame = new MinMaxCurve();
                _this._floatValues = new Float32Array(4);
                return _this;
            }
            TextureSheetAnimationModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._numTilesX = (element._numTilesX || element.numTilesX) || 0;
                this._numTilesY = (element._numTilesY || element.numTilesY) || 0;
                this._animation = (element._animation || element.animation) || 0 /* WholeSheet */;
                this._useRandomRow = (element._useRandomRow || element.useRandomRow) || false;
                this._frameOverTime.deserialize(element._frameOverTime || element.frameOverTime);
                this._startFrame.deserialize(element._startFrame || element.startFrame);
                this._cycleCount = (element._cycleCount || element.cycleCount) || 0;
                this._rowIndex = (element._rowIndex || element.rowIndex) || 0;
            };
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesX", {
                get: function () {
                    return this._numTilesX;
                },
                set: function (value) {
                    if (this._numTilesX !== value) {
                        this._numTilesX = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesY", {
                get: function () {
                    return this._numTilesY;
                },
                set: function (value) {
                    if (this._numTilesY !== value) {
                        this._numTilesY = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "animation", {
                get: function () {
                    return this._animation;
                },
                set: function (value) {
                    if (this._animation !== value) {
                        this._animation = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "useRandomRow", {
                get: function () {
                    return this._useRandomRow;
                },
                set: function (value) {
                    if (this._useRandomRow !== value) {
                        this._useRandomRow = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "frameOverTime", {
                get: function () {
                    return this._frameOverTime;
                },
                set: function (value) {
                    if (this._frameOverTime !== value) {
                        this._frameOverTime.clone(value);
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "startFrame", {
                get: function () {
                    return this._startFrame;
                },
                set: function (value) {
                    if (this._startFrame !== value) {
                        this._startFrame.clone(value);
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "cycleCount", {
                get: function () {
                    return this._cycleCount;
                },
                set: function (value) {
                    if (this._cycleCount !== value) {
                        this._cycleCount = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "rowIndex", {
                get: function () {
                    return this._rowIndex;
                },
                set: function (value) {
                    if (this._rowIndex !== value) {
                        this._rowIndex = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    if (this.enable) {
                        var subU = 1.0 / this._numTilesX;
                        var subV = 1.0 / this._numTilesY;
                        var startFrmaeCount = Math.floor(this._startFrame.constant);
                        var startRow = 0;
                        switch (this._animation) {
                            case 1 /* SingleRow */:
                                {
                                    if (this._useRandomRow) {
                                        startRow = Math.floor(Math.random() * this._numTilesY);
                                    }
                                    else {
                                        startRow = this._rowIndex;
                                    }
                                    break;
                                }
                            case 0 /* WholeSheet */:
                                {
                                    startRow = Math.floor(startFrmaeCount / this._numTilesX);
                                    break;
                                }
                        }
                        var startCol = Math.floor(startFrmaeCount % this._numTilesX);
                        res[0] = subU;
                        res[1] = subV;
                        res[2] = startCol * subU;
                        res[3] = startRow * subV;
                    }
                    else {
                        res[0] = 1.0;
                        res[1] = 1.0;
                        res[2] = 0.0;
                        res[3] = 0.0;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesX", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesY", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_animation", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_useRandomRow", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_frameOverTime", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_startFrame", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_cycleCount", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_rowIndex", void 0);
            return TextureSheetAnimationModule;
        }(ParticleSystemModule));
        particle.TextureSheetAnimationModule = TextureSheetAnimationModule;
        __reflect(TextureSheetAnimationModule.prototype, "egret3d.particle.TextureSheetAnimationModule");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
